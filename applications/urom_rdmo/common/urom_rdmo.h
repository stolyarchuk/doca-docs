/*
 * Copyright (c) 2024 NVIDIA CORPORATION AND AFFILIATES.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted
 * provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright notice, this list of
 *       conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright notice, this list of
 *       conditions and the following disclaimer in the documentation and/or other materials
 *       provided with the distribution.
 *     * Neither the name of the NVIDIA CORPORATION nor the names of its contributors may be used
 *       to endorse or promote products derived from this software without specific prior written
 *       permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NVIDIA CORPORATION BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TOR (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#ifndef UROM_RDMO_H_
#define UROM_RDMO_H_

#include "ucp/api/ucp.h"

#ifdef __cplusplus
extern "C" {
#endif

/* RDMO serializing next raw, iter points to the offset place and returns the buffer start */
#define urom_rdmo_serialize_next_raw(_iter, _type, _offset) \
	({ \
		_type *_result = (_type *)(*(_iter)); \
		*(_iter) = UCS_PTR_BYTE_OFFSET(*(_iter), _offset); \
		_result; \
	})

/* RDMO command types */
enum urom_worker_rdmo_cmd_type {
	UROM_WORKER_CMD_RDMO_CLIENT_INIT, /* Establish host<->DPU RDMA channel command */
	UROM_WORKER_CMD_RDMO_RQ_CREATE,	  /* Create RQ connected to peer worker command */
	UROM_WORKER_CMD_RDMO_RQ_DESTROY,  /* Destroy RQ command */
	UROM_WORKER_CMD_RDMO_MR_REG,	  /* Register target memory region command */
	UROM_WORKER_CMD_RDMO_MR_DEREG,	  /* Deregister target memory region command */
};

/* RDMO client init command structure */
struct urom_worker_rdmo_cmd_client_init {
	uint64_t id;	   /* ID used to identify client in requests */
	void *addr;	   /* Local UCP worker address */
	uint64_t addr_len; /* Local UCP worker address length */
};

/* RDMO create RQ command structure */
struct urom_worker_rdmo_cmd_rq_create {
	void *addr;	   /* Peer UCP worker address */
	uint64_t addr_len; /* Peer UCP worker address length */
};

/* RDMO destroy RQ command structure */
struct urom_worker_rdmo_cmd_rq_destroy {
	uint64_t rq_id; /* RQ id to destroy on DPU worker side */
};

/* RDMO register MR command structure */
struct urom_worker_rdmo_cmd_mr_reg {
	uint64_t va;		  /* Memory virtual address to register */
	uint64_t len;		  /* Memory length */
	void *packed_rkey;	  /* Packed memory remote key, generated by UCX API */
	uint64_t packed_rkey_len; /* Packed memory remote key length */
	void *packed_memh;	  /* Packed memory handle for XGVMI, generated by UCX API */
	uint64_t packed_memh_len; /* Packed memory handle length */
};

/* RDMO client init command structure */
struct urom_worker_rdmo_cmd_mr_dereg {
	uint64_t rkey; /* Remote memory key to deregister */
};

/* UROM RDMO worker command structure */
struct urom_worker_rdmo_cmd {
	uint64_t type; /* Type of command as defined by urom_worker_rdmo_cmd_type */
	union {
		struct urom_worker_rdmo_cmd_client_init client_init; /* Client init command */
		struct urom_worker_rdmo_cmd_rq_create rq_create;     /* RQ create command */
		struct urom_worker_rdmo_cmd_rq_destroy rq_destroy;   /* RQ destroy command */
		struct urom_worker_rdmo_cmd_mr_reg mr_reg;	     /* Memory region register command */
		struct urom_worker_rdmo_cmd_mr_dereg mr_dereg;	     /* Memory region deregister command */
	};
};

/* RDMO notification types */
enum urom_worker_rdmo_notify_type {
	UROM_WORKER_NOTIFY_RDMO_CLIENT_INIT, /* Establish host<->DPU RDMA channel notification */

	UROM_WORKER_NOTIFY_RDMO_RQ_CREATE, /* Create RQ connected to peer worker notification */

	UROM_WORKER_NOTIFY_RDMO_RQ_DESTROY, /* Destroy RQ notification */

	UROM_WORKER_NOTIFY_RDMO_MR_REG,	  /* Register target memory region notification */
	UROM_WORKER_NOTIFY_RDMO_MR_DEREG, /* Deregister target memory region notification */
};

/* RDMO client init notification structure */
struct urom_worker_rdmo_notify_client_init {
	void *addr;	   /* Device UCP worker address */
	uint64_t addr_len; /* Device UCP worker address length */
};

/* RDMO create RQ notification structure */
struct urom_worker_rdmo_notify_rq_create {
	uint64_t rq_id; /* Receive queue id */
};

/* RDMO destroy RQ notification structure */
struct urom_worker_rdmo_notify_rq_destroy {
	uint64_t rq_id; /* Destroyed receive queue id */
};

/* RDMO register MR notification structure */
struct urom_worker_rdmo_notify_mr_reg {
	uint64_t rkey; /* Memory region remote key */
};

/* RDMO deregister MR notification structure */
struct urom_worker_rdmo_notify_mr_dereg {
	uint64_t rkey; /* Memory region remote key */
};

/* UROM RDMO worker notification structure */
struct urom_worker_notify_rdmo {
	uint64_t type; /* Notify type as defined by urom_worker_rdmo_notify_type */
	union {
		struct urom_worker_rdmo_notify_client_init client_init; /* Client init notification */
		struct urom_worker_rdmo_notify_rq_create rq_create;	/* RQ create notification */
		struct urom_worker_rdmo_notify_rq_destroy rq_destroy;	/* RQ destroy notification */
		struct urom_worker_rdmo_notify_mr_reg mr_reg;		/* MR register notification */
		struct urom_worker_rdmo_notify_mr_dereg mr_dereg;	/* MR deregister notification */
	};
};

/* RDMO request flags */
enum urom_rdmo_req_flags {
	UROM_RDMO_REQ_FLAG_FENCE = 1 << 0, /* Complete outstanding ops on this connection before executing request */
};

/* RDMO operations id */
enum urom_rdmo_op_id {
	UROM_RDMO_OP_FLUSH,   /* RDMO flush operation */
	UROM_RDMO_OP_APPEND,  /* RDMO append operation */
	UROM_RDMO_OP_SCATTER, /* RDMO scatter operation */
};

/* RDMO header structure */
struct urom_rdmo_hdr {
	uint64_t id;	/* Client id */
	uint32_t op_id; /* operation id */
	uint32_t flags; /* operation flag */
};

/* RDMO flush header structure */
struct urom_rdmo_flush_hdr {
	uint64_t flush_id; /* Flush id */
};

/* RDMO append header structure */
struct urom_rdmo_append_hdr {
	uint64_t ptr_addr;  /* Memory pointer for append operation */
	uint64_t ptr_rkey;  /* Pointer remote key */
	uint64_t data_rkey; /* Data remote key */
};

/* RDMO scatter header structure */
struct urom_rdmo_scatter_hdr {
	uint64_t count; /* Number of IOVs in the payload */
};

/*
 * IOVs are packed into the Scatter request payload, descriptor followed by data:
 *
 *    | iov 0 | data | iov 1 | data | iov 2 | data |
 */
struct urom_rdmo_scatter_iov {
	uint64_t addr; /* Scattered data address */
	uint64_t rkey; /* Data remote key */
	uint16_t len;  /* Data length */
};

/* RDMO response id */
enum urom_rdmo_rsp_id {
	UROM_RDMO_RSP_FLUSH, /* RDMO flush response id */
};

/* RDMO response header */
struct urom_rdmo_rsp_hdr {
	uint32_t rsp_id; /* RDMO response id */
};

/* RDMO flush response header */
struct urom_rdmo_flush_rsp_hdr {
	uint64_t flush_id; /* Flush id */
};

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* UROM_RDMO_H_ */
