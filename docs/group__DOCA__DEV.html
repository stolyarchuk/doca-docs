<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NVIDIA DOCA SDK: DOCA Device</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<!-- Doxygen Awesome CSS -->
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript">
DoxygenAwesomeDarkModeToggle.init()
DoxygenAwesomeFragmentCopyButton.init()
DoxygenAwesomeParagraphLink.init()
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectname">NVIDIA DOCA SDK
  </td>
  <td id="projectbrief">Data Center on a Chip Framework Documentation</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__DOCA__DEV.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">DOCA Device<div class="ingroups"><a class="el" href="group__DOCACore.html">DOCA Core</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for DOCA Device:</div>
<div class="dyncontent">
<div class="center"><img src="group__DOCA__DEV.png" border="0" usemap="#agroup____DOCA____DEV" alt=""/></div>
<map name="agroup____DOCA____DEV" id="agroup____DOCA____DEV">
<area shape="rect" href="group__DOCACore.html" title=" " alt="" coords="5,5,100,31"/>
<area shape="rect" title=" " alt="" coords="148,5,257,31"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga999d29ad6ea7c582690813ca21da225e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__DEV.html#ga999d29ad6ea7c582690813ca21da225e">DOCA_DEVINFO_VUID_SIZE</a>&#160;&#160;&#160;128</td></tr>
<tr class="memdesc:ga999d29ad6ea7c582690813ca21da225e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Buffer size to hold VUID. Including a null terminator.  <a href="group__DOCA__DEV.html#ga999d29ad6ea7c582690813ca21da225e">More...</a><br /></td></tr>
<tr class="separator:ga999d29ad6ea7c582690813ca21da225e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49d0d90e1d68d9f48252b75880ad4830"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__DEV.html#ga49d0d90e1d68d9f48252b75880ad4830">DOCA_DEVINFO_IPV4_ADDR_SIZE</a>&#160;&#160;&#160;4</td></tr>
<tr class="memdesc:ga49d0d90e1d68d9f48252b75880ad4830"><td class="mdescLeft">&#160;</td><td class="mdescRight">Length of IPv4 address.  <a href="group__DOCA__DEV.html#ga49d0d90e1d68d9f48252b75880ad4830">More...</a><br /></td></tr>
<tr class="separator:ga49d0d90e1d68d9f48252b75880ad4830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade055bc4d38d116f51bb122f561f1a47"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__DEV.html#gade055bc4d38d116f51bb122f561f1a47">DOCA_DEVINFO_IPV6_ADDR_SIZE</a>&#160;&#160;&#160;16</td></tr>
<tr class="memdesc:gade055bc4d38d116f51bb122f561f1a47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Length of IPv6 address.  <a href="group__DOCA__DEV.html#gade055bc4d38d116f51bb122f561f1a47">More...</a><br /></td></tr>
<tr class="separator:gade055bc4d38d116f51bb122f561f1a47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa86d13367b043a02b6cad94cddc11922"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__DEV.html#gaa86d13367b043a02b6cad94cddc11922">DOCA_DEVINFO_MAC_ADDR_SIZE</a>&#160;&#160;&#160;6</td></tr>
<tr class="memdesc:gaa86d13367b043a02b6cad94cddc11922"><td class="mdescLeft">&#160;</td><td class="mdescRight">Length of MAC address.  <a href="group__DOCA__DEV.html#gaa86d13367b043a02b6cad94cddc11922">More...</a><br /></td></tr>
<tr class="separator:gaa86d13367b043a02b6cad94cddc11922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2bd4b0f403a1c6031799a30b6fdfb6e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__DEV.html#gab2bd4b0f403a1c6031799a30b6fdfb6e">DOCA_DEVINFO_IFACE_NAME_SIZE</a>&#160;&#160;&#160;256</td></tr>
<tr class="memdesc:gab2bd4b0f403a1c6031799a30b6fdfb6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Buffer size to hold network interface name. Including a null terminator.  <a href="group__DOCA__DEV.html#gab2bd4b0f403a1c6031799a30b6fdfb6e">More...</a><br /></td></tr>
<tr class="separator:gab2bd4b0f403a1c6031799a30b6fdfb6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89ed3930fb9bf117ca749da1afc915f2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__DEV.html#ga89ed3930fb9bf117ca749da1afc915f2">DOCA_DEVINFO_IBDEV_NAME_SIZE</a>&#160;&#160;&#160;64</td></tr>
<tr class="memdesc:ga89ed3930fb9bf117ca749da1afc915f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Buffer size to hold Infiniband/RoCE device name. Including a null terminator.  <a href="group__DOCA__DEV.html#ga89ed3930fb9bf117ca749da1afc915f2">More...</a><br /></td></tr>
<tr class="separator:ga89ed3930fb9bf117ca749da1afc915f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab37ab164ce9af0c9d23c40781123ce04"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__DEV.html#gab37ab164ce9af0c9d23c40781123ce04">DOCA_DEVINFO_PCI_ADDR_SIZE</a>&#160;&#160;&#160;13</td></tr>
<tr class="memdesc:gab37ab164ce9af0c9d23c40781123ce04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Buffer size to hold PCI BDF format: "XXXX:XX:XX.X". Including a null terminator.  <a href="group__DOCA__DEV.html#gab37ab164ce9af0c9d23c40781123ce04">More...</a><br /></td></tr>
<tr class="separator:gab37ab164ce9af0c9d23c40781123ce04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0eb2a3bc02ee450888899a50c50c3f2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__DEV.html#gaa0eb2a3bc02ee450888899a50c50c3f2">DOCA_DEVINFO_PCI_BDF_SIZE</a>&#160;&#160;&#160;8</td></tr>
<tr class="memdesc:gaa0eb2a3bc02ee450888899a50c50c3f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Buffer size to hold PCI BDF format: "XX:XX.X". Including a null terminator.  <a href="group__DOCA__DEV.html#gaa0eb2a3bc02ee450888899a50c50c3f2">More...</a><br /></td></tr>
<tr class="separator:gaa0eb2a3bc02ee450888899a50c50c3f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f106b0cac1e3525c281a95c42e36084"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__DEV.html#ga9f106b0cac1e3525c281a95c42e36084">DOCA_DEVINFO_REP_VUID_SIZE</a>&#160;&#160;&#160;128</td></tr>
<tr class="memdesc:ga9f106b0cac1e3525c281a95c42e36084"><td class="mdescLeft">&#160;</td><td class="mdescRight">Buffer size to hold VUID. Including a null terminator.  <a href="group__DOCA__DEV.html#ga9f106b0cac1e3525c281a95c42e36084">More...</a><br /></td></tr>
<tr class="separator:ga9f106b0cac1e3525c281a95c42e36084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f8cb8d30f48187dccb90049a7e3a4a6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__DEV.html#ga3f8cb8d30f48187dccb90049a7e3a4a6">DOCA_DEVINFO_REP_PCI_ADDR_SIZE</a>&#160;&#160;&#160;13</td></tr>
<tr class="memdesc:ga3f8cb8d30f48187dccb90049a7e3a4a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Buffer size to hold PCI BDF format: "XXXX:XX:XX.X". Including a null terminator.  <a href="group__DOCA__DEV.html#ga3f8cb8d30f48187dccb90049a7e3a4a6">More...</a><br /></td></tr>
<tr class="separator:ga3f8cb8d30f48187dccb90049a7e3a4a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bb2ff8642a451b8c1fe9079ff152b23"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__DEV.html#ga2bb2ff8642a451b8c1fe9079ff152b23">DOCA_DEVINFO_REP_PCI_BDF_SIZE</a>&#160;&#160;&#160;8</td></tr>
<tr class="memdesc:ga2bb2ff8642a451b8c1fe9079ff152b23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Buffer size to hold PCI BDF format: "XX:XX.X". Including a null terminator.  <a href="group__DOCA__DEV.html#ga2bb2ff8642a451b8c1fe9079ff152b23">More...</a><br /></td></tr>
<tr class="separator:ga2bb2ff8642a451b8c1fe9079ff152b23"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga81104c7206619da197ab557e437e35b6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__DEV.html#ga81104c7206619da197ab557e437e35b6">doca_devinfo_rep_filter</a> { <a class="el" href="group__DOCA__DEV.html#gga81104c7206619da197ab557e437e35b6a17f5aea6d2b893010af966f2b504ce70">DOCA_DEVINFO_REP_FILTER_ALL</a> = 0
, <a class="el" href="group__DOCA__DEV.html#gga81104c7206619da197ab557e437e35b6aa07707d4953ebdaef942ba0d0104fe37">DOCA_DEVINFO_REP_FILTER_NET</a> = 1 &lt;&lt; 1
, <a class="el" href="group__DOCA__DEV.html#gga81104c7206619da197ab557e437e35b6a4c773d4223bca682371a6c444a5deaf2">DOCA_DEVINFO_REP_FILTER_EMULATED</a> = 1 &lt;&lt; 2
 }</td></tr>
<tr class="separator:ga81104c7206619da197ab557e437e35b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga393730414c11746f1bb3eb9333c37178"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#gabf4c2072da5a4674395e37df60eb4b1c">DOCA_STABLE</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__DEV.html#ga393730414c11746f1bb3eb9333c37178">doca_devinfo_create_list</a> (struct doca_devinfo ***dev_list, uint32_t *nb_devs)</td></tr>
<tr class="memdesc:ga393730414c11746f1bb3eb9333c37178"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates list of all available local devices.  <a href="group__DOCA__DEV.html#ga393730414c11746f1bb3eb9333c37178">More...</a><br /></td></tr>
<tr class="separator:ga393730414c11746f1bb3eb9333c37178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1d83f59f8b119eab404b7f7aa70c8df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#gabf4c2072da5a4674395e37df60eb4b1c">DOCA_STABLE</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__DEV.html#gaa1d83f59f8b119eab404b7f7aa70c8df">doca_devinfo_destroy_list</a> (struct doca_devinfo **dev_list)</td></tr>
<tr class="memdesc:gaa1d83f59f8b119eab404b7f7aa70c8df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy list of local device info structures.  <a href="group__DOCA__DEV.html#gaa1d83f59f8b119eab404b7f7aa70c8df">More...</a><br /></td></tr>
<tr class="separator:gaa1d83f59f8b119eab404b7f7aa70c8df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2fa28108fd69670b43a0d41e1b7c29e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#gabf4c2072da5a4674395e37df60eb4b1c">DOCA_STABLE</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__DEV.html#ga2fa28108fd69670b43a0d41e1b7c29e2">doca_devinfo_rep_create_list</a> (struct doca_dev *dev, int filter, struct doca_devinfo_rep ***dev_list_rep, uint32_t *nb_devs_rep)</td></tr>
<tr class="memdesc:ga2fa28108fd69670b43a0d41e1b7c29e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create list of available representor devices accessible by dev.  <a href="group__DOCA__DEV.html#ga2fa28108fd69670b43a0d41e1b7c29e2">More...</a><br /></td></tr>
<tr class="separator:ga2fa28108fd69670b43a0d41e1b7c29e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e23e07b6aedc9d3eb7823469d5cc180"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#gabf4c2072da5a4674395e37df60eb4b1c">DOCA_STABLE</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__DEV.html#ga2e23e07b6aedc9d3eb7823469d5cc180">doca_devinfo_rep_destroy_list</a> (struct doca_devinfo_rep **dev_list_rep)</td></tr>
<tr class="memdesc:ga2e23e07b6aedc9d3eb7823469d5cc180"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy list of representor device info structures.  <a href="group__DOCA__DEV.html#ga2e23e07b6aedc9d3eb7823469d5cc180">More...</a><br /></td></tr>
<tr class="separator:ga2e23e07b6aedc9d3eb7823469d5cc180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab4c7fb74286dae59074406e6c8da202"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#gabf4c2072da5a4674395e37df60eb4b1c">DOCA_STABLE</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__DEV.html#gaab4c7fb74286dae59074406e6c8da202">doca_dev_open</a> (struct doca_devinfo *devinfo, struct doca_dev **dev)</td></tr>
<tr class="memdesc:gaab4c7fb74286dae59074406e6c8da202"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize local device for use.  <a href="group__DOCA__DEV.html#gaab4c7fb74286dae59074406e6c8da202">More...</a><br /></td></tr>
<tr class="separator:gaab4c7fb74286dae59074406e6c8da202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0ed06d8099c38aea195a30e7fef06cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#gabf4c2072da5a4674395e37df60eb4b1c">DOCA_STABLE</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__DEV.html#gae0ed06d8099c38aea195a30e7fef06cc">doca_dev_close</a> (struct doca_dev *dev)</td></tr>
<tr class="memdesc:gae0ed06d8099c38aea195a30e7fef06cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy allocated local device instance.  <a href="group__DOCA__DEV.html#gae0ed06d8099c38aea195a30e7fef06cc">More...</a><br /></td></tr>
<tr class="separator:gae0ed06d8099c38aea195a30e7fef06cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89f556191ea0914c6f1793255df1c1e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__DEV.html#ga89f556191ea0914c6f1793255df1c1e5">doca_dev_accelerate_resource_reclaim</a> (struct doca_dev *dev)</td></tr>
<tr class="memdesc:ga89f556191ea0914c6f1793255df1c1e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accelerates the reclaim process for a local device instance.  <a href="group__DOCA__DEV.html#ga89f556191ea0914c6f1793255df1c1e5">More...</a><br /></td></tr>
<tr class="separator:ga89f556191ea0914c6f1793255df1c1e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1da87e3e6a965ca3ddd7fad6a6866f14"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#gabf4c2072da5a4674395e37df60eb4b1c">DOCA_STABLE</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__DEV.html#ga1da87e3e6a965ca3ddd7fad6a6866f14">doca_dev_rep_open</a> (struct doca_devinfo_rep *devinfo, struct doca_dev_rep **dev_rep)</td></tr>
<tr class="memdesc:ga1da87e3e6a965ca3ddd7fad6a6866f14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize representor device for use.  <a href="group__DOCA__DEV.html#ga1da87e3e6a965ca3ddd7fad6a6866f14">More...</a><br /></td></tr>
<tr class="separator:ga1da87e3e6a965ca3ddd7fad6a6866f14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b916bf433559e8694ff1659e3e57623"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#gabf4c2072da5a4674395e37df60eb4b1c">DOCA_STABLE</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__DEV.html#ga4b916bf433559e8694ff1659e3e57623">doca_dev_rep_close</a> (struct doca_dev_rep *dev)</td></tr>
<tr class="memdesc:ga4b916bf433559e8694ff1659e3e57623"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy allocated representor device instance.  <a href="group__DOCA__DEV.html#ga4b916bf433559e8694ff1659e3e57623">More...</a><br /></td></tr>
<tr class="separator:ga4b916bf433559e8694ff1659e3e57623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabebb0f3457d76fda2b0c07e4a95a5109"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#gabf4c2072da5a4674395e37df60eb4b1c">DOCA_STABLE</a> struct doca_devinfo *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__DEV.html#gabebb0f3457d76fda2b0c07e4a95a5109">doca_dev_as_devinfo</a> (const struct doca_dev *dev)</td></tr>
<tr class="memdesc:gabebb0f3457d76fda2b0c07e4a95a5109"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get local device info from device. This should be useful when wanting to query information about device after opening it, and destroying the devinfo list.  <a href="group__DOCA__DEV.html#gabebb0f3457d76fda2b0c07e4a95a5109">More...</a><br /></td></tr>
<tr class="separator:gabebb0f3457d76fda2b0c07e4a95a5109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4c47356fcaa1616b433dd0edc1ab6c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#gabf4c2072da5a4674395e37df60eb4b1c">DOCA_STABLE</a> struct doca_devinfo_rep *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__DEV.html#gab4c47356fcaa1616b433dd0edc1ab6c3">doca_dev_rep_as_devinfo</a> (struct doca_dev_rep *dev_rep)</td></tr>
<tr class="memdesc:gab4c47356fcaa1616b433dd0edc1ab6c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get representor device info from device. This should be useful when wanting to query information about device after opening it, and destroying the devinfo list.  <a href="group__DOCA__DEV.html#gab4c47356fcaa1616b433dd0edc1ab6c3">More...</a><br /></td></tr>
<tr class="separator:gab4c47356fcaa1616b433dd0edc1ab6c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadeb317cf45b41f4102682a2fd8f50bfe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#gabf4c2072da5a4674395e37df60eb4b1c">DOCA_STABLE</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__DEV.html#gadeb317cf45b41f4102682a2fd8f50bfe">doca_devinfo_get_pci_addr_str</a> (const struct doca_devinfo *devinfo, char *pci_addr_str)</td></tr>
<tr class="memdesc:gadeb317cf45b41f4102682a2fd8f50bfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the PCI address of a DOCA devinfo.  <a href="group__DOCA__DEV.html#gadeb317cf45b41f4102682a2fd8f50bfe">More...</a><br /></td></tr>
<tr class="separator:gadeb317cf45b41f4102682a2fd8f50bfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14192ad7c7e57118c75930998270fde6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#gabf4c2072da5a4674395e37df60eb4b1c">DOCA_STABLE</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__DEV.html#ga14192ad7c7e57118c75930998270fde6">doca_devinfo_is_equal_pci_addr</a> (const struct doca_devinfo *devinfo, const char *pci_addr_str, uint8_t *is_equal)</td></tr>
<tr class="memdesc:ga14192ad7c7e57118c75930998270fde6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a PCI address belongs to a DOCA devinfo.  <a href="group__DOCA__DEV.html#ga14192ad7c7e57118c75930998270fde6">More...</a><br /></td></tr>
<tr class="separator:ga14192ad7c7e57118c75930998270fde6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3843c27432ddcd812c61c94e40fceed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#gabf4c2072da5a4674395e37df60eb4b1c">DOCA_STABLE</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__DEV.html#gab3843c27432ddcd812c61c94e40fceed">doca_devinfo_get_ipv4_addr</a> (const struct doca_devinfo *devinfo, uint8_t *ipv4_addr, uint32_t size)</td></tr>
<tr class="memdesc:gab3843c27432ddcd812c61c94e40fceed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the IPv4 address of a DOCA devinfo.  <a href="group__DOCA__DEV.html#gab3843c27432ddcd812c61c94e40fceed">More...</a><br /></td></tr>
<tr class="separator:gab3843c27432ddcd812c61c94e40fceed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c90d7311045baabd77beec18c1ad258"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#gabf4c2072da5a4674395e37df60eb4b1c">DOCA_STABLE</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__DEV.html#ga5c90d7311045baabd77beec18c1ad258">doca_devinfo_get_ipv6_addr</a> (const struct doca_devinfo *devinfo, uint8_t *ipv6_addr, uint32_t size)</td></tr>
<tr class="memdesc:ga5c90d7311045baabd77beec18c1ad258"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the IPv6 address of a DOCA devinfo.  <a href="group__DOCA__DEV.html#ga5c90d7311045baabd77beec18c1ad258">More...</a><br /></td></tr>
<tr class="separator:ga5c90d7311045baabd77beec18c1ad258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0850dbe9ed78de7a39d765f49647eb4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#gabf4c2072da5a4674395e37df60eb4b1c">DOCA_STABLE</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__DEV.html#gab0850dbe9ed78de7a39d765f49647eb4">doca_devinfo_get_mac_addr</a> (const struct doca_devinfo *devinfo, uint8_t *mac_addr, uint32_t size)</td></tr>
<tr class="memdesc:gab0850dbe9ed78de7a39d765f49647eb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the MAC address of a DOCA devinfo.  <a href="group__DOCA__DEV.html#gab0850dbe9ed78de7a39d765f49647eb4">More...</a><br /></td></tr>
<tr class="separator:gab0850dbe9ed78de7a39d765f49647eb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbb5a342d9269095c0a4690a0ff34702"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#gabf4c2072da5a4674395e37df60eb4b1c">DOCA_STABLE</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__DEV.html#gadbb5a342d9269095c0a4690a0ff34702">doca_devinfo_get_iface_name</a> (const struct doca_devinfo *devinfo, char *iface_name, uint32_t size)</td></tr>
<tr class="memdesc:gadbb5a342d9269095c0a4690a0ff34702"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of the ethernet interface of a DOCA devinfo.  <a href="group__DOCA__DEV.html#gadbb5a342d9269095c0a4690a0ff34702">More...</a><br /></td></tr>
<tr class="separator:gadbb5a342d9269095c0a4690a0ff34702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68fadeeaf5d187a069208eb6aeafea40"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#gabf4c2072da5a4674395e37df60eb4b1c">DOCA_STABLE</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__DEV.html#ga68fadeeaf5d187a069208eb6aeafea40">doca_devinfo_get_ibdev_name</a> (const struct doca_devinfo *devinfo, char *ibdev_name, uint32_t size)</td></tr>
<tr class="memdesc:ga68fadeeaf5d187a069208eb6aeafea40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of the IB device represented by a DOCA devinfo.  <a href="group__DOCA__DEV.html#ga68fadeeaf5d187a069208eb6aeafea40">More...</a><br /></td></tr>
<tr class="separator:ga68fadeeaf5d187a069208eb6aeafea40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad12b1c8f272a58e3ef0542c2d2ddfcfe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#gabf4c2072da5a4674395e37df60eb4b1c">DOCA_STABLE</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__DEV.html#gad12b1c8f272a58e3ef0542c2d2ddfcfe">doca_devinfo_get_lid</a> (const struct doca_devinfo *devinfo, uint16_t *lid)</td></tr>
<tr class="memdesc:gad12b1c8f272a58e3ef0542c2d2ddfcfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the port LID of a DOCA devinfo.  <a href="group__DOCA__DEV.html#gad12b1c8f272a58e3ef0542c2d2ddfcfe">More...</a><br /></td></tr>
<tr class="separator:gad12b1c8f272a58e3ef0542c2d2ddfcfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd5c257a21d051d0b6a49a0adf4d0812"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__DEV.html#gafd5c257a21d051d0b6a49a0adf4d0812">doca_devinfo_get_active_rate</a> (const struct doca_devinfo *devinfo, uint64_t *active_rate)</td></tr>
<tr class="memdesc:gafd5c257a21d051d0b6a49a0adf4d0812"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the active rate of a DOCA devinfo.  <a href="group__DOCA__DEV.html#gafd5c257a21d051d0b6a49a0adf4d0812">More...</a><br /></td></tr>
<tr class="separator:gafd5c257a21d051d0b6a49a0adf4d0812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga403e2fb617e852698ff209387d096f84"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__DEV.html#ga403e2fb617e852698ff209387d096f84">doca_devinfo_get_vhca_id</a> (const struct doca_devinfo *devinfo, uint16_t *vhca_id)</td></tr>
<tr class="memdesc:ga403e2fb617e852698ff209387d096f84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get vhca id of a device.  <a href="group__DOCA__DEV.html#ga403e2fb617e852698ff209387d096f84">More...</a><br /></td></tr>
<tr class="separator:ga403e2fb617e852698ff209387d096f84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29baf8cd20004cae040df8ed14791fe1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#gabf4c2072da5a4674395e37df60eb4b1c">DOCA_STABLE</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__DEV.html#ga29baf8cd20004cae040df8ed14791fe1">doca_devinfo_cap_is_hotplug_manager_supported</a> (const struct doca_devinfo *devinfo, uint8_t *is_hotplug_manager)</td></tr>
<tr class="memdesc:ga29baf8cd20004cae040df8ed14791fe1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the hotplug manager capability of a DOCA devinfo.  <a href="group__DOCA__DEV.html#ga29baf8cd20004cae040df8ed14791fe1">More...</a><br /></td></tr>
<tr class="separator:ga29baf8cd20004cae040df8ed14791fe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga031c01c2da5960f7d25be6b9fe2c7b52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__DEV.html#ga031c01c2da5960f7d25be6b9fe2c7b52">doca_devinfo_cap_is_notification_moderation_supported</a> (const struct doca_devinfo *devinfo, uint8_t *is_notification_moderation_supported)</td></tr>
<tr class="memdesc:ga031c01c2da5960f7d25be6b9fe2c7b52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if notification moderation is supported for a device.  <a href="group__DOCA__DEV.html#ga031c01c2da5960f7d25be6b9fe2c7b52">More...</a><br /></td></tr>
<tr class="separator:ga031c01c2da5960f7d25be6b9fe2c7b52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44ee77c2040ca90e04d87ed3d56dd0ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#gabf4c2072da5a4674395e37df60eb4b1c">DOCA_STABLE</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__DEV.html#ga44ee77c2040ca90e04d87ed3d56dd0ae">doca_devinfo_rep_cap_is_filter_all_supported</a> (const struct doca_devinfo *devinfo, uint8_t *filter_all_supported)</td></tr>
<tr class="memdesc:ga44ee77c2040ca90e04d87ed3d56dd0ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the representor devices discovery capability of the device.  <a href="group__DOCA__DEV.html#ga44ee77c2040ca90e04d87ed3d56dd0ae">More...</a><br /></td></tr>
<tr class="separator:ga44ee77c2040ca90e04d87ed3d56dd0ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6d1976e9ca8c2f68a9f3cd42ffc97b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#gabf4c2072da5a4674395e37df60eb4b1c">DOCA_STABLE</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__DEV.html#gac6d1976e9ca8c2f68a9f3cd42ffc97b9">doca_devinfo_rep_cap_is_filter_net_supported</a> (const struct doca_devinfo *devinfo, uint8_t *filter_net_supported)</td></tr>
<tr class="memdesc:gac6d1976e9ca8c2f68a9f3cd42ffc97b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the remote net discovery capability of the device.  <a href="group__DOCA__DEV.html#gac6d1976e9ca8c2f68a9f3cd42ffc97b9">More...</a><br /></td></tr>
<tr class="separator:gac6d1976e9ca8c2f68a9f3cd42ffc97b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d9726b1c7fbf5077f5308b956907266"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#gabf4c2072da5a4674395e37df60eb4b1c">DOCA_STABLE</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__DEV.html#ga6d9726b1c7fbf5077f5308b956907266">doca_devinfo_rep_cap_is_filter_emulated_supported</a> (const struct doca_devinfo *devinfo, uint8_t *filter_emulated_supported)</td></tr>
<tr class="memdesc:ga6d9726b1c7fbf5077f5308b956907266"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the remote emulated device discovery capability of the device.  <a href="group__DOCA__DEV.html#ga6d9726b1c7fbf5077f5308b956907266">More...</a><br /></td></tr>
<tr class="separator:ga6d9726b1c7fbf5077f5308b956907266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8dbae0ff94ceee32b67962521bf72b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__DEV.html#gac8dbae0ff94ceee32b67962521bf72b4">doca_devinfo_cap_is_accelerate_resource_reclaim_supported</a> (const struct doca_devinfo *devinfo, uint8_t *is_accelerate_resource_reclaim)</td></tr>
<tr class="memdesc:gac8dbae0ff94ceee32b67962521bf72b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the accelerate resource reclaim capability of a DOCA devinfo.  <a href="group__DOCA__DEV.html#gac8dbae0ff94ceee32b67962521bf72b4">More...</a><br /></td></tr>
<tr class="separator:gac8dbae0ff94ceee32b67962521bf72b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50190abaab56874f7999a3aa87d749ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#gabf4c2072da5a4674395e37df60eb4b1c">DOCA_STABLE</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__DEV.html#ga50190abaab56874f7999a3aa87d749ed">doca_devinfo_rep_get_vuid</a> (const struct doca_devinfo_rep *devinfo_rep, char *rep_vuid, uint32_t size)</td></tr>
<tr class="memdesc:ga50190abaab56874f7999a3aa87d749ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Vendor Unique ID of a representor DOCA devinfo.  <a href="group__DOCA__DEV.html#ga50190abaab56874f7999a3aa87d749ed">More...</a><br /></td></tr>
<tr class="separator:ga50190abaab56874f7999a3aa87d749ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6322d1fd2af2cd1277a43bbd71e2b79c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#gabf4c2072da5a4674395e37df60eb4b1c">DOCA_STABLE</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__DEV.html#ga6322d1fd2af2cd1277a43bbd71e2b79c">doca_devinfo_rep_get_pci_addr_str</a> (const struct doca_devinfo_rep *devinfo_rep, char *pci_addr_str)</td></tr>
<tr class="memdesc:ga6322d1fd2af2cd1277a43bbd71e2b79c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the PCI address of a DOCA devinfo_rep.  <a href="group__DOCA__DEV.html#ga6322d1fd2af2cd1277a43bbd71e2b79c">More...</a><br /></td></tr>
<tr class="separator:ga6322d1fd2af2cd1277a43bbd71e2b79c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga822a2996cffa2eb8476dac662d40ae5a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#gabf4c2072da5a4674395e37df60eb4b1c">DOCA_STABLE</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__DEV.html#ga822a2996cffa2eb8476dac662d40ae5a">doca_devinfo_rep_get_pci_func_type</a> (const struct doca_devinfo_rep *devinfo_rep, enum <a class="el" href="group__DOCA__TYPES.html#gaed11d328cbae30cecb1e7c507e05d5f8">doca_pci_func_type</a> *pci_func_type)</td></tr>
<tr class="memdesc:ga822a2996cffa2eb8476dac662d40ae5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the PCI function type of a DOCA devinfo_rep.  <a href="group__DOCA__DEV.html#ga822a2996cffa2eb8476dac662d40ae5a">More...</a><br /></td></tr>
<tr class="separator:ga822a2996cffa2eb8476dac662d40ae5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53aefa72907daf82621d9e855220bdd5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#gabf4c2072da5a4674395e37df60eb4b1c">DOCA_STABLE</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__DEV.html#ga53aefa72907daf82621d9e855220bdd5">doca_devinfo_rep_get_is_hotplug</a> (const struct doca_devinfo_rep *devinfo_rep, uint8_t *is_hotplug)</td></tr>
<tr class="memdesc:ga53aefa72907daf82621d9e855220bdd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query whether the representor device is a hotplugged device.  <a href="group__DOCA__DEV.html#ga53aefa72907daf82621d9e855220bdd5">More...</a><br /></td></tr>
<tr class="separator:ga53aefa72907daf82621d9e855220bdd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf502c2d65e15fdeb0cd326e0e4b0ecd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__DEV.html#gaaf502c2d65e15fdeb0cd326e0e4b0ecd">doca_devinfo_rep_get_iface_name</a> (const struct doca_devinfo_rep *devinfo_rep, char *iface_name, uint32_t size)</td></tr>
<tr class="memdesc:gaaf502c2d65e15fdeb0cd326e0e4b0ecd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of the ethernet interface of a DOCA devinfo_rep.  <a href="group__DOCA__DEV.html#gaaf502c2d65e15fdeb0cd326e0e4b0ecd">More...</a><br /></td></tr>
<tr class="separator:gaaf502c2d65e15fdeb0cd326e0e4b0ecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8596784463ca5af842f6f2eb217e515"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__DEV.html#gae8596784463ca5af842f6f2eb217e515">doca_devinfo_rep_get_vhca_id</a> (const struct doca_devinfo_rep *devinfo_rep, uint16_t *vhca_id)</td></tr>
<tr class="memdesc:gae8596784463ca5af842f6f2eb217e515"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get vhca id of a DOCA devinfo_rep.  <a href="group__DOCA__DEV.html#gae8596784463ca5af842f6f2eb217e515">More...</a><br /></td></tr>
<tr class="separator:gae8596784463ca5af842f6f2eb217e515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5657dca1c2835646a52925665954a39"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#gabf4c2072da5a4674395e37df60eb4b1c">DOCA_STABLE</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__DEV.html#gab5657dca1c2835646a52925665954a39">doca_devinfo_rep_is_equal_pci_addr</a> (const struct doca_devinfo_rep *devinfo_rep, const char *pci_addr_str, uint8_t *is_equal)</td></tr>
<tr class="memdesc:gab5657dca1c2835646a52925665954a39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a PCI address belongs to a DOCA devinfo_rep.  <a href="group__DOCA__DEV.html#gab5657dca1c2835646a52925665954a39">More...</a><br /></td></tr>
<tr class="separator:gab5657dca1c2835646a52925665954a39"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The DOCA device represents an available processing unit backed by the HW or SW implementation. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga89ed3930fb9bf117ca749da1afc915f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga89ed3930fb9bf117ca749da1afc915f2">&#9670;&nbsp;</a></span>DOCA_DEVINFO_IBDEV_NAME_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DOCA_DEVINFO_IBDEV_NAME_SIZE&#160;&#160;&#160;64</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Buffer size to hold Infiniband/RoCE device name. Including a null terminator. </p>

<p class="definition">Definition at line <a class="el" href="doca__dev_8h_source.html#l00309">309</a> of file <a class="el" href="doca__dev_8h_source.html">doca_dev.h</a>.</p>

</div>
</div>
<a id="gab2bd4b0f403a1c6031799a30b6fdfb6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab2bd4b0f403a1c6031799a30b6fdfb6e">&#9670;&nbsp;</a></span>DOCA_DEVINFO_IFACE_NAME_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DOCA_DEVINFO_IFACE_NAME_SIZE&#160;&#160;&#160;256</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Buffer size to hold network interface name. Including a null terminator. </p>

<p class="definition">Definition at line <a class="el" href="doca__dev_8h_source.html#l00305">305</a> of file <a class="el" href="doca__dev_8h_source.html">doca_dev.h</a>.</p>

</div>
</div>
<a id="ga49d0d90e1d68d9f48252b75880ad4830"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga49d0d90e1d68d9f48252b75880ad4830">&#9670;&nbsp;</a></span>DOCA_DEVINFO_IPV4_ADDR_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DOCA_DEVINFO_IPV4_ADDR_SIZE&#160;&#160;&#160;4</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Length of IPv4 address. </p>

<p class="definition">Definition at line <a class="el" href="doca__dev_8h_source.html#l00293">293</a> of file <a class="el" href="doca__dev_8h_source.html">doca_dev.h</a>.</p>

</div>
</div>
<a id="gade055bc4d38d116f51bb122f561f1a47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade055bc4d38d116f51bb122f561f1a47">&#9670;&nbsp;</a></span>DOCA_DEVINFO_IPV6_ADDR_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DOCA_DEVINFO_IPV6_ADDR_SIZE&#160;&#160;&#160;16</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Length of IPv6 address. </p>

<p class="definition">Definition at line <a class="el" href="doca__dev_8h_source.html#l00297">297</a> of file <a class="el" href="doca__dev_8h_source.html">doca_dev.h</a>.</p>

</div>
</div>
<a id="gaa86d13367b043a02b6cad94cddc11922"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa86d13367b043a02b6cad94cddc11922">&#9670;&nbsp;</a></span>DOCA_DEVINFO_MAC_ADDR_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DOCA_DEVINFO_MAC_ADDR_SIZE&#160;&#160;&#160;6</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Length of MAC address. </p>

<p class="definition">Definition at line <a class="el" href="doca__dev_8h_source.html#l00301">301</a> of file <a class="el" href="doca__dev_8h_source.html">doca_dev.h</a>.</p>

</div>
</div>
<a id="gab37ab164ce9af0c9d23c40781123ce04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab37ab164ce9af0c9d23c40781123ce04">&#9670;&nbsp;</a></span>DOCA_DEVINFO_PCI_ADDR_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DOCA_DEVINFO_PCI_ADDR_SIZE&#160;&#160;&#160;13</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Buffer size to hold PCI BDF format: "XXXX:XX:XX.X". Including a null terminator. </p>

<p class="definition">Definition at line <a class="el" href="doca__dev_8h_source.html#l00313">313</a> of file <a class="el" href="doca__dev_8h_source.html">doca_dev.h</a>.</p>

</div>
</div>
<a id="gaa0eb2a3bc02ee450888899a50c50c3f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0eb2a3bc02ee450888899a50c50c3f2">&#9670;&nbsp;</a></span>DOCA_DEVINFO_PCI_BDF_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DOCA_DEVINFO_PCI_BDF_SIZE&#160;&#160;&#160;8</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Buffer size to hold PCI BDF format: "XX:XX.X". Including a null terminator. </p>

<p class="definition">Definition at line <a class="el" href="doca__dev_8h_source.html#l00317">317</a> of file <a class="el" href="doca__dev_8h_source.html">doca_dev.h</a>.</p>

</div>
</div>
<a id="ga3f8cb8d30f48187dccb90049a7e3a4a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f8cb8d30f48187dccb90049a7e3a4a6">&#9670;&nbsp;</a></span>DOCA_DEVINFO_REP_PCI_ADDR_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DOCA_DEVINFO_REP_PCI_ADDR_SIZE&#160;&#160;&#160;13</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Buffer size to hold PCI BDF format: "XXXX:XX:XX.X". Including a null terminator. </p>

<p class="definition">Definition at line <a class="el" href="doca__dev_8h_source.html#l00665">665</a> of file <a class="el" href="doca__dev_8h_source.html">doca_dev.h</a>.</p>

</div>
</div>
<a id="ga2bb2ff8642a451b8c1fe9079ff152b23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2bb2ff8642a451b8c1fe9079ff152b23">&#9670;&nbsp;</a></span>DOCA_DEVINFO_REP_PCI_BDF_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DOCA_DEVINFO_REP_PCI_BDF_SIZE&#160;&#160;&#160;8</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Buffer size to hold PCI BDF format: "XX:XX.X". Including a null terminator. </p>

<p class="definition">Definition at line <a class="el" href="doca__dev_8h_source.html#l00669">669</a> of file <a class="el" href="doca__dev_8h_source.html">doca_dev.h</a>.</p>

</div>
</div>
<a id="ga9f106b0cac1e3525c281a95c42e36084"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f106b0cac1e3525c281a95c42e36084">&#9670;&nbsp;</a></span>DOCA_DEVINFO_REP_VUID_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DOCA_DEVINFO_REP_VUID_SIZE&#160;&#160;&#160;128</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Buffer size to hold VUID. Including a null terminator. </p>

<p class="definition">Definition at line <a class="el" href="doca__dev_8h_source.html#l00661">661</a> of file <a class="el" href="doca__dev_8h_source.html">doca_dev.h</a>.</p>

</div>
</div>
<a id="ga999d29ad6ea7c582690813ca21da225e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga999d29ad6ea7c582690813ca21da225e">&#9670;&nbsp;</a></span>DOCA_DEVINFO_VUID_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DOCA_DEVINFO_VUID_SIZE&#160;&#160;&#160;128</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Buffer size to hold VUID. Including a null terminator. </p>

<p class="definition">Definition at line <a class="el" href="doca__dev_8h_source.html#l00289">289</a> of file <a class="el" href="doca__dev_8h_source.html">doca_dev.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga81104c7206619da197ab557e437e35b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga81104c7206619da197ab557e437e35b6">&#9670;&nbsp;</a></span>doca_devinfo_rep_filter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__DOCA__DEV.html#ga81104c7206619da197ab557e437e35b6">doca_devinfo_rep_filter</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Representor device filter by flavor</p>
<p>Multiple options possible but some are mutually exclusive. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga81104c7206619da197ab557e437e35b6a17f5aea6d2b893010af966f2b504ce70"></a>DOCA_DEVINFO_REP_FILTER_ALL&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga81104c7206619da197ab557e437e35b6aa07707d4953ebdaef942ba0d0104fe37"></a>DOCA_DEVINFO_REP_FILTER_NET&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga81104c7206619da197ab557e437e35b6a4c773d4223bca682371a6c444a5deaf2"></a>DOCA_DEVINFO_REP_FILTER_EMULATED&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="doca__dev_8h_source.html#l00065">65</a> of file <a class="el" href="doca__dev_8h_source.html">doca_dev.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga89f556191ea0914c6f1793255df1c1e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga89f556191ea0914c6f1793255df1c1e5">&#9670;&nbsp;</a></span>doca_dev_accelerate_resource_reclaim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_dev_accelerate_resource_reclaim </td>
          <td>(</td>
          <td class="paramtype">struct doca_dev *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accelerates the reclaim process for a local device instance. </p>
<p>This function optimizes the reclaim time by retaining critical resources in the cache upon closure, allowing them to be reused when restarting. It should be invoked before initiating device resource cleanup, including resources tied to the device, such as DOCA Flow switch ports and their associated components. For scenarios where a fast reclaim is needed, even in the event of a process crash, this function should be called periodically (e.g., once per second) to ensure readiness.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>Pointer to the local DOCA device instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>DOCA_SUCCESS on success.</li>
<li>Appropriate error code on failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - if the input is invalid.</li>
<li>DOCA_ERROR_DRIVER - if there is a driver-related error.</li>
<li>DOCA_ERROR_AGAIN - if the operation should be retried.</li>
<li>DOCA_ERROR_NOT_SUPPORTED - the accelerate resource reclaim capability is unsupported. </li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<a id="gabebb0f3457d76fda2b0c07e4a95a5109"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabebb0f3457d76fda2b0c07e4a95a5109">&#9670;&nbsp;</a></span>doca_dev_as_devinfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#gabf4c2072da5a4674395e37df60eb4b1c">DOCA_STABLE</a> struct doca_devinfo* doca_dev_as_devinfo </td>
          <td>(</td>
          <td class="paramtype">const struct doca_dev *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get local device info from device. This should be useful when wanting to query information about device after opening it, and destroying the devinfo list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>The doca device instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The matching doca_devinfo instance in case of success, NULL in case dev is invalid. </dd></dl>

</div>
</div>
<a id="gae0ed06d8099c38aea195a30e7fef06cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae0ed06d8099c38aea195a30e7fef06cc">&#9670;&nbsp;</a></span>doca_dev_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#gabf4c2072da5a4674395e37df60eb4b1c">DOCA_STABLE</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_dev_close </td>
          <td>(</td>
          <td class="paramtype">struct doca_dev *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy allocated local device instance. </p>
<p>Closes device or decrements its refcount by One. In case the same device was opened multiple times, then only the last call to close will attempt to destroy device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>The local doca device instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success.<ul>
<li>DOCA_ERROR_IN_USE - failed to deallocate device resources. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaab4c7fb74286dae59074406e6c8da202"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab4c7fb74286dae59074406e6c8da202">&#9670;&nbsp;</a></span>doca_dev_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#gabf4c2072da5a4674395e37df60eb4b1c">DOCA_STABLE</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_dev_open </td>
          <td>(</td>
          <td class="paramtype">struct doca_devinfo *&#160;</td>
          <td class="paramname"><em>devinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct doca_dev **&#160;</td>
          <td class="paramname"><em>dev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize local device for use. </p>
<p>Opens device or increments its refcount by One. The device can later be used by other libraries. For every call to <a class="el" href="group__DOCA__DEV.html#gaab4c7fb74286dae59074406e6c8da202" title="Initialize local device for use.">doca_dev_open()</a> there should be a call to <a class="el" href="group__DOCA__DEV.html#gae0ed06d8099c38aea195a30e7fef06cc" title="Destroy allocated local device instance.">doca_dev_close()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">devinfo</td><td>The devinfo structure of the requested device. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dev</td><td>Initialized local doca device instance on success. Valid on success only.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. Error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input.</li>
<li>DOCA_ERROR_NO_MEMORY - failed to allocate protection domain for device.</li>
<li>DOCA_ERROR_NOT_CONNECTED - failed to open device.</li>
<li>DOCA_ERROR_INITIALIZATION - maximum number of open devices was exceeded.</li>
<li>DOCA_ERROR_NOT_SUPPORTED - devinfo was created by <a class="el" href="group__DOCA__RDMA__BRIDGE.html#ga1783cf67614b6a4930ebec5bb1203e1c" title="Open a DOCA device using an ibv_pd.">doca_rdma_bridge_open_dev_from_pd()</a>. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gab4c47356fcaa1616b433dd0edc1ab6c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab4c47356fcaa1616b433dd0edc1ab6c3">&#9670;&nbsp;</a></span>doca_dev_rep_as_devinfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#gabf4c2072da5a4674395e37df60eb4b1c">DOCA_STABLE</a> struct doca_devinfo_rep* doca_dev_rep_as_devinfo </td>
          <td>(</td>
          <td class="paramtype">struct doca_dev_rep *&#160;</td>
          <td class="paramname"><em>dev_rep</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get representor device info from device. This should be useful when wanting to query information about device after opening it, and destroying the devinfo list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev_rep</td><td>The representor doca device instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The matching doca_devinfo_rep instance in case of success, NULL in case dev_rep is invalid. </dd></dl>

</div>
</div>
<a id="ga4b916bf433559e8694ff1659e3e57623"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b916bf433559e8694ff1659e3e57623">&#9670;&nbsp;</a></span>doca_dev_rep_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#gabf4c2072da5a4674395e37df60eb4b1c">DOCA_STABLE</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_dev_rep_close </td>
          <td>(</td>
          <td class="paramtype">struct doca_dev_rep *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy allocated representor device instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>The representor doca device instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. Error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input.</li>
<li>DOCA_ERROR_IN_USE - failed to deallocate device resources. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga1da87e3e6a965ca3ddd7fad6a6866f14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1da87e3e6a965ca3ddd7fad6a6866f14">&#9670;&nbsp;</a></span>doca_dev_rep_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#gabf4c2072da5a4674395e37df60eb4b1c">DOCA_STABLE</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_dev_rep_open </td>
          <td>(</td>
          <td class="paramtype">struct doca_devinfo_rep *&#160;</td>
          <td class="paramname"><em>devinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct doca_dev_rep **&#160;</td>
          <td class="paramname"><em>dev_rep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize representor device for use. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">devinfo</td><td>The devinfo structure of the requested device. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dev_rep</td><td>Initialized representor doca device instance on success. Valid on success only.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. Error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input.</li>
<li>DOCA_ERROR_NO_MEMORY - failed to allocate memory for device. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gac8dbae0ff94ceee32b67962521bf72b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac8dbae0ff94ceee32b67962521bf72b4">&#9670;&nbsp;</a></span>doca_devinfo_cap_is_accelerate_resource_reclaim_supported()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_devinfo_cap_is_accelerate_resource_reclaim_supported </td>
          <td>(</td>
          <td class="paramtype">const struct doca_devinfo *&#160;</td>
          <td class="paramname"><em>devinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>is_accelerate_resource_reclaim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the accelerate resource reclaim capability of a DOCA devinfo. </p>
<p>The accelerate resource reclaim property type: uint8_t*.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">devinfo</td><td>The device to query. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">is_accelerate_resource_reclaim</td><td>1 if the accelerate resource reclaim capability is supported, 0 otherwise.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. Error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input.</li>
<li>DOCA_ERROR_DRIVER - failed to query capability support. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga29baf8cd20004cae040df8ed14791fe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga29baf8cd20004cae040df8ed14791fe1">&#9670;&nbsp;</a></span>doca_devinfo_cap_is_hotplug_manager_supported()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#gabf4c2072da5a4674395e37df60eb4b1c">DOCA_STABLE</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_devinfo_cap_is_hotplug_manager_supported </td>
          <td>(</td>
          <td class="paramtype">const struct doca_devinfo *&#160;</td>
          <td class="paramname"><em>devinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>is_hotplug_manager</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the hotplug manager capability of a DOCA devinfo. </p>
<p>The hotplug manager property type: uint8_t*.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">devinfo</td><td>The device to query. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">is_hotplug_manager</td><td>1 if the hotplug manager capability is supported, 0 otherwise.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. Error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input.</li>
<li>DOCA_ERROR_DRIVER - failed to query capability support. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga031c01c2da5960f7d25be6b9fe2c7b52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga031c01c2da5960f7d25be6b9fe2c7b52">&#9670;&nbsp;</a></span>doca_devinfo_cap_is_notification_moderation_supported()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_devinfo_cap_is_notification_moderation_supported </td>
          <td>(</td>
          <td class="paramtype">const struct doca_devinfo *&#160;</td>
          <td class="paramname"><em>devinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>is_notification_moderation_supported</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if notification moderation is supported for a device. </p>
<p>The notification moderation supported type: uint8_t*.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">devinfo</td><td>The device to query. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">is_notification_moderation_supported</td><td>1 if the device supports notification moderation</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. Error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input.</li>
<li>DOCA_ERROR_DRIVER - failed to query capability support. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga393730414c11746f1bb3eb9333c37178"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga393730414c11746f1bb3eb9333c37178">&#9670;&nbsp;</a></span>doca_devinfo_create_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#gabf4c2072da5a4674395e37df60eb4b1c">DOCA_STABLE</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_devinfo_create_list </td>
          <td>(</td>
          <td class="paramtype">struct doca_devinfo ***&#160;</td>
          <td class="paramname"><em>dev_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>nb_devs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates list of all available local devices. </p>
<p>Lists information about available devices, to start using the device you first have to call <a class="el" href="group__DOCA__DEV.html#gaab4c7fb74286dae59074406e6c8da202" title="Initialize local device for use.">doca_dev_open()</a>, while passing an element of this list. List elements become invalid once it has been destroyed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dev_list</td><td>Pointer to array of pointers. Output can then be accessed as follows (*dev_list)[idx]. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">nb_devs</td><td>Number of available local devices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. Error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input.</li>
<li>DOCA_ERROR_NO_MEMORY - failed to allocate enough space.</li>
<li>DOCA_ERROR_NOT_FOUND - failed to get RDMA devices list </li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Returned list must be destroyed using <a class="el" href="group__DOCA__DEV.html#gaa1d83f59f8b119eab404b7f7aa70c8df" title="Destroy list of local device info structures.">doca_devinfo_destroy_list()</a> </dd></dl>

</div>
</div>
<a id="gaa1d83f59f8b119eab404b7f7aa70c8df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1d83f59f8b119eab404b7f7aa70c8df">&#9670;&nbsp;</a></span>doca_devinfo_destroy_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#gabf4c2072da5a4674395e37df60eb4b1c">DOCA_STABLE</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_devinfo_destroy_list </td>
          <td>(</td>
          <td class="paramtype">struct doca_devinfo **&#160;</td>
          <td class="paramname"><em>dev_list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy list of local device info structures. </p>
<p>Destroys the list of device information, once the list has been destroyed, all elements become invalid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev_list</td><td>List to be destroyed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. Error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input.</li>
<li>DOCA_ERROR_IN_USE - at least one device in the list is in a corrupted state. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gafd5c257a21d051d0b6a49a0adf4d0812"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd5c257a21d051d0b6a49a0adf4d0812">&#9670;&nbsp;</a></span>doca_devinfo_get_active_rate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_devinfo_get_active_rate </td>
          <td>(</td>
          <td class="paramtype">const struct doca_devinfo *&#160;</td>
          <td class="paramname"><em>devinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>active_rate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the active rate of a DOCA devinfo. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">devinfo</td><td>The device to query. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">active_rate</td><td>The active rate of the given port on the device. Given in units of bits/s.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. Error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input.</li>
<li>DOCA_ERROR_DRIVER - failed to query port rate. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga68fadeeaf5d187a069208eb6aeafea40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga68fadeeaf5d187a069208eb6aeafea40">&#9670;&nbsp;</a></span>doca_devinfo_get_ibdev_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#gabf4c2072da5a4674395e37df60eb4b1c">DOCA_STABLE</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_devinfo_get_ibdev_name </td>
          <td>(</td>
          <td class="paramtype">const struct doca_devinfo *&#160;</td>
          <td class="paramname"><em>devinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>ibdev_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the name of the IB device represented by a DOCA devinfo. </p>
<p>The name of the IB device type: char[DOCA_DEVINFO_IBDEV_NAME_SIZE].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">devinfo</td><td>The device to query. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ibdev_name</td><td>The name of the IB device represented by devinfo. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size of the input ibdev_name buffer, must be at least DOCA_DEVINFO_IBDEV_NAME_SIZE which includes the null terminating byte.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. Error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gadbb5a342d9269095c0a4690a0ff34702"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadbb5a342d9269095c0a4690a0ff34702">&#9670;&nbsp;</a></span>doca_devinfo_get_iface_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#gabf4c2072da5a4674395e37df60eb4b1c">DOCA_STABLE</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_devinfo_get_iface_name </td>
          <td>(</td>
          <td class="paramtype">const struct doca_devinfo *&#160;</td>
          <td class="paramname"><em>devinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>iface_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the name of the ethernet interface of a DOCA devinfo. </p>
<p>The name of the ethernet interface is the same as it's name in ifconfig. The name of the ethernet interface type: char[DOCA_DEVINFO_IFACE_NAME_SIZE].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">devinfo</td><td>The device to query. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">iface_name</td><td>The name of the ethernet interface of devinfo. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size of the input iface_name buffer, must be at least DOCA_DEVINFO_IFACE_NAME_SIZE which includes the null terminating byte.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. Error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input.</li>
<li>DOCA_ERROR_OPERATING_SYSTEM - failed to acquire the interface name from the OS </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gab3843c27432ddcd812c61c94e40fceed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3843c27432ddcd812c61c94e40fceed">&#9670;&nbsp;</a></span>doca_devinfo_get_ipv4_addr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#gabf4c2072da5a4674395e37df60eb4b1c">DOCA_STABLE</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_devinfo_get_ipv4_addr </td>
          <td>(</td>
          <td class="paramtype">const struct doca_devinfo *&#160;</td>
          <td class="paramname"><em>devinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>ipv4_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the IPv4 address of a DOCA devinfo. </p>
<p>The IPv4 address type: uint8_t[DOCA_DEVINFO_IPV4_ADDR_SIZE].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">devinfo</td><td>The device to query. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ipv4_addr</td><td>The IPv4 address of devinfo. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size of the input ipv4_addr buffer, must be at least DOCA_DEVINFO_IPV4_ADDR_SIZE</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. Error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input.</li>
<li>DOCA_ERROR_NOT_FOUND - no IPv4 address was assigned</li>
<li>DOCA_ERROR_OPERATING_SYSTEM - failed to acquire the IPv4 address from the OS </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga5c90d7311045baabd77beec18c1ad258"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c90d7311045baabd77beec18c1ad258">&#9670;&nbsp;</a></span>doca_devinfo_get_ipv6_addr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#gabf4c2072da5a4674395e37df60eb4b1c">DOCA_STABLE</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_devinfo_get_ipv6_addr </td>
          <td>(</td>
          <td class="paramtype">const struct doca_devinfo *&#160;</td>
          <td class="paramname"><em>devinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>ipv6_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the IPv6 address of a DOCA devinfo. </p>
<p>The IPv6 address type: uint8_t[DOCA_DEVINFO_IPV6_ADDR_SIZE].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">devinfo</td><td>The device to query. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ipv6_addr</td><td>The IPv6 address of devinfo. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size of the input ipv6_addr buffer, must be at least DOCA_DEVINFO_IPV6_ADDR_SIZE</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. Error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input.</li>
<li>DOCA_ERROR_OPERATING_SYSTEM - failed to acquire the IPv6 address from the OS </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gad12b1c8f272a58e3ef0542c2d2ddfcfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad12b1c8f272a58e3ef0542c2d2ddfcfe">&#9670;&nbsp;</a></span>doca_devinfo_get_lid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#gabf4c2072da5a4674395e37df60eb4b1c">DOCA_STABLE</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_devinfo_get_lid </td>
          <td>(</td>
          <td class="paramtype">const struct doca_devinfo *&#160;</td>
          <td class="paramname"><em>devinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>lid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the port LID of a DOCA devinfo. </p>
<p>The port LID type: uint16_t *.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">devinfo</td><td>The device to query. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">lid</td><td>The port LID of devinfo.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. Error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input.</li>
<li>DOCA_ERROR_DRIVER - failed to query port LID.</li>
<li>DOCA_ERROR_NOT_SUPPORTED - the device port's link layer is not IB. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gab0850dbe9ed78de7a39d765f49647eb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab0850dbe9ed78de7a39d765f49647eb4">&#9670;&nbsp;</a></span>doca_devinfo_get_mac_addr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#gabf4c2072da5a4674395e37df60eb4b1c">DOCA_STABLE</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_devinfo_get_mac_addr </td>
          <td>(</td>
          <td class="paramtype">const struct doca_devinfo *&#160;</td>
          <td class="paramname"><em>devinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>mac_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the MAC address of a DOCA devinfo. </p>
<p>The MAC address type: uint8_t[DOCA_DEVINFO_MAC_ADDR_SIZE].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">devinfo</td><td>The device to query. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mac_addr</td><td>The MAC address of devinfo. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size of the input mac_addr buffer, must be at least DOCA_DEVINFO_MAC_ADDR_SIZE</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. Error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input.</li>
<li>DOCA_ERROR_NOT_SUPPORTED - the device port's link layer is not RoCE. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gadeb317cf45b41f4102682a2fd8f50bfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadeb317cf45b41f4102682a2fd8f50bfe">&#9670;&nbsp;</a></span>doca_devinfo_get_pci_addr_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#gabf4c2072da5a4674395e37df60eb4b1c">DOCA_STABLE</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_devinfo_get_pci_addr_str </td>
          <td>(</td>
          <td class="paramtype">const struct doca_devinfo *&#160;</td>
          <td class="paramname"><em>devinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>pci_addr_str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the PCI address of a DOCA devinfo. </p>
<p>The PCI address string format is "Domain:Bus:Device.Function", such that each value is represented by HEX digits, e.g., "0000:3a:00.0"</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">devinfo</td><td>The device to query. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pci_addr_str</td><td>The PCI address of devinfo, should be of size DOCA_DEVINFO_PCI_ADDR_SIZE at least.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. Error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input.</li>
<li>DOCA_ERROR_OPERATING_SYSTEM - failed to acquire the PCI address from the OS </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga403e2fb617e852698ff209387d096f84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga403e2fb617e852698ff209387d096f84">&#9670;&nbsp;</a></span>doca_devinfo_get_vhca_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_devinfo_get_vhca_id </td>
          <td>(</td>
          <td class="paramtype">const struct doca_devinfo *&#160;</td>
          <td class="paramname"><em>devinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>vhca_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get vhca id of a device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">devinfo</td><td>The device to query. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vhca_id</td><td>Returned vhca id of the device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. Error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input.</li>
<li>DOCA_ERROR_DRIVER - failed to query capability support. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga14192ad7c7e57118c75930998270fde6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga14192ad7c7e57118c75930998270fde6">&#9670;&nbsp;</a></span>doca_devinfo_is_equal_pci_addr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#gabf4c2072da5a4674395e37df60eb4b1c">DOCA_STABLE</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_devinfo_is_equal_pci_addr </td>
          <td>(</td>
          <td class="paramtype">const struct doca_devinfo *&#160;</td>
          <td class="paramname"><em>devinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pci_addr_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>is_equal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a PCI address belongs to a DOCA devinfo. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">devinfo</td><td>The device to query. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pci_addr_str</td><td>The PCI address to check, should be as one of the following formats:<ul>
<li>"Domain:Bus:Device.Function", e.g., "0000:3a:00.0" (size DOCA_DEVINFO_PCI_ADDR_SIZE including a null terminator).</li>
<li>"Bus:Device.Function", e.g., "3a:00.0" (size DOCA_DEVINFO_PCI_BDF_SIZE including a null terminator), Domain is assumed to be "0000" (i.e. "0000:&lt;pci_addr_str&gt;"). </li>
</ul>
</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">is_equal</td><td>1 if pci_addr_str belongs to devinfo, 0 otherwise. In case of an error, no certain value is guaranteed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. Error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input.</li>
<li>DOCA_ERROR_OPERATING_SYSTEM - failed to acquire the actual PCI address from the OS for comparison. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga44ee77c2040ca90e04d87ed3d56dd0ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga44ee77c2040ca90e04d87ed3d56dd0ae">&#9670;&nbsp;</a></span>doca_devinfo_rep_cap_is_filter_all_supported()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#gabf4c2072da5a4674395e37df60eb4b1c">DOCA_STABLE</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_devinfo_rep_cap_is_filter_all_supported </td>
          <td>(</td>
          <td class="paramtype">const struct doca_devinfo *&#160;</td>
          <td class="paramname"><em>devinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>filter_all_supported</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the representor devices discovery capability of the device. </p>
<p>Get uint8_t value defining if the device can be used to create list of representor devices. In case true is returned, then this device supports at least one representor type. See <a class="el" href="group__DOCA__DEV.html#ga2fa28108fd69670b43a0d41e1b7c29e2" title="Create list of available representor devices accessible by dev.">doca_devinfo_rep_create_list()</a>. true - device can be used with the remote list create API with filter DOCA_DEVINFO_REP_FILTER_ALL. false - providing DOCA_DEVINFO_REP_FILTER_ALL is guaranteed to fail with DOCA_ERROR_NOT_SUPPORTED.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">devinfo</td><td>The device to query. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">filter_all_supported</td><td>1 if the rep list all capability is supported, 0 otherwise.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. Error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input.</li>
<li>DOCA_ERROR_DRIVER - failed to query capability support.</li>
<li>DOCA_ERROR_NOT_SUPPORTED - local device does not expose representor devices. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga6d9726b1c7fbf5077f5308b956907266"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6d9726b1c7fbf5077f5308b956907266">&#9670;&nbsp;</a></span>doca_devinfo_rep_cap_is_filter_emulated_supported()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#gabf4c2072da5a4674395e37df60eb4b1c">DOCA_STABLE</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_devinfo_rep_cap_is_filter_emulated_supported </td>
          <td>(</td>
          <td class="paramtype">const struct doca_devinfo *&#160;</td>
          <td class="paramname"><em>devinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>filter_emulated_supported</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the remote emulated device discovery capability of the device. </p>
<p>Get uint8_t value defining if the device can be used to create list of emulated representor devices. See <a class="el" href="group__DOCA__DEV.html#ga2fa28108fd69670b43a0d41e1b7c29e2" title="Create list of available representor devices accessible by dev.">doca_devinfo_rep_create_list()</a>. true - device can be used with the remote list create API with filter DOCA_DEVINFO_REP_FILTER_EMULATED. false - providing DOCA_DEVINFO_REP_FILTER_EMULATED is guaranteed to fail with DOCA_ERROR_NOT_SUPPORTED.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">devinfo</td><td>The device to query. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">filter_emulated_supported</td><td>1 if the list emulated capability is supported, 0 otherwise.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. Error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input.</li>
<li>DOCA_ERROR_DRIVER - failed to query capability support.</li>
<li>DOCA_ERROR_NOT_SUPPORTED - local device does not expose representor devices. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gac6d1976e9ca8c2f68a9f3cd42ffc97b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6d1976e9ca8c2f68a9f3cd42ffc97b9">&#9670;&nbsp;</a></span>doca_devinfo_rep_cap_is_filter_net_supported()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#gabf4c2072da5a4674395e37df60eb4b1c">DOCA_STABLE</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_devinfo_rep_cap_is_filter_net_supported </td>
          <td>(</td>
          <td class="paramtype">const struct doca_devinfo *&#160;</td>
          <td class="paramname"><em>devinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>filter_net_supported</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the remote net discovery capability of the device. </p>
<p>Get uint8_t value defining if the device can be used to create list of net remote devices. See doca_devinfo_remote_list_create(). true - device can be used with the remote list create API with filter DOCA_DEV_REMOTE_FILTER_NET. false - providing DOCA_DEV_REMOTE_FILTER_NET is guaranteed to fail with DOCA_ERROR_NOT_SUPPORTED.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">devinfo</td><td>The device to query. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">filter_net_supported</td><td>1 if the rep list net capability is supported, 0 otherwise.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. Error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input.</li>
<li>DOCA_ERROR_DRIVER - failed to query capability support.</li>
<li>DOCA_ERROR_NOT_SUPPORTED - local device does not expose representor devices. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga2fa28108fd69670b43a0d41e1b7c29e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2fa28108fd69670b43a0d41e1b7c29e2">&#9670;&nbsp;</a></span>doca_devinfo_rep_create_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#gabf4c2072da5a4674395e37df60eb4b1c">DOCA_STABLE</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_devinfo_rep_create_list </td>
          <td>(</td>
          <td class="paramtype">struct doca_dev *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct doca_devinfo_rep ***&#160;</td>
          <td class="paramname"><em>dev_list_rep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>nb_devs_rep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create list of available representor devices accessible by dev. </p>
<p>Returns all representors managed by the provided device. The provided device must be a local device. The representor may represent a network function attached to the host, or it can represent an emulated function attached to the host.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>Local device with access to representors. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>Bitmap filter of representor types. See enum doca_devinfo_rep_filter for more details. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dev_list_rep</td><td>Pointer to array of pointers. Output can then be accessed as follows (*dev_list_rep)[idx]. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">nb_devs_rep</td><td>Number of available representor devices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. Error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input.</li>
<li>DOCA_ERROR_NO_MEMORY - failed to allocate memory for list.</li>
<li>DOCA_ERROR_DRIVER - Failed to query driver.</li>
<li>DOCA_ERROR_NOT_SUPPORTED - local device does not expose representor devices </li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Returned list must be destroyed using <a class="el" href="group__DOCA__DEV.html#ga2e23e07b6aedc9d3eb7823469d5cc180" title="Destroy list of representor device info structures.">doca_devinfo_rep_destroy_list()</a> </dd></dl>

</div>
</div>
<a id="ga2e23e07b6aedc9d3eb7823469d5cc180"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2e23e07b6aedc9d3eb7823469d5cc180">&#9670;&nbsp;</a></span>doca_devinfo_rep_destroy_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#gabf4c2072da5a4674395e37df60eb4b1c">DOCA_STABLE</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_devinfo_rep_destroy_list </td>
          <td>(</td>
          <td class="paramtype">struct doca_devinfo_rep **&#160;</td>
          <td class="paramname"><em>dev_list_rep</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy list of representor device info structures. </p>
<p>Destroy list of representor device information, once the list has been destroyed, all elements of the list are considered invalid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev_list_rep</td><td>List to be destroyed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. Error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input.</li>
<li>DOCA_ERROR_IN_USE - the doca_dev that created the list is in a corrupted state. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaaf502c2d65e15fdeb0cd326e0e4b0ecd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf502c2d65e15fdeb0cd326e0e4b0ecd">&#9670;&nbsp;</a></span>doca_devinfo_rep_get_iface_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_devinfo_rep_get_iface_name </td>
          <td>(</td>
          <td class="paramtype">const struct doca_devinfo_rep *&#160;</td>
          <td class="paramname"><em>devinfo_rep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>iface_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the name of the ethernet interface of a DOCA devinfo_rep. </p>
<p>The name of the ethernet interface is the same as it's name in ifconfig. The name of the ethernet interface type: char[DOCA_DEVINFO_IFACE_NAME_SIZE].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">devinfo_rep</td><td>Representor device info </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">iface_name</td><td>The name of the ethernet interface of devinfo_rep. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size of the input iface_name buffer, must be at least DOCA_DEVINFO_IFACE_NAME_SIZE which includes the null terminating byte.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. Error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input.</li>
<li>DOCA_ERROR_OPERATING_SYSTEM - failed to acquire the interface name from the OS </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga53aefa72907daf82621d9e855220bdd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga53aefa72907daf82621d9e855220bdd5">&#9670;&nbsp;</a></span>doca_devinfo_rep_get_is_hotplug()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#gabf4c2072da5a4674395e37df60eb4b1c">DOCA_STABLE</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_devinfo_rep_get_is_hotplug </td>
          <td>(</td>
          <td class="paramtype">const struct doca_devinfo_rep *&#160;</td>
          <td class="paramname"><em>devinfo_rep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>is_hotplug</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query whether the representor device is a hotplugged device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">devinfo_rep</td><td>representor device info </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">is_hotplug</td><td>1 if the representor device is a hotplugged device. 0 if representor device is statically plugged. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. Error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga6322d1fd2af2cd1277a43bbd71e2b79c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6322d1fd2af2cd1277a43bbd71e2b79c">&#9670;&nbsp;</a></span>doca_devinfo_rep_get_pci_addr_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#gabf4c2072da5a4674395e37df60eb4b1c">DOCA_STABLE</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_devinfo_rep_get_pci_addr_str </td>
          <td>(</td>
          <td class="paramtype">const struct doca_devinfo_rep *&#160;</td>
          <td class="paramname"><em>devinfo_rep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>pci_addr_str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the PCI address of a DOCA devinfo_rep. </p>
<p>The PCI address string format is "Domain:Bus:Device.Function", such that each value is represented by HEX digits, e.g., "0000:3a:00.0".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">devinfo_rep</td><td>The device to query. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pci_addr_str</td><td>The PCI address of devinfo_rep, should be of size DOCA_DEVINFO_REP_PCI_ADDR_SIZE at least.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. Error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input.</li>
<li>DOCA_ERROR_NO_MEMORY - not enough memory to generate the stringed PCI address.</li>
<li>DOCA_ERROR_UNEXPECTED - an unexpected error occurred. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga822a2996cffa2eb8476dac662d40ae5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga822a2996cffa2eb8476dac662d40ae5a">&#9670;&nbsp;</a></span>doca_devinfo_rep_get_pci_func_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#gabf4c2072da5a4674395e37df60eb4b1c">DOCA_STABLE</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_devinfo_rep_get_pci_func_type </td>
          <td>(</td>
          <td class="paramtype">const struct doca_devinfo_rep *&#160;</td>
          <td class="paramname"><em>devinfo_rep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__DOCA__TYPES.html#gaed11d328cbae30cecb1e7c507e05d5f8">doca_pci_func_type</a> *&#160;</td>
          <td class="paramname"><em>pci_func_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the PCI function type of a DOCA devinfo_rep. </p>
<p>The pci function type: enum doca_pci_func_type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">devinfo_rep</td><td>The representor of device to query. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pci_func_type</td><td>The PCI function type of the devinfo_rep.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. Error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gae8596784463ca5af842f6f2eb217e515"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae8596784463ca5af842f6f2eb217e515">&#9670;&nbsp;</a></span>doca_devinfo_rep_get_vhca_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_devinfo_rep_get_vhca_id </td>
          <td>(</td>
          <td class="paramtype">const struct doca_devinfo_rep *&#160;</td>
          <td class="paramname"><em>devinfo_rep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>vhca_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get vhca id of a DOCA devinfo_rep. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">devinfo_rep</td><td>Representor device info. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vhca_id</td><td>Returned vhca id of the devinfo_rep. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. Error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga50190abaab56874f7999a3aa87d749ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga50190abaab56874f7999a3aa87d749ed">&#9670;&nbsp;</a></span>doca_devinfo_rep_get_vuid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#gabf4c2072da5a4674395e37df60eb4b1c">DOCA_STABLE</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_devinfo_rep_get_vuid </td>
          <td>(</td>
          <td class="paramtype">const struct doca_devinfo_rep *&#160;</td>
          <td class="paramname"><em>devinfo_rep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>rep_vuid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the Vendor Unique ID of a representor DOCA devinfo. </p>
<p>The Vendor Unique ID is used as stable ID of a VF/PF. The Vendor Unique ID type: char[DOCA_DEVINFO_VUID_SIZE].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">devinfo_rep</td><td>The representor device to query. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rep_vuid</td><td>The Vendor Unique ID of devinfo_rep. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size of the vuid buffer, including the terminating null byte ('\0').</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. Error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gab5657dca1c2835646a52925665954a39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5657dca1c2835646a52925665954a39">&#9670;&nbsp;</a></span>doca_devinfo_rep_is_equal_pci_addr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#gabf4c2072da5a4674395e37df60eb4b1c">DOCA_STABLE</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_devinfo_rep_is_equal_pci_addr </td>
          <td>(</td>
          <td class="paramtype">const struct doca_devinfo_rep *&#160;</td>
          <td class="paramname"><em>devinfo_rep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pci_addr_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>is_equal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a PCI address belongs to a DOCA devinfo_rep. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">devinfo_rep</td><td>The representor of device to query. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pci_addr_str</td><td>The PCI address to check, should be as one of the following formats:<ul>
<li>"Domain:Bus:Device.Function", e.g., "0000:3a:00.0" (size DOCA_DEVINFO_PCI_ADDR_SIZE including a null terminator).</li>
<li>"Bus:Device.Function", e.g., "3a:00.0" (size DOCA_DEVINFO_PCI_BDF_SIZE including a null terminator). Domain is assumed to be "0000" (i.e. "0000:&lt;pci_addr_str&gt;"). </li>
</ul>
</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">is_equal</td><td>1 if pci_addr_str belongs to devinfo_rep, 0 otherwise.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. Error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input.</li>
<li>DOCA_ERROR_NO_MEMORY - not enough memory to generate devinfo_rep PCI address for comparison.</li>
<li>DOCA_ERROR_UNEXPECTED - an unexpected error occurred. </li>
</ul>
</dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Wed Aug 13 2025 08:00:17 for NVIDIA DOCA SDK by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
