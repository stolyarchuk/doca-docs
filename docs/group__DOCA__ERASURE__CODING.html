<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NVIDIA DOCA SDK: DOCA Erasure Coding Engine</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<!-- Doxygen Awesome CSS -->
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript">
DoxygenAwesomeDarkModeToggle.init()
DoxygenAwesomeFragmentCopyButton.init()
DoxygenAwesomeParagraphLink.init()
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectname">NVIDIA DOCA SDK
  </td>
  <td id="projectbrief">Data Center on a Chip Framework Documentation</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__DOCA__ERASURE__CODING.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">DOCA Erasure Coding Engine</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaaf8c38dcf6373d1ad0a90b18a9ad566d"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ERASURE__CODING.html#gaaf8c38dcf6373d1ad0a90b18a9ad566d">doca_ec_task_galois_mul_completion_cb_t</a>) (struct doca_ec_task_galois_mul *task, union <a class="el" href="uniondoca__data.html">doca_data</a> task_user_data, union <a class="el" href="uniondoca__data.html">doca_data</a> ctx_user_data)</td></tr>
<tr class="memdesc:gaaf8c38dcf6373d1ad0a90b18a9ad566d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to execute on completion of a Galois multiplication task.  <a href="group__DOCA__ERASURE__CODING.html#gaaf8c38dcf6373d1ad0a90b18a9ad566d">More...</a><br /></td></tr>
<tr class="separator:gaaf8c38dcf6373d1ad0a90b18a9ad566d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42860387eeebc0d91078fa2f0339bb86"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ERASURE__CODING.html#ga42860387eeebc0d91078fa2f0339bb86">doca_ec_task_create_completion_cb_t</a>) (struct doca_ec_task_create *task, union <a class="el" href="uniondoca__data.html">doca_data</a> task_user_data, union <a class="el" href="uniondoca__data.html">doca_data</a> ctx_user_data)</td></tr>
<tr class="memdesc:ga42860387eeebc0d91078fa2f0339bb86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to execute on completion of a create task.  <a href="group__DOCA__ERASURE__CODING.html#ga42860387eeebc0d91078fa2f0339bb86">More...</a><br /></td></tr>
<tr class="separator:ga42860387eeebc0d91078fa2f0339bb86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaabc6520e67af390486ee5709eb26bf06"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ERASURE__CODING.html#gaabc6520e67af390486ee5709eb26bf06">doca_ec_task_update_completion_cb_t</a>) (struct doca_ec_task_update *task, union <a class="el" href="uniondoca__data.html">doca_data</a> task_user_data, union <a class="el" href="uniondoca__data.html">doca_data</a> ctx_user_data)</td></tr>
<tr class="memdesc:gaabc6520e67af390486ee5709eb26bf06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to execute on completion of an update task.  <a href="group__DOCA__ERASURE__CODING.html#gaabc6520e67af390486ee5709eb26bf06">More...</a><br /></td></tr>
<tr class="separator:gaabc6520e67af390486ee5709eb26bf06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2563dc71fb7e17bf9071166f552fe6d3"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ERASURE__CODING.html#ga2563dc71fb7e17bf9071166f552fe6d3">doca_ec_task_recover_completion_cb_t</a>) (struct doca_ec_task_recover *task, union <a class="el" href="uniondoca__data.html">doca_data</a> task_user_data, union <a class="el" href="uniondoca__data.html">doca_data</a> ctx_user_data)</td></tr>
<tr class="memdesc:ga2563dc71fb7e17bf9071166f552fe6d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to execute on completion of a recover task.  <a href="group__DOCA__ERASURE__CODING.html#ga2563dc71fb7e17bf9071166f552fe6d3">More...</a><br /></td></tr>
<tr class="separator:ga2563dc71fb7e17bf9071166f552fe6d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga4fb15cedefb4dc30e3a79a8fd1e795b6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ERASURE__CODING.html#ga4fb15cedefb4dc30e3a79a8fd1e795b6">doca_ec_matrix_type</a> { <a class="el" href="group__DOCA__ERASURE__CODING.html#gga4fb15cedefb4dc30e3a79a8fd1e795b6a69e444bb75f3afe6ce1e068b1151118d">DOCA_EC_MATRIX_TYPE_CAUCHY</a> = 1
, <a class="el" href="group__DOCA__ERASURE__CODING.html#gga4fb15cedefb4dc30e3a79a8fd1e795b6a422bd96be7877d992355c26d3cd02382">DOCA_EC_MATRIX_TYPE_VANDERMONDE</a> = 2
 }</td></tr>
<tr class="memdesc:ga4fb15cedefb4dc30e3a79a8fd1e795b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Types of coding matrix used for erasure codes.  <a href="group__DOCA__ERASURE__CODING.html#ga4fb15cedefb4dc30e3a79a8fd1e795b6">More...</a><br /></td></tr>
<tr class="separator:ga4fb15cedefb4dc30e3a79a8fd1e795b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gae1d6a1066a26a215694d18f5bcd85bb7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ERASURE__CODING.html#gae1d6a1066a26a215694d18f5bcd85bb7">doca_ec_cap_task_galois_mul_is_supported</a> (const struct doca_devinfo *devinfo)</td></tr>
<tr class="separator:gae1d6a1066a26a215694d18f5bcd85bb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55b05932c26c554ad94a8d1ab5ac9b29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ERASURE__CODING.html#ga55b05932c26c554ad94a8d1ab5ac9b29">doca_ec_task_galois_mul_set_conf</a> (struct doca_ec *ec, <a class="el" href="group__DOCA__ERASURE__CODING.html#gaaf8c38dcf6373d1ad0a90b18a9ad566d">doca_ec_task_galois_mul_completion_cb_t</a> successful_task_completion_cb, <a class="el" href="group__DOCA__ERASURE__CODING.html#gaaf8c38dcf6373d1ad0a90b18a9ad566d">doca_ec_task_galois_mul_completion_cb_t</a> error_task_completion_cb, uint32_t num_tasks)</td></tr>
<tr class="memdesc:ga55b05932c26c554ad94a8d1ab5ac9b29"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method sets the Galois multiplication tasks configuration.  <a href="group__DOCA__ERASURE__CODING.html#ga55b05932c26c554ad94a8d1ab5ac9b29">More...</a><br /></td></tr>
<tr class="separator:ga55b05932c26c554ad94a8d1ab5ac9b29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81c41a295c06f30e56ea7e258e70e5d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ERASURE__CODING.html#ga81c41a295c06f30e56ea7e258e70e5d0">doca_ec_task_galois_mul_allocate_init</a> (struct doca_ec *ec, const struct doca_ec_matrix *coding_matrix, const struct doca_buf *src_buf, struct doca_buf *dst_buf, union <a class="el" href="uniondoca__data.html">doca_data</a> user_data, struct doca_ec_task_galois_mul **task)</td></tr>
<tr class="memdesc:ga81c41a295c06f30e56ea7e258e70e5d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method allocates and initializes a Galois multiplication task.  <a href="group__DOCA__ERASURE__CODING.html#ga81c41a295c06f30e56ea7e258e70e5d0">More...</a><br /></td></tr>
<tr class="separator:ga81c41a295c06f30e56ea7e258e70e5d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8edb3516cbce5d7c6661d12075ede59"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> struct doca_task *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ERASURE__CODING.html#gaa8edb3516cbce5d7c6661d12075ede59">doca_ec_task_galois_mul_as_task</a> (struct doca_ec_task_galois_mul *task)</td></tr>
<tr class="memdesc:gaa8edb3516cbce5d7c6661d12075ede59"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method converts an EC Galois multiplication task to a doca_task.  <a href="group__DOCA__ERASURE__CODING.html#gaa8edb3516cbce5d7c6661d12075ede59">More...</a><br /></td></tr>
<tr class="separator:gaa8edb3516cbce5d7c6661d12075ede59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48ded46b752119ec12c9db6abc47aca5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ERASURE__CODING.html#ga48ded46b752119ec12c9db6abc47aca5">doca_ec_task_galois_mul_set_coding_matrix</a> (struct doca_ec_task_galois_mul *task, const struct doca_ec_matrix *coding_matrix)</td></tr>
<tr class="memdesc:ga48ded46b752119ec12c9db6abc47aca5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method sets the coding_matrix of a Galois multiplication task.  <a href="group__DOCA__ERASURE__CODING.html#ga48ded46b752119ec12c9db6abc47aca5">More...</a><br /></td></tr>
<tr class="separator:ga48ded46b752119ec12c9db6abc47aca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafddf5be14c735d14d582843d6a5d4f3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> const struct doca_ec_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ERASURE__CODING.html#gafddf5be14c735d14d582843d6a5d4f3d">doca_ec_task_galois_mul_get_coding_matrix</a> (const struct doca_ec_task_galois_mul *task)</td></tr>
<tr class="memdesc:gafddf5be14c735d14d582843d6a5d4f3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method gets the coding matrix of a Galois multiplication task.  <a href="group__DOCA__ERASURE__CODING.html#gafddf5be14c735d14d582843d6a5d4f3d">More...</a><br /></td></tr>
<tr class="separator:gafddf5be14c735d14d582843d6a5d4f3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4207bf1c97acc95cb5defed43b4f6bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ERASURE__CODING.html#gaa4207bf1c97acc95cb5defed43b4f6bb">doca_ec_task_galois_mul_set_src_buf</a> (struct doca_ec_task_galois_mul *task, const struct doca_buf *src_buf)</td></tr>
<tr class="memdesc:gaa4207bf1c97acc95cb5defed43b4f6bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method sets the source buffer of a Galois multiplication task.  <a href="group__DOCA__ERASURE__CODING.html#gaa4207bf1c97acc95cb5defed43b4f6bb">More...</a><br /></td></tr>
<tr class="separator:gaa4207bf1c97acc95cb5defed43b4f6bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4cb758f4818eb7d4b289cc45db81b11"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> const struct doca_buf *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ERASURE__CODING.html#gaf4cb758f4818eb7d4b289cc45db81b11">doca_ec_task_galois_mul_get_src_buf</a> (const struct doca_ec_task_galois_mul *task)</td></tr>
<tr class="memdesc:gaf4cb758f4818eb7d4b289cc45db81b11"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method gets the source buffer of a Galois multiplication task.  <a href="group__DOCA__ERASURE__CODING.html#gaf4cb758f4818eb7d4b289cc45db81b11">More...</a><br /></td></tr>
<tr class="separator:gaf4cb758f4818eb7d4b289cc45db81b11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14574698479b829b244cfb979c4ee286"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ERASURE__CODING.html#ga14574698479b829b244cfb979c4ee286">doca_ec_task_galois_mul_set_dst_buf</a> (struct doca_ec_task_galois_mul *task, struct doca_buf *dst_buf)</td></tr>
<tr class="memdesc:ga14574698479b829b244cfb979c4ee286"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method sets the destination buffer of a Galois multiplication task.  <a href="group__DOCA__ERASURE__CODING.html#ga14574698479b829b244cfb979c4ee286">More...</a><br /></td></tr>
<tr class="separator:ga14574698479b829b244cfb979c4ee286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47a2340f9d7e06304ceb162d7725474d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> struct doca_buf *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ERASURE__CODING.html#ga47a2340f9d7e06304ceb162d7725474d">doca_ec_task_galois_mul_get_dst_buf</a> (const struct doca_ec_task_galois_mul *task)</td></tr>
<tr class="memdesc:ga47a2340f9d7e06304ceb162d7725474d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method gets the destination buffer of a Galois multiplication task.  <a href="group__DOCA__ERASURE__CODING.html#ga47a2340f9d7e06304ceb162d7725474d">More...</a><br /></td></tr>
<tr class="separator:ga47a2340f9d7e06304ceb162d7725474d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0302911e18b0cba98b54867986786b09"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ERASURE__CODING.html#ga0302911e18b0cba98b54867986786b09">doca_ec_cap_task_create_is_supported</a> (const struct doca_devinfo *devinfo)</td></tr>
<tr class="separator:ga0302911e18b0cba98b54867986786b09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a0dbff2ab3528ae54a60f4565e6f256"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ERASURE__CODING.html#ga2a0dbff2ab3528ae54a60f4565e6f256">doca_ec_task_create_set_conf</a> (struct doca_ec *ec, <a class="el" href="group__DOCA__ERASURE__CODING.html#ga42860387eeebc0d91078fa2f0339bb86">doca_ec_task_create_completion_cb_t</a> successful_task_completion_cb, <a class="el" href="group__DOCA__ERASURE__CODING.html#ga42860387eeebc0d91078fa2f0339bb86">doca_ec_task_create_completion_cb_t</a> error_task_completion_cb, uint32_t num_tasks)</td></tr>
<tr class="memdesc:ga2a0dbff2ab3528ae54a60f4565e6f256"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method sets the create tasks configuration.  <a href="group__DOCA__ERASURE__CODING.html#ga2a0dbff2ab3528ae54a60f4565e6f256">More...</a><br /></td></tr>
<tr class="separator:ga2a0dbff2ab3528ae54a60f4565e6f256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga523e6cb9b75baab43444db3135ed3e3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ERASURE__CODING.html#ga523e6cb9b75baab43444db3135ed3e3a">doca_ec_task_create_allocate_init</a> (struct doca_ec *ec, const struct doca_ec_matrix *coding_matrix, const struct doca_buf *original_data_blocks, struct doca_buf *rdnc_blocks, union <a class="el" href="uniondoca__data.html">doca_data</a> user_data, struct doca_ec_task_create **task)</td></tr>
<tr class="memdesc:ga523e6cb9b75baab43444db3135ed3e3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method allocates and initializes a create task.  <a href="group__DOCA__ERASURE__CODING.html#ga523e6cb9b75baab43444db3135ed3e3a">More...</a><br /></td></tr>
<tr class="separator:ga523e6cb9b75baab43444db3135ed3e3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2f079344bcfb5cbe2c3b329bca82e26"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> struct doca_task *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ERASURE__CODING.html#gad2f079344bcfb5cbe2c3b329bca82e26">doca_ec_task_create_as_task</a> (struct doca_ec_task_create *task)</td></tr>
<tr class="memdesc:gad2f079344bcfb5cbe2c3b329bca82e26"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method converts an EC create task to a doca_task.  <a href="group__DOCA__ERASURE__CODING.html#gad2f079344bcfb5cbe2c3b329bca82e26">More...</a><br /></td></tr>
<tr class="separator:gad2f079344bcfb5cbe2c3b329bca82e26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66f94e0dc5f9288bd82cad2fcf15356b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ERASURE__CODING.html#ga66f94e0dc5f9288bd82cad2fcf15356b">doca_ec_task_create_set_coding_matrix</a> (struct doca_ec_task_create *task, const struct doca_ec_matrix *coding_matrix)</td></tr>
<tr class="memdesc:ga66f94e0dc5f9288bd82cad2fcf15356b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method sets the coding_matrix of a create task.  <a href="group__DOCA__ERASURE__CODING.html#ga66f94e0dc5f9288bd82cad2fcf15356b">More...</a><br /></td></tr>
<tr class="separator:ga66f94e0dc5f9288bd82cad2fcf15356b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98b9a5385109bf28d8dcee523613e3c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> const struct doca_ec_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ERASURE__CODING.html#ga98b9a5385109bf28d8dcee523613e3c7">doca_ec_task_create_get_coding_matrix</a> (const struct doca_ec_task_create *task)</td></tr>
<tr class="memdesc:ga98b9a5385109bf28d8dcee523613e3c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method gets the coding matrix of a create task.  <a href="group__DOCA__ERASURE__CODING.html#ga98b9a5385109bf28d8dcee523613e3c7">More...</a><br /></td></tr>
<tr class="separator:ga98b9a5385109bf28d8dcee523613e3c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8da7d4fe0ee585f00fd7238021844040"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ERASURE__CODING.html#ga8da7d4fe0ee585f00fd7238021844040">doca_ec_task_create_set_original_data_blocks</a> (struct doca_ec_task_create *task, const struct doca_buf *original_data_blocks)</td></tr>
<tr class="memdesc:ga8da7d4fe0ee585f00fd7238021844040"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method sets the original_data_blocks buffer of a create task.  <a href="group__DOCA__ERASURE__CODING.html#ga8da7d4fe0ee585f00fd7238021844040">More...</a><br /></td></tr>
<tr class="separator:ga8da7d4fe0ee585f00fd7238021844040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga851da283b8f930e552fb4342d7fd671f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> const struct doca_buf *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ERASURE__CODING.html#ga851da283b8f930e552fb4342d7fd671f">doca_ec_task_create_get_original_data_blocks</a> (const struct doca_ec_task_create *task)</td></tr>
<tr class="memdesc:ga851da283b8f930e552fb4342d7fd671f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method gets the original_data_blocks buffer of a create task. The original_data_blocks buffer is a source buffer with data - A sequence containing all original data blocks - block_1, block_2 ,...  <a href="group__DOCA__ERASURE__CODING.html#ga851da283b8f930e552fb4342d7fd671f">More...</a><br /></td></tr>
<tr class="separator:ga851da283b8f930e552fb4342d7fd671f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b9157e2cb3bc9de36ce24689417419d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ERASURE__CODING.html#ga7b9157e2cb3bc9de36ce24689417419d">doca_ec_task_create_set_rdnc_blocks</a> (struct doca_ec_task_create *task, struct doca_buf *rdnc_blocks)</td></tr>
<tr class="memdesc:ga7b9157e2cb3bc9de36ce24689417419d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method sets the rdnc_blocks buffer of a create task.  <a href="group__DOCA__ERASURE__CODING.html#ga7b9157e2cb3bc9de36ce24689417419d">More...</a><br /></td></tr>
<tr class="separator:ga7b9157e2cb3bc9de36ce24689417419d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad04bd441d062f06810187de6c80cc883"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> struct doca_buf *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ERASURE__CODING.html#gad04bd441d062f06810187de6c80cc883">doca_ec_task_create_get_rdnc_blocks</a> (const struct doca_ec_task_create *task)</td></tr>
<tr class="memdesc:gad04bd441d062f06810187de6c80cc883"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method gets the rdnc_blocks buffer of a create task. The rdnc_blocks buffer is a destination buffer for the redundancy blocks. On successful completion of this task, will hold a sequence containing all redundancy blocks - rdnc_block_1, rdnc_block_2 ,...  <a href="group__DOCA__ERASURE__CODING.html#gad04bd441d062f06810187de6c80cc883">More...</a><br /></td></tr>
<tr class="separator:gad04bd441d062f06810187de6c80cc883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21518715a70bca719cb42ac33ec8845a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ERASURE__CODING.html#ga21518715a70bca719cb42ac33ec8845a">doca_ec_cap_task_update_is_supported</a> (const struct doca_devinfo *devinfo)</td></tr>
<tr class="separator:ga21518715a70bca719cb42ac33ec8845a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86aab51db72ad8c3ad1023acfa06a354"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ERASURE__CODING.html#ga86aab51db72ad8c3ad1023acfa06a354">doca_ec_task_update_set_conf</a> (struct doca_ec *ec, <a class="el" href="group__DOCA__ERASURE__CODING.html#gaabc6520e67af390486ee5709eb26bf06">doca_ec_task_update_completion_cb_t</a> successful_task_completion_cb, <a class="el" href="group__DOCA__ERASURE__CODING.html#gaabc6520e67af390486ee5709eb26bf06">doca_ec_task_update_completion_cb_t</a> error_task_completion_cb, uint32_t num_tasks)</td></tr>
<tr class="memdesc:ga86aab51db72ad8c3ad1023acfa06a354"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method sets the update tasks configuration.  <a href="group__DOCA__ERASURE__CODING.html#ga86aab51db72ad8c3ad1023acfa06a354">More...</a><br /></td></tr>
<tr class="separator:ga86aab51db72ad8c3ad1023acfa06a354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a0a2f0dae8ae31d86d6fbd89be89827"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ERASURE__CODING.html#ga0a0a2f0dae8ae31d86d6fbd89be89827">doca_ec_task_update_allocate_init</a> (struct doca_ec *ec, const struct doca_ec_matrix *update_matrix, const struct doca_buf *original_updated_and_rdnc_blocks, struct doca_buf *updated_rdnc_blocks, union <a class="el" href="uniondoca__data.html">doca_data</a> user_data, struct doca_ec_task_update **task)</td></tr>
<tr class="memdesc:ga0a0a2f0dae8ae31d86d6fbd89be89827"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method allocates and initializes an update task.  <a href="group__DOCA__ERASURE__CODING.html#ga0a0a2f0dae8ae31d86d6fbd89be89827">More...</a><br /></td></tr>
<tr class="separator:ga0a0a2f0dae8ae31d86d6fbd89be89827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfa941153da0cba1b978055c08e5e168"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> struct doca_task *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ERASURE__CODING.html#gacfa941153da0cba1b978055c08e5e168">doca_ec_task_update_as_task</a> (struct doca_ec_task_update *task)</td></tr>
<tr class="memdesc:gacfa941153da0cba1b978055c08e5e168"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method converts an EC update task to a doca_task.  <a href="group__DOCA__ERASURE__CODING.html#gacfa941153da0cba1b978055c08e5e168">More...</a><br /></td></tr>
<tr class="separator:gacfa941153da0cba1b978055c08e5e168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec35da8aa8f23fb6d38b9ea2bf26a362"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ERASURE__CODING.html#gaec35da8aa8f23fb6d38b9ea2bf26a362">doca_ec_task_update_set_update_matrix</a> (struct doca_ec_task_update *task, const struct doca_ec_matrix *update_matrix)</td></tr>
<tr class="memdesc:gaec35da8aa8f23fb6d38b9ea2bf26a362"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method sets the update_matrix of an update task.  <a href="group__DOCA__ERASURE__CODING.html#gaec35da8aa8f23fb6d38b9ea2bf26a362">More...</a><br /></td></tr>
<tr class="separator:gaec35da8aa8f23fb6d38b9ea2bf26a362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34cbf57214f2d837ade26bde430a3090"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> const struct doca_ec_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ERASURE__CODING.html#ga34cbf57214f2d837ade26bde430a3090">doca_ec_task_update_get_update_matrix</a> (const struct doca_ec_task_update *task)</td></tr>
<tr class="memdesc:ga34cbf57214f2d837ade26bde430a3090"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method gets the update_matrix of an update task.  <a href="group__DOCA__ERASURE__CODING.html#ga34cbf57214f2d837ade26bde430a3090">More...</a><br /></td></tr>
<tr class="separator:ga34cbf57214f2d837ade26bde430a3090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69d7c3134957a0cd35bb7ca9561bae37"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ERASURE__CODING.html#ga69d7c3134957a0cd35bb7ca9561bae37">doca_ec_task_update_set_original_updated_and_rdnc_blocks</a> (struct doca_ec_task_update *task, const struct doca_buf *original_updated_and_rdnc_blocks)</td></tr>
<tr class="memdesc:ga69d7c3134957a0cd35bb7ca9561bae37"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method sets the original_updated_and_rdnc_blocks buffer of an update task.  <a href="group__DOCA__ERASURE__CODING.html#ga69d7c3134957a0cd35bb7ca9561bae37">More...</a><br /></td></tr>
<tr class="separator:ga69d7c3134957a0cd35bb7ca9561bae37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b5d6cccbcfeb91978c9aaf8bfb54ca5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> const struct doca_buf *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ERASURE__CODING.html#ga6b5d6cccbcfeb91978c9aaf8bfb54ca5">doca_ec_task_update_get_original_updated_and_rdnc_blocks</a> (const struct doca_ec_task_update *task)</td></tr>
<tr class="memdesc:ga6b5d6cccbcfeb91978c9aaf8bfb54ca5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method gets the original_updated_and_rdnc_blocks buffer of an update task. The original_data_blocks buffer is a source buffer with data - A sequence containing the original data block and it's updated data block, for each block that was updated, followed by the old redundancy blocks - old_data_block_i, updated_data_block_i, old_data_block_j, updated_data_block_j ,... ,rdnc_block_1, rdnc_block_2 ,...  <a href="group__DOCA__ERASURE__CODING.html#ga6b5d6cccbcfeb91978c9aaf8bfb54ca5">More...</a><br /></td></tr>
<tr class="separator:ga6b5d6cccbcfeb91978c9aaf8bfb54ca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7df8b462bbf4b33fa14283d1b382605"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ERASURE__CODING.html#gae7df8b462bbf4b33fa14283d1b382605">doca_ec_task_update_set_updated_rdnc_blocks</a> (struct doca_ec_task_update *task, struct doca_buf *updated_rdnc_blocks)</td></tr>
<tr class="memdesc:gae7df8b462bbf4b33fa14283d1b382605"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method sets the updated_rdnc_blocks buffer of an update task.  <a href="group__DOCA__ERASURE__CODING.html#gae7df8b462bbf4b33fa14283d1b382605">More...</a><br /></td></tr>
<tr class="separator:gae7df8b462bbf4b33fa14283d1b382605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1dfcb729efebd5b6d5aa660ea90658d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> struct doca_buf *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ERASURE__CODING.html#ga1dfcb729efebd5b6d5aa660ea90658d3">doca_ec_task_update_get_updated_rdnc_blocks</a> (const struct doca_ec_task_update *task)</td></tr>
<tr class="memdesc:ga1dfcb729efebd5b6d5aa660ea90658d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method gets the updated_rdnc_blocks buffer of an update task. The rdnc_blocks buffer is a destination buffer for the redundancy blocks. On successful completion of this task, will hold a sequence containing all redundancy blocks - rdnc_block_1, rdnc_block_2 ,...  <a href="group__DOCA__ERASURE__CODING.html#ga1dfcb729efebd5b6d5aa660ea90658d3">More...</a><br /></td></tr>
<tr class="separator:ga1dfcb729efebd5b6d5aa660ea90658d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd260c112a685bd619056228f6cd24ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ERASURE__CODING.html#gafd260c112a685bd619056228f6cd24ee">doca_ec_cap_task_recover_is_supported</a> (const struct doca_devinfo *devinfo)</td></tr>
<tr class="separator:gafd260c112a685bd619056228f6cd24ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5457642a348fd934016165bc1f8f14b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ERASURE__CODING.html#gaa5457642a348fd934016165bc1f8f14b">doca_ec_task_recover_set_conf</a> (struct doca_ec *ec, <a class="el" href="group__DOCA__ERASURE__CODING.html#ga2563dc71fb7e17bf9071166f552fe6d3">doca_ec_task_recover_completion_cb_t</a> successful_task_completion_cb, <a class="el" href="group__DOCA__ERASURE__CODING.html#ga2563dc71fb7e17bf9071166f552fe6d3">doca_ec_task_recover_completion_cb_t</a> error_task_completion_cb, uint32_t num_tasks)</td></tr>
<tr class="memdesc:gaa5457642a348fd934016165bc1f8f14b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method sets the recover tasks configuration.  <a href="group__DOCA__ERASURE__CODING.html#gaa5457642a348fd934016165bc1f8f14b">More...</a><br /></td></tr>
<tr class="separator:gaa5457642a348fd934016165bc1f8f14b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b359de3f06b475fe8dbbd69f4a8951a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ERASURE__CODING.html#ga7b359de3f06b475fe8dbbd69f4a8951a">doca_ec_task_recover_allocate_init</a> (struct doca_ec *ec, const struct doca_ec_matrix *recover_matrix, const struct doca_buf *available_blocks, struct doca_buf *recovered_data_blocks, union <a class="el" href="uniondoca__data.html">doca_data</a> user_data, struct doca_ec_task_recover **task)</td></tr>
<tr class="memdesc:ga7b359de3f06b475fe8dbbd69f4a8951a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method allocates and initializes a recover task.  <a href="group__DOCA__ERASURE__CODING.html#ga7b359de3f06b475fe8dbbd69f4a8951a">More...</a><br /></td></tr>
<tr class="separator:ga7b359de3f06b475fe8dbbd69f4a8951a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa45db7f46348df0b7b04ebc815803e9f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> struct doca_task *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ERASURE__CODING.html#gaa45db7f46348df0b7b04ebc815803e9f">doca_ec_task_recover_as_task</a> (struct doca_ec_task_recover *task)</td></tr>
<tr class="memdesc:gaa45db7f46348df0b7b04ebc815803e9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method converts an EC recover task to a doca_task.  <a href="group__DOCA__ERASURE__CODING.html#gaa45db7f46348df0b7b04ebc815803e9f">More...</a><br /></td></tr>
<tr class="separator:gaa45db7f46348df0b7b04ebc815803e9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa11f062d125cf8965518ec71b39c3558"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ERASURE__CODING.html#gaa11f062d125cf8965518ec71b39c3558">doca_ec_task_recover_set_recover_matrix</a> (struct doca_ec_task_recover *task, const struct doca_ec_matrix *recover_matrix)</td></tr>
<tr class="memdesc:gaa11f062d125cf8965518ec71b39c3558"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method sets the recover_matrix of a recover task.  <a href="group__DOCA__ERASURE__CODING.html#gaa11f062d125cf8965518ec71b39c3558">More...</a><br /></td></tr>
<tr class="separator:gaa11f062d125cf8965518ec71b39c3558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafcf8ec321b660a4a5f70898fb347e99e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> const struct doca_ec_matrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ERASURE__CODING.html#gafcf8ec321b660a4a5f70898fb347e99e">doca_ec_task_recover_get_recover_matrix</a> (const struct doca_ec_task_recover *task)</td></tr>
<tr class="memdesc:gafcf8ec321b660a4a5f70898fb347e99e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method gets the recover_matrix of a recover task.  <a href="group__DOCA__ERASURE__CODING.html#gafcf8ec321b660a4a5f70898fb347e99e">More...</a><br /></td></tr>
<tr class="separator:gafcf8ec321b660a4a5f70898fb347e99e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga106b3198b8cbdde3a229b0ed160daf2c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ERASURE__CODING.html#ga106b3198b8cbdde3a229b0ed160daf2c">doca_ec_task_recover_set_available_blocks</a> (struct doca_ec_task_recover *task, const struct doca_buf *available_blocks)</td></tr>
<tr class="memdesc:ga106b3198b8cbdde3a229b0ed160daf2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method sets the available_blocks buffer of a recover task.  <a href="group__DOCA__ERASURE__CODING.html#ga106b3198b8cbdde3a229b0ed160daf2c">More...</a><br /></td></tr>
<tr class="separator:ga106b3198b8cbdde3a229b0ed160daf2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3fe41b34a9e0ffb3425a9cb7ee683b29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> const struct doca_buf *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ERASURE__CODING.html#ga3fe41b34a9e0ffb3425a9cb7ee683b29">doca_ec_task_recover_get_available_blocks</a> (const struct doca_ec_task_recover *task)</td></tr>
<tr class="memdesc:ga3fe41b34a9e0ffb3425a9cb7ee683b29"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method gets the available_blocks buffer of a recover task. The available_blocks buffer is a source buffer with data - A sequence containing all available data blocks and redundancy blocks - data_block_a, data_block_b, data_block_c ,... ,rdnc_block_x, rdnc_block_y ,...  <a href="group__DOCA__ERASURE__CODING.html#ga3fe41b34a9e0ffb3425a9cb7ee683b29">More...</a><br /></td></tr>
<tr class="separator:ga3fe41b34a9e0ffb3425a9cb7ee683b29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6dcb622b9270fc9932cd7a77a21cc27"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ERASURE__CODING.html#gae6dcb622b9270fc9932cd7a77a21cc27">doca_ec_task_recover_set_recovered_data_blocks</a> (struct doca_ec_task_recover *task, struct doca_buf *recovered_data_blocks)</td></tr>
<tr class="memdesc:gae6dcb622b9270fc9932cd7a77a21cc27"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method sets the recovered_data_blocks buffer of a recover task.  <a href="group__DOCA__ERASURE__CODING.html#gae6dcb622b9270fc9932cd7a77a21cc27">More...</a><br /></td></tr>
<tr class="separator:gae6dcb622b9270fc9932cd7a77a21cc27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40ca28764100eaf179d34d5fb3ae1c77"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> struct doca_buf *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ERASURE__CODING.html#ga40ca28764100eaf179d34d5fb3ae1c77">doca_ec_task_recover_get_recovered_data</a> (const struct doca_ec_task_recover *task)</td></tr>
<tr class="memdesc:ga40ca28764100eaf179d34d5fb3ae1c77"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method gets the recovered_data buffer of a recover task. The recovered_data buffer is a destination buffer for the recovered data blocks. On successful completion of this task, will hold a sequence containing all the recovered data blocks - data_block_i, data_block_j ,...  <a href="group__DOCA__ERASURE__CODING.html#ga40ca28764100eaf179d34d5fb3ae1c77">More...</a><br /></td></tr>
<tr class="separator:ga40ca28764100eaf179d34d5fb3ae1c77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga787fcc2e8a3e16b7fc6435a96802282e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ERASURE__CODING.html#ga787fcc2e8a3e16b7fc6435a96802282e">doca_ec_create</a> (struct doca_dev *dev, struct doca_ec **ec)</td></tr>
<tr class="memdesc:ga787fcc2e8a3e16b7fc6435a96802282e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a DOCA EC instance.  <a href="group__DOCA__ERASURE__CODING.html#ga787fcc2e8a3e16b7fc6435a96802282e">More...</a><br /></td></tr>
<tr class="separator:ga787fcc2e8a3e16b7fc6435a96802282e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga499b0ce2be9adcc24c06f6d428bda593"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ERASURE__CODING.html#ga499b0ce2be9adcc24c06f6d428bda593">doca_ec_destroy</a> (struct doca_ec *ec)</td></tr>
<tr class="memdesc:ga499b0ce2be9adcc24c06f6d428bda593"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a DOCA EC instance.  <a href="group__DOCA__ERASURE__CODING.html#ga499b0ce2be9adcc24c06f6d428bda593">More...</a><br /></td></tr>
<tr class="separator:ga499b0ce2be9adcc24c06f6d428bda593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae70758dc640bcb329666a05bd6623c7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> struct doca_ctx *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ERASURE__CODING.html#gae70758dc640bcb329666a05bd6623c7d">doca_ec_as_ctx</a> (struct doca_ec *ec)</td></tr>
<tr class="memdesc:gae70758dc640bcb329666a05bd6623c7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert EC instance into context.  <a href="group__DOCA__ERASURE__CODING.html#gae70758dc640bcb329666a05bd6623c7d">More...</a><br /></td></tr>
<tr class="separator:gae70758dc640bcb329666a05bd6623c7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad8317674b739cc70644c942ba66c6c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ERASURE__CODING.html#gaad8317674b739cc70644c942ba66c6c0">doca_ec_cap_get_max_block_size</a> (const struct doca_devinfo *devinfo, uint64_t *max_block_size)</td></tr>
<tr class="memdesc:gaad8317674b739cc70644c942ba66c6c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get maximum block size supported for DOCA EC tasks.  <a href="group__DOCA__ERASURE__CODING.html#gaad8317674b739cc70644c942ba66c6c0">More...</a><br /></td></tr>
<tr class="separator:gaad8317674b739cc70644c942ba66c6c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6dffec38dea0b091208805bbbdb7c73f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ERASURE__CODING.html#ga6dffec38dea0b091208805bbbdb7c73f">doca_ec_cap_get_max_buf_list_len</a> (const struct doca_devinfo *devinfo, uint32_t *max_buf_list_len)</td></tr>
<tr class="memdesc:ga6dffec38dea0b091208805bbbdb7c73f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum supported number of elements in DOCA linked-list buffer used for EC tasks.  <a href="group__DOCA__ERASURE__CODING.html#ga6dffec38dea0b091208805bbbdb7c73f">More...</a><br /></td></tr>
<tr class="separator:ga6dffec38dea0b091208805bbbdb7c73f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae64f4716c9a46cdc56a6b504d4790677"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ERASURE__CODING.html#gae64f4716c9a46cdc56a6b504d4790677">doca_ec_matrix_create</a> (struct doca_ec *ec, enum <a class="el" href="group__DOCA__ERASURE__CODING.html#ga4fb15cedefb4dc30e3a79a8fd1e795b6">doca_ec_matrix_type</a> <a class="el" href="upf__accel_8h.html#a5f649fbc43a239b31af8e53c8b76b756">type</a>, <a class="el" href="____stddef__size__t_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a> data_block_count, <a class="el" href="____stddef__size__t_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a> rdnc_block_count, struct doca_ec_matrix **matrix)</td></tr>
<tr class="memdesc:gae64f4716c9a46cdc56a6b504d4790677"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate coding matrix for Erasure Code encode i.e. most basic encode matrix. This is necessary for executing create tasks.  <a href="group__DOCA__ERASURE__CODING.html#gae64f4716c9a46cdc56a6b504d4790677">More...</a><br /></td></tr>
<tr class="separator:gae64f4716c9a46cdc56a6b504d4790677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga648f2103f8b81d6f5763d9793c3c2932"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ERASURE__CODING.html#ga648f2103f8b81d6f5763d9793c3c2932">doca_ec_matrix_create_from_raw</a> (struct doca_ec *ec, uint8_t *data, <a class="el" href="____stddef__size__t_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a> data_block_count, <a class="el" href="____stddef__size__t_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a> rdnc_block_count, struct doca_ec_matrix **matrix)</td></tr>
<tr class="memdesc:ga648f2103f8b81d6f5763d9793c3c2932"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create coding matrix for Erasure Code encode i.e. most basic encode matrix from char array. This is substitute for doca_ec_matrix_create which converts a char array to an DOCA EC matrix that can be used to execute different EC tasks.  <a href="group__DOCA__ERASURE__CODING.html#ga648f2103f8b81d6f5763d9793c3c2932">More...</a><br /></td></tr>
<tr class="separator:ga648f2103f8b81d6f5763d9793c3c2932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga946acc8bf43bd69bb2a8b48daec9c0e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ERASURE__CODING.html#ga946acc8bf43bd69bb2a8b48daec9c0e4">doca_ec_matrix_create_update</a> (struct doca_ec *ec, const struct doca_ec_matrix *coding_matrix, uint32_t update_indices[], <a class="el" href="____stddef__size__t_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a> n_updates, struct doca_ec_matrix **matrix)</td></tr>
<tr class="memdesc:ga946acc8bf43bd69bb2a8b48daec9c0e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate coding matrix for Erasure Code update. To use this function must call <a class="el" href="group__DOCA__ERASURE__CODING.html#gae64f4716c9a46cdc56a6b504d4790677" title="Generate coding matrix for Erasure Code encode i.e. most basic encode matrix. This is necessary for e...">doca_ec_matrix_create()</a> or <a class="el" href="group__DOCA__ERASURE__CODING.html#ga648f2103f8b81d6f5763d9793c3c2932" title="Create coding matrix for Erasure Code encode i.e. most basic encode matrix from char array....">doca_ec_matrix_create_from_raw()</a> before.  <a href="group__DOCA__ERASURE__CODING.html#ga946acc8bf43bd69bb2a8b48daec9c0e4">More...</a><br /></td></tr>
<tr class="separator:ga946acc8bf43bd69bb2a8b48daec9c0e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae32dab279d4e627cede8ea09baa8b52e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ERASURE__CODING.html#gae32dab279d4e627cede8ea09baa8b52e">doca_ec_matrix_create_recover</a> (struct doca_ec *ec, const struct doca_ec_matrix *coding_matrix, uint32_t missing_indices[], <a class="el" href="____stddef__size__t_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a> n_missing, struct doca_ec_matrix **matrix)</td></tr>
<tr class="memdesc:gae32dab279d4e627cede8ea09baa8b52e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate coding matrix for Erasure Code recovery from failure. To use this function must call <a class="el" href="group__DOCA__ERASURE__CODING.html#gae64f4716c9a46cdc56a6b504d4790677" title="Generate coding matrix for Erasure Code encode i.e. most basic encode matrix. This is necessary for e...">doca_ec_matrix_create()</a> or <a class="el" href="group__DOCA__ERASURE__CODING.html#ga648f2103f8b81d6f5763d9793c3c2932" title="Create coding matrix for Erasure Code encode i.e. most basic encode matrix from char array....">doca_ec_matrix_create_from_raw()</a> before.  <a href="group__DOCA__ERASURE__CODING.html#gae32dab279d4e627cede8ea09baa8b52e">More...</a><br /></td></tr>
<tr class="separator:gae32dab279d4e627cede8ea09baa8b52e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga988adee3d30b76552556dfbec16ca0d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ERASURE__CODING.html#ga988adee3d30b76552556dfbec16ca0d6">doca_ec_matrix_destroy</a> (struct doca_ec_matrix *matrix)</td></tr>
<tr class="memdesc:ga988adee3d30b76552556dfbec16ca0d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy coding matrix.  <a href="group__DOCA__ERASURE__CODING.html#ga988adee3d30b76552556dfbec16ca0d6">More...</a><br /></td></tr>
<tr class="separator:ga988adee3d30b76552556dfbec16ca0d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>DOCA Erasure Coding library. For more details please refer to the user guide on DOCA devzone. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga42860387eeebc0d91078fa2f0339bb86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga42860387eeebc0d91078fa2f0339bb86">&#9670;&nbsp;</a></span>doca_ec_task_create_completion_cb_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* doca_ec_task_create_completion_cb_t) (struct doca_ec_task_create *task, union <a class="el" href="uniondoca__data.html">doca_data</a> task_user_data, union <a class="el" href="uniondoca__data.html">doca_data</a> ctx_user_data)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to execute on completion of a create task. </p>
<p>This function is called by <a class="el" href="group__DOCA__PE.html#ga9a0e5d8d7a584dcc3db5c612875887cb" title="Run the progress engine.">doca_pe_progress()</a> when a create task is successfully identified as completed. When this function is called the ownership of the task object passes from DOCA back to user. Inside this callback the user may decide on the task object:</p><ul>
<li>re-submit task with <a class="el" href="group__DOCA__PE.html#ga632e751030cb01805462495099773776" title="Submit a task to a progress engine.">doca_task_submit()</a>; task object ownership passed to DOCA</li>
<li>release task with <a class="el" href="group__DOCA__PE.html#gae916a784f1e4119ded756ab1253abbed" title="Free a task back to where it was allocated from.">doca_task_free()</a>; task object ownership passed to DOCA</li>
<li>keep the task object for future re-use; user keeps the ownership on the task object Inside this callback the user shouldn't call <a class="el" href="group__DOCA__PE.html#ga9a0e5d8d7a584dcc3db5c612875887cb" title="Run the progress engine.">doca_pe_progress()</a>. Please see <a class="el" href="group__DOCA__PE.html#ga9a0e5d8d7a584dcc3db5c612875887cb" title="Run the progress engine.">doca_pe_progress()</a> for details.</li>
</ul>
<p>Any failure/error inside this function should be handled internally or deferred; Since this function is nested in the execution of <a class="el" href="group__DOCA__PE.html#ga9a0e5d8d7a584dcc3db5c612875887cb" title="Run the progress engine.">doca_pe_progress()</a>, this callback doesn't return an error.</p>
<dl class="section note"><dt>Note</dt><dd>This callback type is utilized for both successful &amp; failed task completions.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The completed create task. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The implementation can assume this value is not NULL. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task_user_data</td><td>The <a class="el" href="uniondoca__data.html" title="Convenience type for representing opaque data.">doca_data</a> supplied to the task by the application (during task allocation or by a setter). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx_user_data</td><td>The <a class="el" href="uniondoca__data.html" title="Convenience type for representing opaque data.">doca_data</a> supplied to the doca_ctx by the application (using a setter). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="doca__erasure__coding_8h_source.html#l00311">311</a> of file <a class="el" href="doca__erasure__coding_8h_source.html">doca_erasure_coding.h</a>.</p>

</div>
</div>
<a id="gaaf8c38dcf6373d1ad0a90b18a9ad566d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf8c38dcf6373d1ad0a90b18a9ad566d">&#9670;&nbsp;</a></span>doca_ec_task_galois_mul_completion_cb_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* doca_ec_task_galois_mul_completion_cb_t) (struct doca_ec_task_galois_mul *task, union <a class="el" href="uniondoca__data.html">doca_data</a> task_user_data, union <a class="el" href="uniondoca__data.html">doca_data</a> ctx_user_data)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to execute on completion of a Galois multiplication task. </p>
<p>This function is called by <a class="el" href="group__DOCA__PE.html#ga9a0e5d8d7a584dcc3db5c612875887cb" title="Run the progress engine.">doca_pe_progress()</a> when a Galois multiplication task is successfully identified as completed. When this function is called the ownership of the task object passes from DOCA back to user. Inside this callback the user may decide on the task object:</p><ul>
<li>re-submit task with <a class="el" href="group__DOCA__PE.html#ga632e751030cb01805462495099773776" title="Submit a task to a progress engine.">doca_task_submit()</a>; task object ownership passed to DOCA</li>
<li>release task with <a class="el" href="group__DOCA__PE.html#gae916a784f1e4119ded756ab1253abbed" title="Free a task back to where it was allocated from.">doca_task_free()</a>; task object ownership passed to DOCA</li>
<li>keep the task object for future re-use; user keeps the ownership on the task object Inside this callback the user shouldn't call <a class="el" href="group__DOCA__PE.html#ga9a0e5d8d7a584dcc3db5c612875887cb" title="Run the progress engine.">doca_pe_progress()</a>. Please see <a class="el" href="group__DOCA__PE.html#ga9a0e5d8d7a584dcc3db5c612875887cb" title="Run the progress engine.">doca_pe_progress()</a> for details.</li>
</ul>
<p>Any failure/error inside this function should be handled internally or deferred; Since this function is nested in the execution of <a class="el" href="group__DOCA__PE.html#ga9a0e5d8d7a584dcc3db5c612875887cb" title="Run the progress engine.">doca_pe_progress()</a>, this callback doesn't return an error.</p>
<dl class="section note"><dt>Note</dt><dd>This callback type is utilized for both successful &amp; failed task completions.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The completed Galois multiplication task. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The implementation can assume this value is not NULL. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task_user_data</td><td>The <a class="el" href="uniondoca__data.html" title="Convenience type for representing opaque data.">doca_data</a> supplied to the task by the application (during task allocation or by a setter). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx_user_data</td><td>The <a class="el" href="uniondoca__data.html" title="Convenience type for representing opaque data.">doca_data</a> supplied to the doca_ctx by the application (using a setter). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="doca__erasure__coding_8h_source.html#l00092">92</a> of file <a class="el" href="doca__erasure__coding_8h_source.html">doca_erasure_coding.h</a>.</p>

</div>
</div>
<a id="ga2563dc71fb7e17bf9071166f552fe6d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2563dc71fb7e17bf9071166f552fe6d3">&#9670;&nbsp;</a></span>doca_ec_task_recover_completion_cb_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* doca_ec_task_recover_completion_cb_t) (struct doca_ec_task_recover *task, union <a class="el" href="uniondoca__data.html">doca_data</a> task_user_data, union <a class="el" href="uniondoca__data.html">doca_data</a> ctx_user_data)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to execute on completion of a recover task. </p>
<p>This function is called by <a class="el" href="group__DOCA__PE.html#ga9a0e5d8d7a584dcc3db5c612875887cb" title="Run the progress engine.">doca_pe_progress()</a> when a recover task is successfully identified as completed. When this function is called the ownership of the task object passes from DOCA back to user. Inside this callback the user may decide on the task object:</p><ul>
<li>re-submit task with <a class="el" href="group__DOCA__PE.html#ga632e751030cb01805462495099773776" title="Submit a task to a progress engine.">doca_task_submit()</a>; task object ownership passed to DOCA</li>
<li>release task with <a class="el" href="group__DOCA__PE.html#gae916a784f1e4119ded756ab1253abbed" title="Free a task back to where it was allocated from.">doca_task_free()</a>; task object ownership passed to DOCA</li>
<li>keep the task object for future re-use; user keeps the ownership on the task object Inside this callback the user shouldn't call <a class="el" href="group__DOCA__PE.html#ga9a0e5d8d7a584dcc3db5c612875887cb" title="Run the progress engine.">doca_pe_progress()</a>. Please see <a class="el" href="group__DOCA__PE.html#ga9a0e5d8d7a584dcc3db5c612875887cb" title="Run the progress engine.">doca_pe_progress()</a> for details.</li>
</ul>
<p>Any failure/error inside this function should be handled internally or deferred; Since this function is nested in the execution of <a class="el" href="group__DOCA__PE.html#ga9a0e5d8d7a584dcc3db5c612875887cb" title="Run the progress engine.">doca_pe_progress()</a>, this callback doesn't return an error.</p>
<dl class="section note"><dt>Note</dt><dd>This callback type is utilized for both successful &amp; failed task completions.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The completed recover task. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The implementation can assume this value is not NULL. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task_user_data</td><td>The <a class="el" href="uniondoca__data.html" title="Convenience type for representing opaque data.">doca_data</a> supplied to the task by the application (during task allocation or by a setter). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx_user_data</td><td>The <a class="el" href="uniondoca__data.html" title="Convenience type for representing opaque data.">doca_data</a> supplied to the doca_ctx by the application (using a setter). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="doca__erasure__coding_8h_source.html#l00772">772</a> of file <a class="el" href="doca__erasure__coding_8h_source.html">doca_erasure_coding.h</a>.</p>

</div>
</div>
<a id="gaabc6520e67af390486ee5709eb26bf06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaabc6520e67af390486ee5709eb26bf06">&#9670;&nbsp;</a></span>doca_ec_task_update_completion_cb_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* doca_ec_task_update_completion_cb_t) (struct doca_ec_task_update *task, union <a class="el" href="uniondoca__data.html">doca_data</a> task_user_data, union <a class="el" href="uniondoca__data.html">doca_data</a> ctx_user_data)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to execute on completion of an update task. </p>
<p>This function is called by <a class="el" href="group__DOCA__PE.html#ga9a0e5d8d7a584dcc3db5c612875887cb" title="Run the progress engine.">doca_pe_progress()</a> when an update task is successfully identified as completed. When this function is called the ownership of the task object passes from DOCA back to user. Inside this callback the user may decide on the task object:</p><ul>
<li>re-submit task with <a class="el" href="group__DOCA__PE.html#ga632e751030cb01805462495099773776" title="Submit a task to a progress engine.">doca_task_submit()</a>; task object ownership passed to DOCA</li>
<li>release task with <a class="el" href="group__DOCA__PE.html#gae916a784f1e4119ded756ab1253abbed" title="Free a task back to where it was allocated from.">doca_task_free()</a>; task object ownership passed to DOCA</li>
<li>keep the task object for future re-use; user keeps the ownership on the task object Inside this callback the user shouldn't call <a class="el" href="group__DOCA__PE.html#ga9a0e5d8d7a584dcc3db5c612875887cb" title="Run the progress engine.">doca_pe_progress()</a>. Please see <a class="el" href="group__DOCA__PE.html#ga9a0e5d8d7a584dcc3db5c612875887cb" title="Run the progress engine.">doca_pe_progress()</a> for details.</li>
</ul>
<p>Any failure/error inside this function should be handled internally or deferred; Since this function is nested in the execution of <a class="el" href="group__DOCA__PE.html#ga9a0e5d8d7a584dcc3db5c612875887cb" title="Run the progress engine.">doca_pe_progress()</a>, this callback doesn't return an error.</p>
<dl class="section note"><dt>Note</dt><dd>This callback type is utilized for both successful &amp; failed task completions.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The completed update task. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The implementation can assume this value is not NULL. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task_user_data</td><td>The <a class="el" href="uniondoca__data.html" title="Convenience type for representing opaque data.">doca_data</a> supplied to the task by the application (during task allocation or by a setter). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx_user_data</td><td>The <a class="el" href="uniondoca__data.html" title="Convenience type for representing opaque data.">doca_data</a> supplied to the doca_ctx by the application (using a setter). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="doca__erasure__coding_8h_source.html#l00538">538</a> of file <a class="el" href="doca__erasure__coding_8h_source.html">doca_erasure_coding.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga4fb15cedefb4dc30e3a79a8fd1e795b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4fb15cedefb4dc30e3a79a8fd1e795b6">&#9670;&nbsp;</a></span>doca_ec_matrix_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__DOCA__ERASURE__CODING.html#ga4fb15cedefb4dc30e3a79a8fd1e795b6">doca_ec_matrix_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Types of coding matrix used for erasure codes. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga4fb15cedefb4dc30e3a79a8fd1e795b6a69e444bb75f3afe6ce1e068b1151118d"></a>DOCA_EC_MATRIX_TYPE_CAUCHY&#160;</td><td class="fielddoc"><p>Cauchy matrix of coding.</p>
<p>Cauchy matrix guarantees any sub-matrix will be invertible. The matrix is constructed in the following form: a_i_j = 1/(x_i + y_j) where 0 &lt;= i &lt; number of data blocks, 0 &lt;= j &lt; number of redundancy blocks, x_i = i, y_j = j + number of data blocks</p>
<p>This is the recommended type to use. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4fb15cedefb4dc30e3a79a8fd1e795b6a422bd96be7877d992355c26d3cd02382"></a>DOCA_EC_MATRIX_TYPE_VANDERMONDE&#160;</td><td class="fielddoc"><p>Vandermonde matrix of coding.</p>
<p>Vandermonde matrix does not guarantee every sub-matrix will be invertible. The matrix is constructed in the following form: a_i_j = (i + 1)^j where 0 &lt;= i &lt; number of data blocks, 0 &lt;= j &lt; number of redundancy blocks</p>
<p>Because this matrix does not guarantee invertible it is less recommended to use. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="doca__erasure__coding_8h_source.html#l01067">1067</a> of file <a class="el" href="doca__erasure__coding_8h_source.html">doca_erasure_coding.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gae70758dc640bcb329666a05bd6623c7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae70758dc640bcb329666a05bd6623c7d">&#9670;&nbsp;</a></span>doca_ec_as_ctx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> struct doca_ctx* doca_ec_as_ctx </td>
          <td>(</td>
          <td class="paramtype">struct doca_ec *&#160;</td>
          <td class="paramname"><em>ec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert EC instance into context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ec</td><td>EC instance. This must remain valid until after the context is no longer required.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success doca_ctx object, otherwise NULL. </dd></dl>

</div>
</div>
<a id="gaad8317674b739cc70644c942ba66c6c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad8317674b739cc70644c942ba66c6c0">&#9670;&nbsp;</a></span>doca_ec_cap_get_max_block_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_ec_cap_get_max_block_size </td>
          <td>(</td>
          <td class="paramtype">const struct doca_devinfo *&#160;</td>
          <td class="paramname"><em>devinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>max_block_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get maximum block size supported for DOCA EC tasks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">devinfo</td><td>The DOCA device information that should be queried. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">max_block_size</td><td>The max block size for DOCA EC operation in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input.</li>
<li>DOCA_ERROR_NOT_SUPPORTED - failed to query device capabilities or provided devinfo does not support EC. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga6dffec38dea0b091208805bbbdb7c73f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6dffec38dea0b091208805bbbdb7c73f">&#9670;&nbsp;</a></span>doca_ec_cap_get_max_buf_list_len()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_ec_cap_get_max_buf_list_len </td>
          <td>(</td>
          <td class="paramtype">const struct doca_devinfo *&#160;</td>
          <td class="paramname"><em>devinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>max_buf_list_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the maximum supported number of elements in DOCA linked-list buffer used for EC tasks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">devinfo</td><td>The DOCA device information that should be queried. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">max_buf_list_len</td><td>The maximum supported number of elements in DOCA linked-list buffer. The value 1 indicates that only a single element is supported.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga0302911e18b0cba98b54867986786b09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0302911e18b0cba98b54867986786b09">&#9670;&nbsp;</a></span>doca_ec_cap_task_create_is_supported()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_ec_cap_task_create_is_supported </td>
          <td>(</td>
          <td class="paramtype">const struct doca_devinfo *&#160;</td>
          <td class="paramname"><em>devinfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if a given device supports executing a create task.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">devinfo</td><td>The DOCA device information that should be queried.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case device supports the task. Error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input.</li>
<li>DOCA_ERROR_NOT_SUPPORTED - provided devinfo does not support the task. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gae1d6a1066a26a215694d18f5bcd85bb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae1d6a1066a26a215694d18f5bcd85bb7">&#9670;&nbsp;</a></span>doca_ec_cap_task_galois_mul_is_supported()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_ec_cap_task_galois_mul_is_supported </td>
          <td>(</td>
          <td class="paramtype">const struct doca_devinfo *&#160;</td>
          <td class="paramname"><em>devinfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if a given device supports executing a Galois multiplication task.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">devinfo</td><td>The DOCA device information that should be queried.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case device supports the task. Error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input.</li>
<li>DOCA_ERROR_NOT_SUPPORTED - provided devinfo does not support the task. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gafd260c112a685bd619056228f6cd24ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd260c112a685bd619056228f6cd24ee">&#9670;&nbsp;</a></span>doca_ec_cap_task_recover_is_supported()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_ec_cap_task_recover_is_supported </td>
          <td>(</td>
          <td class="paramtype">const struct doca_devinfo *&#160;</td>
          <td class="paramname"><em>devinfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if a given device supports executing a recover task.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">devinfo</td><td>The DOCA device information that should be queried.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case device supports the task. Error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input.</li>
<li>DOCA_ERROR_NOT_SUPPORTED - provided devinfo does not support the task. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga21518715a70bca719cb42ac33ec8845a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga21518715a70bca719cb42ac33ec8845a">&#9670;&nbsp;</a></span>doca_ec_cap_task_update_is_supported()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_ec_cap_task_update_is_supported </td>
          <td>(</td>
          <td class="paramtype">const struct doca_devinfo *&#160;</td>
          <td class="paramname"><em>devinfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if a given device supports executing an update task.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">devinfo</td><td>The DOCA device information that should be queried.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case device supports the task. Error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input.</li>
<li>DOCA_ERROR_NOT_SUPPORTED - provided devinfo does not support the task. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga787fcc2e8a3e16b7fc6435a96802282e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga787fcc2e8a3e16b7fc6435a96802282e">&#9670;&nbsp;</a></span>doca_ec_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_ec_create </td>
          <td>(</td>
          <td class="paramtype">struct doca_dev *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct doca_ec **&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a DOCA EC instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>The device to attach to the EC instance. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ec</td><td>Pointer to pointer to be set to point to the created doca_ec instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - ec argument is a NULL pointer.</li>
<li>DOCA_ERROR_NO_MEMORY - failed to allocate sufficient memory for doca_ec. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga499b0ce2be9adcc24c06f6d428bda593"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga499b0ce2be9adcc24c06f6d428bda593">&#9670;&nbsp;</a></span>doca_ec_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_ec_destroy </td>
          <td>(</td>
          <td class="paramtype">struct doca_ec *&#160;</td>
          <td class="paramname"><em>ec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a DOCA EC instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ec</td><td>Pointer to instance to be destroyed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_BAD_STATE - EC context is not idle. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gae64f4716c9a46cdc56a6b504d4790677"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae64f4716c9a46cdc56a6b504d4790677">&#9670;&nbsp;</a></span>doca_ec_matrix_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_ec_matrix_create </td>
          <td>(</td>
          <td class="paramtype">struct doca_ec *&#160;</td>
          <td class="paramname"><em>ec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__DOCA__ERASURE__CODING.html#ga4fb15cedefb4dc30e3a79a8fd1e795b6">doca_ec_matrix_type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="____stddef__size__t_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a>&#160;</td>
          <td class="paramname"><em>data_block_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="____stddef__size__t_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a>&#160;</td>
          <td class="paramname"><em>rdnc_block_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct doca_ec_matrix **&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate coding matrix for Erasure Code encode i.e. most basic encode matrix. This is necessary for executing create tasks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ec</td><td>EC instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>Provided in enum doca_ec_matrix_type, the type will be consistent in recovery/update process. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data_block_count</td><td>The number of original data blocks. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rdnc_block_count</td><td>The number of redundancy blocks. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">matrix</td><td>The coding matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga648f2103f8b81d6f5763d9793c3c2932"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga648f2103f8b81d6f5763d9793c3c2932">&#9670;&nbsp;</a></span>doca_ec_matrix_create_from_raw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_ec_matrix_create_from_raw </td>
          <td>(</td>
          <td class="paramtype">struct doca_ec *&#160;</td>
          <td class="paramname"><em>ec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="____stddef__size__t_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a>&#160;</td>
          <td class="paramname"><em>data_block_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="____stddef__size__t_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a>&#160;</td>
          <td class="paramname"><em>rdnc_block_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct doca_ec_matrix **&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create coding matrix for Erasure Code encode i.e. most basic encode matrix from char array. This is substitute for doca_ec_matrix_create which converts a char array to an DOCA EC matrix that can be used to execute different EC tasks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ec</td><td>EC instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The data of a coding matrix with size data_block_count * rdnc_block_count. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data_block_count</td><td>The number of original data blocks. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rdnc_block_count</td><td>The number of redundancy blocks. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">matrix</td><td>The coding matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gae32dab279d4e627cede8ea09baa8b52e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae32dab279d4e627cede8ea09baa8b52e">&#9670;&nbsp;</a></span>doca_ec_matrix_create_recover()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_ec_matrix_create_recover </td>
          <td>(</td>
          <td class="paramtype">struct doca_ec *&#160;</td>
          <td class="paramname"><em>ec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct doca_ec_matrix *&#160;</td>
          <td class="paramname"><em>coding_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>missing_indices</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="____stddef__size__t_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a>&#160;</td>
          <td class="paramname"><em>n_missing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct doca_ec_matrix **&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate coding matrix for Erasure Code recovery from failure. To use this function must call <a class="el" href="group__DOCA__ERASURE__CODING.html#gae64f4716c9a46cdc56a6b504d4790677" title="Generate coding matrix for Erasure Code encode i.e. most basic encode matrix. This is necessary for e...">doca_ec_matrix_create()</a> or <a class="el" href="group__DOCA__ERASURE__CODING.html#ga648f2103f8b81d6f5763d9793c3c2932" title="Create coding matrix for Erasure Code encode i.e. most basic encode matrix from char array....">doca_ec_matrix_create_from_raw()</a> before. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ec</td><td>EC instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coding_matrix</td><td>A coding matrix as it was created by <a class="el" href="group__DOCA__ERASURE__CODING.html#gae64f4716c9a46cdc56a6b504d4790677" title="Generate coding matrix for Erasure Code encode i.e. most basic encode matrix. This is necessary for e...">doca_ec_matrix_create()</a> or <a class="el" href="group__DOCA__ERASURE__CODING.html#ga648f2103f8b81d6f5763d9793c3c2932" title="Create coding matrix for Erasure Code encode i.e. most basic encode matrix from char array....">doca_ec_matrix_create_from_raw()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">missing_indices</td><td>An array specifying the indices of the missing data blocks. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The indices need to be in ascending order. </dd>
<dd>
The indices should match the order of the data blocks in the matrix creation function. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n_missing</td><td>missing_indices count. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">matrix</td><td>The recover coding matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga946acc8bf43bd69bb2a8b48daec9c0e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga946acc8bf43bd69bb2a8b48daec9c0e4">&#9670;&nbsp;</a></span>doca_ec_matrix_create_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_ec_matrix_create_update </td>
          <td>(</td>
          <td class="paramtype">struct doca_ec *&#160;</td>
          <td class="paramname"><em>ec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct doca_ec_matrix *&#160;</td>
          <td class="paramname"><em>coding_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>update_indices</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="____stddef__size__t_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a>&#160;</td>
          <td class="paramname"><em>n_updates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct doca_ec_matrix **&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate coding matrix for Erasure Code update. To use this function must call <a class="el" href="group__DOCA__ERASURE__CODING.html#gae64f4716c9a46cdc56a6b504d4790677" title="Generate coding matrix for Erasure Code encode i.e. most basic encode matrix. This is necessary for e...">doca_ec_matrix_create()</a> or <a class="el" href="group__DOCA__ERASURE__CODING.html#ga648f2103f8b81d6f5763d9793c3c2932" title="Create coding matrix for Erasure Code encode i.e. most basic encode matrix from char array....">doca_ec_matrix_create_from_raw()</a> before. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ec</td><td>EC instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coding_matrix</td><td>A coding matrix as it was created by <a class="el" href="group__DOCA__ERASURE__CODING.html#gae64f4716c9a46cdc56a6b504d4790677" title="Generate coding matrix for Erasure Code encode i.e. most basic encode matrix. This is necessary for e...">doca_ec_matrix_create()</a> or <a class="el" href="group__DOCA__ERASURE__CODING.html#ga648f2103f8b81d6f5763d9793c3c2932" title="Create coding matrix for Erasure Code encode i.e. most basic encode matrix from char array....">doca_ec_matrix_create_from_raw()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">update_indices</td><td>An array specifying the indices of the updated data blocks. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The indices need to be in ascending order. </dd>
<dd>
The indices should match the order of the data blocks in the matrix creation function. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n_updates</td><td>update_indices count. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">matrix</td><td>The update coding matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga988adee3d30b76552556dfbec16ca0d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga988adee3d30b76552556dfbec16ca0d6">&#9670;&nbsp;</a></span>doca_ec_matrix_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_ec_matrix_destroy </td>
          <td>(</td>
          <td class="paramtype">struct doca_ec_matrix *&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy coding matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>A coding matrix as it was created by <a class="el" href="group__DOCA__ERASURE__CODING.html#gae64f4716c9a46cdc56a6b504d4790677" title="Generate coding matrix for Erasure Code encode i.e. most basic encode matrix. This is necessary for e...">doca_ec_matrix_create()</a> or <a class="el" href="group__DOCA__ERASURE__CODING.html#ga648f2103f8b81d6f5763d9793c3c2932" title="Create coding matrix for Erasure Code encode i.e. most basic encode matrix from char array....">doca_ec_matrix_create_from_raw()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga523e6cb9b75baab43444db3135ed3e3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga523e6cb9b75baab43444db3135ed3e3a">&#9670;&nbsp;</a></span>doca_ec_task_create_allocate_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_ec_task_create_allocate_init </td>
          <td>(</td>
          <td class="paramtype">struct doca_ec *&#160;</td>
          <td class="paramname"><em>ec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct doca_ec_matrix *&#160;</td>
          <td class="paramname"><em>coding_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct doca_buf *&#160;</td>
          <td class="paramname"><em>original_data_blocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct doca_buf *&#160;</td>
          <td class="paramname"><em>rdnc_blocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">union <a class="el" href="uniondoca__data.html">doca_data</a>&#160;</td>
          <td class="paramname"><em>user_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct doca_ec_task_create **&#160;</td>
          <td class="paramname"><em>task</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method allocates and initializes a create task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ec</td><td>The EC instance to allocate the task for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coding_matrix</td><td>A coding matrix as it was create by <a class="el" href="group__DOCA__ERASURE__CODING.html#gae64f4716c9a46cdc56a6b504d4790677" title="Generate coding matrix for Erasure Code encode i.e. most basic encode matrix. This is necessary for e...">doca_ec_matrix_create()</a> or <a class="el" href="group__DOCA__ERASURE__CODING.html#ga648f2103f8b81d6f5763d9793c3c2932" title="Create coding matrix for Erasure Code encode i.e. most basic encode matrix from char array....">doca_ec_matrix_create_from_raw()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">original_data_blocks</td><td>A source buffer with data - A sequence containing all original data blocks - block_1, block_2 ,... </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rdnc_blocks</td><td>A destination buffer for the redundancy blocks. On successful completion of this task, will hold a sequence containing all redundancy blocks - rdnc_block_1, rdnc_block_2 ,... </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user_data</td><td><a class="el" href="uniondoca__data.html" title="Convenience type for representing opaque data.">doca_data</a> to attach to the task. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">task</td><td>On success, an allocated and initialized create task.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The data length of original_data_blocks and the minimal available memory in rdnc_blocks should be in multiplication of block size. For example, for a given coding matrix that is 10x4 (10 original blocks, 4 redundancy blocks) - original_data_blocks data length should be: 10x64KB = 640KB. rdnc_blocks available memory should be at least: 4x64KB = 256KB.</dd></dl>
<p>They also should be aligned to 64B and with a minimum size of 64B. For example: 500B size should be padded to be 512B.</p>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input.</li>
<li>DOCA_ERROR_NO_MEMORY - no more tasks to allocate. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gad2f079344bcfb5cbe2c3b329bca82e26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad2f079344bcfb5cbe2c3b329bca82e26">&#9670;&nbsp;</a></span>doca_ec_task_create_as_task()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> struct doca_task* doca_ec_task_create_as_task </td>
          <td>(</td>
          <td class="paramtype">struct doca_ec_task_create *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method converts an EC create task to a doca_task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task that should be converted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>doca_task </dd></dl>

</div>
</div>
<a id="ga98b9a5385109bf28d8dcee523613e3c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga98b9a5385109bf28d8dcee523613e3c7">&#9670;&nbsp;</a></span>doca_ec_task_create_get_coding_matrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> const struct doca_ec_matrix* doca_ec_task_create_get_coding_matrix </td>
          <td>(</td>
          <td class="paramtype">const struct doca_ec_task_create *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method gets the coding matrix of a create task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task that should be queried.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The task's coding_matrix. </dd></dl>

</div>
</div>
<a id="ga851da283b8f930e552fb4342d7fd671f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga851da283b8f930e552fb4342d7fd671f">&#9670;&nbsp;</a></span>doca_ec_task_create_get_original_data_blocks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> const struct doca_buf* doca_ec_task_create_get_original_data_blocks </td>
          <td>(</td>
          <td class="paramtype">const struct doca_ec_task_create *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method gets the original_data_blocks buffer of a create task. The original_data_blocks buffer is a source buffer with data - A sequence containing all original data blocks - block_1, block_2 ,... </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task that should be queried.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The task's original_data_blocks buffer. </dd></dl>

</div>
</div>
<a id="gad04bd441d062f06810187de6c80cc883"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad04bd441d062f06810187de6c80cc883">&#9670;&nbsp;</a></span>doca_ec_task_create_get_rdnc_blocks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> struct doca_buf* doca_ec_task_create_get_rdnc_blocks </td>
          <td>(</td>
          <td class="paramtype">const struct doca_ec_task_create *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method gets the rdnc_blocks buffer of a create task. The rdnc_blocks buffer is a destination buffer for the redundancy blocks. On successful completion of this task, will hold a sequence containing all redundancy blocks - rdnc_block_1, rdnc_block_2 ,... </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task that should be queried.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The task's rdnc_blocks buffer. </dd></dl>

</div>
</div>
<a id="ga66f94e0dc5f9288bd82cad2fcf15356b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga66f94e0dc5f9288bd82cad2fcf15356b">&#9670;&nbsp;</a></span>doca_ec_task_create_set_coding_matrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> void doca_ec_task_create_set_coding_matrix </td>
          <td>(</td>
          <td class="paramtype">struct doca_ec_task_create *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct doca_ec_matrix *&#160;</td>
          <td class="paramname"><em>coding_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method sets the coding_matrix of a create task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task to set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coding_matrix</td><td>A coding matrix as it was create by <a class="el" href="group__DOCA__ERASURE__CODING.html#gae64f4716c9a46cdc56a6b504d4790677" title="Generate coding matrix for Erasure Code encode i.e. most basic encode matrix. This is necessary for e...">doca_ec_matrix_create()</a> or <a class="el" href="group__DOCA__ERASURE__CODING.html#ga648f2103f8b81d6f5763d9793c3c2932" title="Create coding matrix for Erasure Code encode i.e. most basic encode matrix from char array....">doca_ec_matrix_create_from_raw()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2a0dbff2ab3528ae54a60f4565e6f256"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2a0dbff2ab3528ae54a60f4565e6f256">&#9670;&nbsp;</a></span>doca_ec_task_create_set_conf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_ec_task_create_set_conf </td>
          <td>(</td>
          <td class="paramtype">struct doca_ec *&#160;</td>
          <td class="paramname"><em>ec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DOCA__ERASURE__CODING.html#ga42860387eeebc0d91078fa2f0339bb86">doca_ec_task_create_completion_cb_t</a>&#160;</td>
          <td class="paramname"><em>successful_task_completion_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DOCA__ERASURE__CODING.html#ga42860387eeebc0d91078fa2f0339bb86">doca_ec_task_create_completion_cb_t</a>&#160;</td>
          <td class="paramname"><em>error_task_completion_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num_tasks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method sets the create tasks configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ec</td><td>The EC instance to config. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">successful_task_completion_cb</td><td>A callback function for create tasks that were completed successfully. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">error_task_completion_cb</td><td>A callback function for create tasks that were completed with an error. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_tasks</td><td>Number of create tasks.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga8da7d4fe0ee585f00fd7238021844040"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8da7d4fe0ee585f00fd7238021844040">&#9670;&nbsp;</a></span>doca_ec_task_create_set_original_data_blocks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> void doca_ec_task_create_set_original_data_blocks </td>
          <td>(</td>
          <td class="paramtype">struct doca_ec_task_create *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct doca_buf *&#160;</td>
          <td class="paramname"><em>original_data_blocks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method sets the original_data_blocks buffer of a create task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task to set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">original_data_blocks</td><td>A source buffer with data - A sequence containing all original data blocks - block_1, block_2 ,...</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The data length of original_data_blocks should be in multiplication of block size. For example, for a given coding matrix that is 10x4 (10 original blocks, 4 redundancy blocks) - original_data_blocks data length should be: 10x64KB = 640KB.</dd></dl>
<p>The data length should also be aligned to 64B and with a minimum size of 64B. For example: 500B size should be padded to be 512B. </p>

</div>
</div>
<a id="ga7b9157e2cb3bc9de36ce24689417419d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b9157e2cb3bc9de36ce24689417419d">&#9670;&nbsp;</a></span>doca_ec_task_create_set_rdnc_blocks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> void doca_ec_task_create_set_rdnc_blocks </td>
          <td>(</td>
          <td class="paramtype">struct doca_ec_task_create *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct doca_buf *&#160;</td>
          <td class="paramname"><em>rdnc_blocks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method sets the rdnc_blocks buffer of a create task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task to set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rdnc_blocks</td><td>A destination buffer for the redundancy blocks. On successful completion of this task, will hold a sequence containing all redundancy blocks - rdnc_block_1, rdnc_block_2 ,...</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The minimal available memory in rdnc_blocks should be in multiplication of block size. For example, for a given coding matrix that is 10x4 (10 original blocks, 4 redundancy blocks) - rdnc_blocks available memory should be at least: 4x64KB = 256KB.</dd></dl>
<p>The minimal available memory should also be aligned to 64B and at least 64B. For example: 500B size should be padded to be 512B at the least. </p>

</div>
</div>
<a id="ga81c41a295c06f30e56ea7e258e70e5d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga81c41a295c06f30e56ea7e258e70e5d0">&#9670;&nbsp;</a></span>doca_ec_task_galois_mul_allocate_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_ec_task_galois_mul_allocate_init </td>
          <td>(</td>
          <td class="paramtype">struct doca_ec *&#160;</td>
          <td class="paramname"><em>ec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct doca_ec_matrix *&#160;</td>
          <td class="paramname"><em>coding_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct doca_buf *&#160;</td>
          <td class="paramname"><em>src_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct doca_buf *&#160;</td>
          <td class="paramname"><em>dst_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">union <a class="el" href="uniondoca__data.html">doca_data</a>&#160;</td>
          <td class="paramname"><em>user_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct doca_ec_task_galois_mul **&#160;</td>
          <td class="paramname"><em>task</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method allocates and initializes a Galois multiplication task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ec</td><td>The EC instance to allocate the task for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coding_matrix</td><td>A coding matrix as it was create by <a class="el" href="group__DOCA__ERASURE__CODING.html#gae64f4716c9a46cdc56a6b504d4790677" title="Generate coding matrix for Erasure Code encode i.e. most basic encode matrix. This is necessary for e...">doca_ec_matrix_create()</a> or <a class="el" href="group__DOCA__ERASURE__CODING.html#ga648f2103f8b81d6f5763d9793c3c2932" title="Create coding matrix for Erasure Code encode i.e. most basic encode matrix from char array....">doca_ec_matrix_create_from_raw()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src_buf</td><td>A source buffer with data - A sequence containing data blocks - block_1, block_2 ,... </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dst_buf</td><td>Destination data buffer. On successful completion of this task, will hold a sequence containing all multiplication outcome blocks - dst_block_1, dst_block_2 ,... </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user_data</td><td><a class="el" href="uniondoca__data.html" title="Convenience type for representing opaque data.">doca_data</a> to attach to the task. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">task</td><td>On success, an allocated and initialized Galois multiplication task.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The data length of src_buf and the minimal available memory in dst_buf should be in multiplication of block size. For example, for a given coding matrix that is 10x4 (10 original blocks, 4 redundancy blocks) - src_buf data length should be: 10x64KB = 640KB. dst_buf available memory should be at least: 4x64KB = 256KB.</dd></dl>
<p>They also should be aligned to 64B and with a minimum size of 64B. For example: 500B size should be padded to be 512B.</p>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input.</li>
<li>DOCA_ERROR_NO_MEMORY - no more tasks to allocate. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaa8edb3516cbce5d7c6661d12075ede59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8edb3516cbce5d7c6661d12075ede59">&#9670;&nbsp;</a></span>doca_ec_task_galois_mul_as_task()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> struct doca_task* doca_ec_task_galois_mul_as_task </td>
          <td>(</td>
          <td class="paramtype">struct doca_ec_task_galois_mul *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method converts an EC Galois multiplication task to a doca_task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task that should be converted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>doca_task </dd></dl>

</div>
</div>
<a id="gafddf5be14c735d14d582843d6a5d4f3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafddf5be14c735d14d582843d6a5d4f3d">&#9670;&nbsp;</a></span>doca_ec_task_galois_mul_get_coding_matrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> const struct doca_ec_matrix* doca_ec_task_galois_mul_get_coding_matrix </td>
          <td>(</td>
          <td class="paramtype">const struct doca_ec_task_galois_mul *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method gets the coding matrix of a Galois multiplication task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task that should be queried.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The task's coding_matrix. </dd></dl>

</div>
</div>
<a id="ga47a2340f9d7e06304ceb162d7725474d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga47a2340f9d7e06304ceb162d7725474d">&#9670;&nbsp;</a></span>doca_ec_task_galois_mul_get_dst_buf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> struct doca_buf* doca_ec_task_galois_mul_get_dst_buf </td>
          <td>(</td>
          <td class="paramtype">const struct doca_ec_task_galois_mul *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method gets the destination buffer of a Galois multiplication task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task that should be queried.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The task's dst_buf. </dd></dl>

</div>
</div>
<a id="gaf4cb758f4818eb7d4b289cc45db81b11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf4cb758f4818eb7d4b289cc45db81b11">&#9670;&nbsp;</a></span>doca_ec_task_galois_mul_get_src_buf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> const struct doca_buf* doca_ec_task_galois_mul_get_src_buf </td>
          <td>(</td>
          <td class="paramtype">const struct doca_ec_task_galois_mul *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method gets the source buffer of a Galois multiplication task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task that should be queried.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The task's src_buf. </dd></dl>

</div>
</div>
<a id="ga48ded46b752119ec12c9db6abc47aca5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga48ded46b752119ec12c9db6abc47aca5">&#9670;&nbsp;</a></span>doca_ec_task_galois_mul_set_coding_matrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> void doca_ec_task_galois_mul_set_coding_matrix </td>
          <td>(</td>
          <td class="paramtype">struct doca_ec_task_galois_mul *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct doca_ec_matrix *&#160;</td>
          <td class="paramname"><em>coding_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method sets the coding_matrix of a Galois multiplication task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task to set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coding_matrix</td><td>A coding matrix as it was create by <a class="el" href="group__DOCA__ERASURE__CODING.html#gae64f4716c9a46cdc56a6b504d4790677" title="Generate coding matrix for Erasure Code encode i.e. most basic encode matrix. This is necessary for e...">doca_ec_matrix_create()</a> or <a class="el" href="group__DOCA__ERASURE__CODING.html#ga648f2103f8b81d6f5763d9793c3c2932" title="Create coding matrix for Erasure Code encode i.e. most basic encode matrix from char array....">doca_ec_matrix_create_from_raw()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga55b05932c26c554ad94a8d1ab5ac9b29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga55b05932c26c554ad94a8d1ab5ac9b29">&#9670;&nbsp;</a></span>doca_ec_task_galois_mul_set_conf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_ec_task_galois_mul_set_conf </td>
          <td>(</td>
          <td class="paramtype">struct doca_ec *&#160;</td>
          <td class="paramname"><em>ec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DOCA__ERASURE__CODING.html#gaaf8c38dcf6373d1ad0a90b18a9ad566d">doca_ec_task_galois_mul_completion_cb_t</a>&#160;</td>
          <td class="paramname"><em>successful_task_completion_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DOCA__ERASURE__CODING.html#gaaf8c38dcf6373d1ad0a90b18a9ad566d">doca_ec_task_galois_mul_completion_cb_t</a>&#160;</td>
          <td class="paramname"><em>error_task_completion_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num_tasks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method sets the Galois multiplication tasks configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ec</td><td>The EC instance to config. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">successful_task_completion_cb</td><td>A callback function for Galois multiplication tasks that were completed successfully. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">error_task_completion_cb</td><td>A callback function for Galois multiplication tasks that were completed with an error. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_tasks</td><td>Number of Galois multiplication tasks.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga14574698479b829b244cfb979c4ee286"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga14574698479b829b244cfb979c4ee286">&#9670;&nbsp;</a></span>doca_ec_task_galois_mul_set_dst_buf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> void doca_ec_task_galois_mul_set_dst_buf </td>
          <td>(</td>
          <td class="paramtype">struct doca_ec_task_galois_mul *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct doca_buf *&#160;</td>
          <td class="paramname"><em>dst_buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method sets the destination buffer of a Galois multiplication task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task to set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dst_buf</td><td>Destination data buffer. On successful completion of this task, will hold a sequence containing all multiplication outcome blocks - dst_block_1, dst_block_2 ,...</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The minimal available memory in dst_buf should be in multiplication of block * size. For example, for a given coding matrix that is 10x4 (10 original blocks, 4 redundancy blocks) - dst_buf available memory should be at least: 4x64KB = 256KB.</dd></dl>
<p>The minimal available memory should also be aligned to 64B and at least 64B. For example: 500B size should be padded to be 512B at the least. </p>

</div>
</div>
<a id="gaa4207bf1c97acc95cb5defed43b4f6bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa4207bf1c97acc95cb5defed43b4f6bb">&#9670;&nbsp;</a></span>doca_ec_task_galois_mul_set_src_buf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> void doca_ec_task_galois_mul_set_src_buf </td>
          <td>(</td>
          <td class="paramtype">struct doca_ec_task_galois_mul *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct doca_buf *&#160;</td>
          <td class="paramname"><em>src_buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method sets the source buffer of a Galois multiplication task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task to set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src_buf</td><td>A source buffer with data - A sequence containing all original data blocks - block_1, block_2 ,...</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The data length of src_buf should be in multiplication of block size. For example, for a given coding matrix that is 10x4 (10 original blocks, 4 redundancy blocks) - src_buf data length should be: 10x64KB = 640KB.</dd></dl>
<p>The data length should also be aligned to 64B and with a minimum size of 64B. For example: 500B size should be padded to be 512B. </p>

</div>
</div>
<a id="ga7b359de3f06b475fe8dbbd69f4a8951a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b359de3f06b475fe8dbbd69f4a8951a">&#9670;&nbsp;</a></span>doca_ec_task_recover_allocate_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_ec_task_recover_allocate_init </td>
          <td>(</td>
          <td class="paramtype">struct doca_ec *&#160;</td>
          <td class="paramname"><em>ec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct doca_ec_matrix *&#160;</td>
          <td class="paramname"><em>recover_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct doca_buf *&#160;</td>
          <td class="paramname"><em>available_blocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct doca_buf *&#160;</td>
          <td class="paramname"><em>recovered_data_blocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">union <a class="el" href="uniondoca__data.html">doca_data</a>&#160;</td>
          <td class="paramname"><em>user_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct doca_ec_task_recover **&#160;</td>
          <td class="paramname"><em>task</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method allocates and initializes a recover task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ec</td><td>The EC instance to allocate the task for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">recover_matrix</td><td>The recover coding matrix as it was created by <a class="el" href="group__DOCA__ERASURE__CODING.html#gae32dab279d4e627cede8ea09baa8b52e" title="Generate coding matrix for Erasure Code recovery from failure. To use this function must call doca_ec...">doca_ec_matrix_create_recover()</a> or <a class="el" href="group__DOCA__ERASURE__CODING.html#ga648f2103f8b81d6f5763d9793c3c2932" title="Create coding matrix for Erasure Code encode i.e. most basic encode matrix from char array....">doca_ec_matrix_create_from_raw()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">available_blocks</td><td>A source buffer with data - A sequence containing available data blocks and redundancy blocks - data_block_a, data_block_b, data_block_c ,... ,rdnc_block_x, rdnc_block_y ,... The total number of blocks given in this buffer should be equal to the original number data blocks. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">recovered_data_blocks</td><td>A destination buffer for the recovered data blocks. On successful completion of this task, will hold a sequence containing all the recovered data blocks - data_block_i, data_block_j ,... </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user_data</td><td><a class="el" href="uniondoca__data.html" title="Convenience type for representing opaque data.">doca_data</a> to attach to the task. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">task</td><td>On success, an allocated and initialized recover task.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The data length of available_blocks and the minimal available memory in recovered_data_blocks should be in multiplication of block size. For example, for a given recover_matrix based on an original 10x4 coding matrix (10 original blocks, 4 redundancy blocks) - 10 available blocks should be given in total (for example 7 data blocks and 3 redundancy blocks) and available_blocks data length should be: 10x64KB = 640KB. recovered_data_blocks minimal available memory should be according to the amount of missing data blocks: in this example, 3x64KB = 192KB.</dd></dl>
<p>They also should be aligned to 64B and with a minimum size of 64B. For example: 500B size should be padded to be 512B.</p>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input.</li>
<li>DOCA_ERROR_NO_MEMORY - no more tasks to allocate. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaa45db7f46348df0b7b04ebc815803e9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa45db7f46348df0b7b04ebc815803e9f">&#9670;&nbsp;</a></span>doca_ec_task_recover_as_task()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> struct doca_task* doca_ec_task_recover_as_task </td>
          <td>(</td>
          <td class="paramtype">struct doca_ec_task_recover *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method converts an EC recover task to a doca_task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task that should be converted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>doca_task </dd></dl>

</div>
</div>
<a id="ga3fe41b34a9e0ffb3425a9cb7ee683b29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3fe41b34a9e0ffb3425a9cb7ee683b29">&#9670;&nbsp;</a></span>doca_ec_task_recover_get_available_blocks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> const struct doca_buf* doca_ec_task_recover_get_available_blocks </td>
          <td>(</td>
          <td class="paramtype">const struct doca_ec_task_recover *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method gets the available_blocks buffer of a recover task. The available_blocks buffer is a source buffer with data - A sequence containing all available data blocks and redundancy blocks - data_block_a, data_block_b, data_block_c ,... ,rdnc_block_x, rdnc_block_y ,... </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task that should be queried.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The task's available_blocks buffer. </dd></dl>

</div>
</div>
<a id="gafcf8ec321b660a4a5f70898fb347e99e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafcf8ec321b660a4a5f70898fb347e99e">&#9670;&nbsp;</a></span>doca_ec_task_recover_get_recover_matrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> const struct doca_ec_matrix* doca_ec_task_recover_get_recover_matrix </td>
          <td>(</td>
          <td class="paramtype">const struct doca_ec_task_recover *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method gets the recover_matrix of a recover task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task that should be queried.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The task's recover_matrix. </dd></dl>

</div>
</div>
<a id="ga40ca28764100eaf179d34d5fb3ae1c77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga40ca28764100eaf179d34d5fb3ae1c77">&#9670;&nbsp;</a></span>doca_ec_task_recover_get_recovered_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> struct doca_buf* doca_ec_task_recover_get_recovered_data </td>
          <td>(</td>
          <td class="paramtype">const struct doca_ec_task_recover *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method gets the recovered_data buffer of a recover task. The recovered_data buffer is a destination buffer for the recovered data blocks. On successful completion of this task, will hold a sequence containing all the recovered data blocks - data_block_i, data_block_j ,... </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task that should be queried.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The task's recovered_data buffer. </dd></dl>

</div>
</div>
<a id="ga106b3198b8cbdde3a229b0ed160daf2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga106b3198b8cbdde3a229b0ed160daf2c">&#9670;&nbsp;</a></span>doca_ec_task_recover_set_available_blocks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> void doca_ec_task_recover_set_available_blocks </td>
          <td>(</td>
          <td class="paramtype">struct doca_ec_task_recover *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct doca_buf *&#160;</td>
          <td class="paramname"><em>available_blocks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method sets the available_blocks buffer of a recover task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task to set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">available_blocks</td><td>A source buffer with data - A sequence containing available data blocks and redundancy blocks - data_block_a, data_block_b, data_block_c ,... ,rdnc_block_x, rdnc_block_y ,... The total number of blocks given in this buffer should be equal to the original number data blocks.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The data length of available_blocks should be in multiplication of block size. For example, for a given recover_matrix based on an original 10x4 coding matrix (10 original blocks, 4 redundancy blocks) - 10 available blocks should be given in total (i data blocks and j redundancy blocks) and available_blocks data length should be: 10x64KB = 640KB.</dd></dl>
<p>The data length should also be aligned to 64B and with a minimum size of 64B. For example: 500B size should be padded to be 512B. </p>

</div>
</div>
<a id="gaa5457642a348fd934016165bc1f8f14b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa5457642a348fd934016165bc1f8f14b">&#9670;&nbsp;</a></span>doca_ec_task_recover_set_conf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_ec_task_recover_set_conf </td>
          <td>(</td>
          <td class="paramtype">struct doca_ec *&#160;</td>
          <td class="paramname"><em>ec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DOCA__ERASURE__CODING.html#ga2563dc71fb7e17bf9071166f552fe6d3">doca_ec_task_recover_completion_cb_t</a>&#160;</td>
          <td class="paramname"><em>successful_task_completion_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DOCA__ERASURE__CODING.html#ga2563dc71fb7e17bf9071166f552fe6d3">doca_ec_task_recover_completion_cb_t</a>&#160;</td>
          <td class="paramname"><em>error_task_completion_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num_tasks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method sets the recover tasks configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ec</td><td>The EC instance to config. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">successful_task_completion_cb</td><td>A callback function for recover tasks that were completed successfully. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">error_task_completion_cb</td><td>A callback function for recover tasks that were completed with an error. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_tasks</td><td>Number of recover tasks.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaa11f062d125cf8965518ec71b39c3558"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa11f062d125cf8965518ec71b39c3558">&#9670;&nbsp;</a></span>doca_ec_task_recover_set_recover_matrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> void doca_ec_task_recover_set_recover_matrix </td>
          <td>(</td>
          <td class="paramtype">struct doca_ec_task_recover *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct doca_ec_matrix *&#160;</td>
          <td class="paramname"><em>recover_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method sets the recover_matrix of a recover task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task to set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">recover_matrix</td><td>The recover coding matrix as it was created by <a class="el" href="group__DOCA__ERASURE__CODING.html#gae32dab279d4e627cede8ea09baa8b52e" title="Generate coding matrix for Erasure Code recovery from failure. To use this function must call doca_ec...">doca_ec_matrix_create_recover()</a> or <a class="el" href="group__DOCA__ERASURE__CODING.html#ga648f2103f8b81d6f5763d9793c3c2932" title="Create coding matrix for Erasure Code encode i.e. most basic encode matrix from char array....">doca_ec_matrix_create_from_raw()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae6dcb622b9270fc9932cd7a77a21cc27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae6dcb622b9270fc9932cd7a77a21cc27">&#9670;&nbsp;</a></span>doca_ec_task_recover_set_recovered_data_blocks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> void doca_ec_task_recover_set_recovered_data_blocks </td>
          <td>(</td>
          <td class="paramtype">struct doca_ec_task_recover *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct doca_buf *&#160;</td>
          <td class="paramname"><em>recovered_data_blocks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method sets the recovered_data_blocks buffer of a recover task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task to set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">recovered_data_blocks</td><td>A destination buffer for the recovered data blocks. On successful completion of this task, will hold a sequence containing all the recovered data blocks - data_block_i, data_block_j ,...</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The minimal available memory in recovered_data_blocks should be in multiplication of block size. For example, for a given recover_matrix based on an original 10x4 coding matrix (10 original blocks, 4 redundancy blocks), in which 3 data blocks need to be recovered - recovered_data_blocks minimal available memory should be according to the amount of missing data blocks: in this example, 3x64KB = 192KB.</dd></dl>
<p>The minimal available memory should also be aligned to 64B and at least 64B. For example: 500B size should be padded to be 512B at the least. </p>

</div>
</div>
<a id="ga0a0a2f0dae8ae31d86d6fbd89be89827"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a0a2f0dae8ae31d86d6fbd89be89827">&#9670;&nbsp;</a></span>doca_ec_task_update_allocate_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_ec_task_update_allocate_init </td>
          <td>(</td>
          <td class="paramtype">struct doca_ec *&#160;</td>
          <td class="paramname"><em>ec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct doca_ec_matrix *&#160;</td>
          <td class="paramname"><em>update_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct doca_buf *&#160;</td>
          <td class="paramname"><em>original_updated_and_rdnc_blocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct doca_buf *&#160;</td>
          <td class="paramname"><em>updated_rdnc_blocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">union <a class="el" href="uniondoca__data.html">doca_data</a>&#160;</td>
          <td class="paramname"><em>user_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct doca_ec_task_update **&#160;</td>
          <td class="paramname"><em>task</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method allocates and initializes an update task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ec</td><td>The EC instance to allocate the task for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">update_matrix</td><td>The update coding matrix as it was created by <a class="el" href="group__DOCA__ERASURE__CODING.html#ga946acc8bf43bd69bb2a8b48daec9c0e4" title="Generate coding matrix for Erasure Code update. To use this function must call doca_ec_matrix_create(...">doca_ec_matrix_create_update()</a> or <a class="el" href="group__DOCA__ERASURE__CODING.html#ga648f2103f8b81d6f5763d9793c3c2932" title="Create coding matrix for Erasure Code encode i.e. most basic encode matrix from char array....">doca_ec_matrix_create_from_raw()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">original_updated_and_rdnc_blocks</td><td>A source buffer with data - A sequence containing the original data block and it's updated data block, for each block that was updated, followed by the old redundancy blocks - old_data_block_i, updated_data_block_i, old_data_block_j, updated_data_block_j ,... ,rdnc_block_1, rdnc_block_2 ,... </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">updated_rdnc_blocks</td><td>A destination buffer for the updated redundancy blocks. On successful completion of this task, will hold a sequence containing all updated redundancy blocks - rdnc_block_1, rdnc_block_2 ,... </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user_data</td><td><a class="el" href="uniondoca__data.html" title="Convenience type for representing opaque data.">doca_data</a> to attach to the task. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">task</td><td>On success, an allocated and initialized update task.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The data length of original_updated_and_rdnc_blocks and the minimal available memory in updated_rdnc_blocks should be in multiplication of block size. For example, for a given update_matrix that has 4 redundancy blocks, in which 3 data block were updated - original_updated_and_rdnc_blocks data length should be: (3+3+4=10)x64KB = 640KB. (3 original data blocks and their updated data block, and 4 redundancy blocks). updated_rdnc_blocks available memory should be at least: 4x64KB = 256KB.</dd></dl>
<p>They also should be aligned to 64B and with a minimum size of 64B. For example: 500B size should be padded to be 512B.</p>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input.</li>
<li>DOCA_ERROR_NO_MEMORY - no more tasks to allocate. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gacfa941153da0cba1b978055c08e5e168"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacfa941153da0cba1b978055c08e5e168">&#9670;&nbsp;</a></span>doca_ec_task_update_as_task()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> struct doca_task* doca_ec_task_update_as_task </td>
          <td>(</td>
          <td class="paramtype">struct doca_ec_task_update *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method converts an EC update task to a doca_task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task that should be converted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>doca_task </dd></dl>

</div>
</div>
<a id="ga6b5d6cccbcfeb91978c9aaf8bfb54ca5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b5d6cccbcfeb91978c9aaf8bfb54ca5">&#9670;&nbsp;</a></span>doca_ec_task_update_get_original_updated_and_rdnc_blocks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> const struct doca_buf* doca_ec_task_update_get_original_updated_and_rdnc_blocks </td>
          <td>(</td>
          <td class="paramtype">const struct doca_ec_task_update *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method gets the original_updated_and_rdnc_blocks buffer of an update task. The original_data_blocks buffer is a source buffer with data - A sequence containing the original data block and it's updated data block, for each block that was updated, followed by the old redundancy blocks - old_data_block_i, updated_data_block_i, old_data_block_j, updated_data_block_j ,... ,rdnc_block_1, rdnc_block_2 ,... </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task that should be queried.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The task's original_updated_and_rdnc_blocks buffer. </dd></dl>

</div>
</div>
<a id="ga34cbf57214f2d837ade26bde430a3090"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga34cbf57214f2d837ade26bde430a3090">&#9670;&nbsp;</a></span>doca_ec_task_update_get_update_matrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> const struct doca_ec_matrix* doca_ec_task_update_get_update_matrix </td>
          <td>(</td>
          <td class="paramtype">const struct doca_ec_task_update *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method gets the update_matrix of an update task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task that should be queried.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The task's update_matrix. </dd></dl>

</div>
</div>
<a id="ga1dfcb729efebd5b6d5aa660ea90658d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1dfcb729efebd5b6d5aa660ea90658d3">&#9670;&nbsp;</a></span>doca_ec_task_update_get_updated_rdnc_blocks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> struct doca_buf* doca_ec_task_update_get_updated_rdnc_blocks </td>
          <td>(</td>
          <td class="paramtype">const struct doca_ec_task_update *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method gets the updated_rdnc_blocks buffer of an update task. The rdnc_blocks buffer is a destination buffer for the redundancy blocks. On successful completion of this task, will hold a sequence containing all redundancy blocks - rdnc_block_1, rdnc_block_2 ,... </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task that should be queried.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The task's updated_rdnc_blocks buffer. </dd></dl>

</div>
</div>
<a id="ga86aab51db72ad8c3ad1023acfa06a354"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga86aab51db72ad8c3ad1023acfa06a354">&#9670;&nbsp;</a></span>doca_ec_task_update_set_conf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_ec_task_update_set_conf </td>
          <td>(</td>
          <td class="paramtype">struct doca_ec *&#160;</td>
          <td class="paramname"><em>ec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DOCA__ERASURE__CODING.html#gaabc6520e67af390486ee5709eb26bf06">doca_ec_task_update_completion_cb_t</a>&#160;</td>
          <td class="paramname"><em>successful_task_completion_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DOCA__ERASURE__CODING.html#gaabc6520e67af390486ee5709eb26bf06">doca_ec_task_update_completion_cb_t</a>&#160;</td>
          <td class="paramname"><em>error_task_completion_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num_tasks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method sets the update tasks configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ec</td><td>The EC instance to config. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">successful_task_completion_cb</td><td>A callback function for update tasks that were completed successfully. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">error_task_completion_cb</td><td>A callback function for update tasks that were completed with an error. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_tasks</td><td>Number of update tasks.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga69d7c3134957a0cd35bb7ca9561bae37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga69d7c3134957a0cd35bb7ca9561bae37">&#9670;&nbsp;</a></span>doca_ec_task_update_set_original_updated_and_rdnc_blocks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> void doca_ec_task_update_set_original_updated_and_rdnc_blocks </td>
          <td>(</td>
          <td class="paramtype">struct doca_ec_task_update *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct doca_buf *&#160;</td>
          <td class="paramname"><em>original_updated_and_rdnc_blocks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method sets the original_updated_and_rdnc_blocks buffer of an update task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task to set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">original_updated_and_rdnc_blocks</td><td>A source buffer with data - A sequence containing the original data block and it's updated data block, for each block that was updated, followed by the old redundancy blocks - old_data_block_i, updated_data_block_i, old_data_block_j, updated_data_block_j ,... ,rdnc_block_1, rdnc_block_2 ,...</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The data length of original_updated_and_rdnc_blocks should be in multiplication of block size. For example, for a given update_matrix that has 4 redundancy blocks, in which 3 data block were updated - original_updated_and_rdnc_blocks data length should be: (3+3+4=10)x64KB = 640KB. (3 original data blocks and their updated data block, and 4 redundancy blocks).</dd></dl>
<p>The data length should also be aligned to 64B and with a minimum size of 64B. For example: 500B size should be padded to be 512B. </p>

</div>
</div>
<a id="gaec35da8aa8f23fb6d38b9ea2bf26a362"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec35da8aa8f23fb6d38b9ea2bf26a362">&#9670;&nbsp;</a></span>doca_ec_task_update_set_update_matrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> void doca_ec_task_update_set_update_matrix </td>
          <td>(</td>
          <td class="paramtype">struct doca_ec_task_update *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct doca_ec_matrix *&#160;</td>
          <td class="paramname"><em>update_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method sets the update_matrix of an update task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task to set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">update_matrix</td><td>The update coding matrix as it was created by <a class="el" href="group__DOCA__ERASURE__CODING.html#ga946acc8bf43bd69bb2a8b48daec9c0e4" title="Generate coding matrix for Erasure Code update. To use this function must call doca_ec_matrix_create(...">doca_ec_matrix_create_update()</a> or <a class="el" href="group__DOCA__ERASURE__CODING.html#ga648f2103f8b81d6f5763d9793c3c2932" title="Create coding matrix for Erasure Code encode i.e. most basic encode matrix from char array....">doca_ec_matrix_create_from_raw()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae7df8b462bbf4b33fa14283d1b382605"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae7df8b462bbf4b33fa14283d1b382605">&#9670;&nbsp;</a></span>doca_ec_task_update_set_updated_rdnc_blocks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> void doca_ec_task_update_set_updated_rdnc_blocks </td>
          <td>(</td>
          <td class="paramtype">struct doca_ec_task_update *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct doca_buf *&#160;</td>
          <td class="paramname"><em>updated_rdnc_blocks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method sets the updated_rdnc_blocks buffer of an update task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task to set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">updated_rdnc_blocks</td><td>A destination buffer for the updated redundancy blocks. On successful completion of this task, will hold a sequence containing all updated redundancy blocks - rdnc_block_1, rdnc_block_2 ,...</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The minimal available memory in updated_rdnc_blocks should be in multiplication of block size. For example, for a given update_matrix that has 4 redundancy blocks, in which 3 data block were updated - updated_rdnc_blocks available memory should be at least: 4x64KB = 256KB.</dd></dl>
<p>The minimal available memory should also be aligned to 64B and at least 64B. For example: 500B size should be padded to be 512B at the least. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Wed Aug 13 2025 09:23:37 for NVIDIA DOCA SDK by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
