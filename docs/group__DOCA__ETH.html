<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NVIDIA DOCA SDK: DOCA ETH</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<!-- Doxygen Awesome CSS -->
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript">
DoxygenAwesomeDarkModeToggle.init()
DoxygenAwesomeFragmentCopyButton.init()
DoxygenAwesomeParagraphLink.init()
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectname">NVIDIA DOCA SDK
  </td>
  <td id="projectbrief">Data Center on a Chip Framework Documentation</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__DOCA__ETH.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">DOCA ETH</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for DOCA ETH:</div>
<div class="dyncontent">
<div class="center"><img src="group__DOCA__ETH.png" border="0" usemap="#agroup____DOCA____ETH" alt=""/></div>
<map name="agroup____DOCA____ETH" id="agroup____DOCA____ETH">
<area shape="rect" href="group__DOCA__ETH__TXQ.html" title=" " alt="" coords="145,5,266,31"/>
<area shape="rect" title=" " alt="" coords="5,31,96,56"/>
<area shape="rect" href="group__DOCA__ETH__RXQ.html" title=" " alt="" coords="144,55,267,80"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__DOCA__ETH__RXQ"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ETH__RXQ.html">DOCA ETH RXQ</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__DOCA__ETH__TXQ"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ETH__TXQ.html">DOCA ETH TXQ</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga0aeb6e81bb2aeb9de36b67d90e0934d4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ETH.html#ga0aeb6e81bb2aeb9de36b67d90e0934d4">doca_eth_rxq_type</a> { <a class="el" href="group__DOCA__ETH.html#gga0aeb6e81bb2aeb9de36b67d90e0934d4a578e9279409a45e19ddd79fbf7d17ba6">DOCA_ETH_RXQ_TYPE_CYCLIC</a> = 0
, <a class="el" href="group__DOCA__ETH.html#gga0aeb6e81bb2aeb9de36b67d90e0934d4a56bc55361d9eda5077f2d2be5fa23a53">DOCA_ETH_RXQ_TYPE_MANAGED_MEMPOOL</a>
, <a class="el" href="group__DOCA__ETH.html#gga0aeb6e81bb2aeb9de36b67d90e0934d4aee37cffce9715e8b235ebe37fc744cd6">DOCA_ETH_RXQ_TYPE_REGULAR</a>
 }</td></tr>
<tr class="separator:ga0aeb6e81bb2aeb9de36b67d90e0934d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd255c9ac16a9c7b410661e2d684a7a5"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ETH.html#gadd255c9ac16a9c7b410661e2d684a7a5">doca_eth_rxq_data_path_type</a> { <a class="el" href="group__DOCA__ETH.html#ggadd255c9ac16a9c7b410661e2d684a7a5a13fbfd0afde509977ced48832f81c458">DOCA_ETH_RXQ_DATA_PATH_TYPE_CPU</a> = 0
, <a class="el" href="group__DOCA__ETH.html#ggadd255c9ac16a9c7b410661e2d684a7a5a68a8fc138d9a6145beaa9d9a6eb9dc77">DOCA_ETH_RXQ_DATA_PATH_TYPE_GPU</a>
 }</td></tr>
<tr class="separator:gadd255c9ac16a9c7b410661e2d684a7a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gab0137b30a8fdd981c783ad037bedfa64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ETH.html#gab0137b30a8fdd981c783ad037bedfa64">doca_eth_rxq_create</a> (struct doca_dev *dev, uint32_t max_burst_size, uint32_t max_packet_size, struct doca_eth_rxq **eth_rxq)</td></tr>
<tr class="memdesc:gab0137b30a8fdd981c783ad037bedfa64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a DOCA ETH RXQ instance.  <a href="group__DOCA__ETH.html#gab0137b30a8fdd981c783ad037bedfa64">More...</a><br /></td></tr>
<tr class="separator:gab0137b30a8fdd981c783ad037bedfa64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e604bf995cfe9f376caffe9a1c9ae4c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ETH.html#ga5e604bf995cfe9f376caffe9a1c9ae4c">doca_eth_rxq_destroy</a> (struct doca_eth_rxq *eth_rxq)</td></tr>
<tr class="memdesc:ga5e604bf995cfe9f376caffe9a1c9ae4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a DOCA ETH RXQ instance.  <a href="group__DOCA__ETH.html#ga5e604bf995cfe9f376caffe9a1c9ae4c">More...</a><br /></td></tr>
<tr class="separator:ga5e604bf995cfe9f376caffe9a1c9ae4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92a26bb9e28dfe46ba69a71155cf1829"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> struct doca_ctx *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ETH.html#ga92a26bb9e28dfe46ba69a71155cf1829">doca_eth_rxq_as_doca_ctx</a> (struct doca_eth_rxq *eth_rxq)</td></tr>
<tr class="memdesc:ga92a26bb9e28dfe46ba69a71155cf1829"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert doca_eth_rxq instance into a generalized context for use with doca core objects.  <a href="group__DOCA__ETH.html#ga92a26bb9e28dfe46ba69a71155cf1829">More...</a><br /></td></tr>
<tr class="separator:ga92a26bb9e28dfe46ba69a71155cf1829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ba098a142ee5dcdb67d27788fef5400"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ETH.html#ga3ba098a142ee5dcdb67d27788fef5400">doca_eth_rxq_set_max_burst_size</a> (struct doca_eth_rxq *eth_rxq, uint32_t max_burst_size)</td></tr>
<tr class="memdesc:ga3ba098a142ee5dcdb67d27788fef5400"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set max burst size property for doca_eth_rxq. This value dictates the maximal number of packets the HW can handle at the same time. can only be called before calling <a class="el" href="group__DOCA__CTX.html#ga712a2c32ab9113f568d08c379ec506f7" title="Finalizes all configurations, and starts the DOCA CTX.">doca_ctx_start()</a>.  <a href="group__DOCA__ETH.html#ga3ba098a142ee5dcdb67d27788fef5400">More...</a><br /></td></tr>
<tr class="separator:ga3ba098a142ee5dcdb67d27788fef5400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabae4d6515ceae5184c62c5954ea54c7b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ETH.html#gabae4d6515ceae5184c62c5954ea54c7b">doca_eth_rxq_set_max_packet_size</a> (struct doca_eth_rxq *eth_rxq, uint32_t max_packet_size)</td></tr>
<tr class="memdesc:gabae4d6515ceae5184c62c5954ea54c7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set max packet size property for doca_eth_rxq. can only be called before calling <a class="el" href="group__DOCA__CTX.html#ga712a2c32ab9113f568d08c379ec506f7" title="Finalizes all configurations, and starts the DOCA CTX.">doca_ctx_start()</a>.  <a href="group__DOCA__ETH.html#gabae4d6515ceae5184c62c5954ea54c7b">More...</a><br /></td></tr>
<tr class="separator:gabae4d6515ceae5184c62c5954ea54c7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae478592c3c7d15ad3c1ec470805fdc3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ETH.html#gae478592c3c7d15ad3c1ec470805fdc3d">doca_eth_rxq_set_metadata_num</a> (struct doca_eth_rxq *eth_rxq, uint8_t metadata_num)</td></tr>
<tr class="memdesc:gae478592c3c7d15ad3c1ec470805fdc3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set metadata number for doca_eth_rxq. can only be called before calling <a class="el" href="group__DOCA__CTX.html#ga712a2c32ab9113f568d08c379ec506f7" title="Finalizes all configurations, and starts the DOCA CTX.">doca_ctx_start()</a>.  <a href="group__DOCA__ETH.html#gae478592c3c7d15ad3c1ec470805fdc3d">More...</a><br /></td></tr>
<tr class="separator:gae478592c3c7d15ad3c1ec470805fdc3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e4193716cf95d66cd7215a0b6e7784e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ETH.html#ga0e4193716cf95d66cd7215a0b6e7784e">doca_eth_rxq_set_flow_tag</a> (struct doca_eth_rxq *eth_rxq, uint8_t enable_flow_tag)</td></tr>
<tr class="memdesc:ga0e4193716cf95d66cd7215a0b6e7784e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setter to enable flow tag support. User can retrieve flow tag per packet when this is enabled. can only be called before calling <a class="el" href="group__DOCA__CTX.html#ga712a2c32ab9113f568d08c379ec506f7" title="Finalizes all configurations, and starts the DOCA CTX.">doca_ctx_start()</a>.  <a href="group__DOCA__ETH.html#ga0e4193716cf95d66cd7215a0b6e7784e">More...</a><br /></td></tr>
<tr class="separator:ga0e4193716cf95d66cd7215a0b6e7784e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae66fc9ed99ac00173b168675a7fef942"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ETH.html#gae66fc9ed99ac00173b168675a7fef942">doca_eth_rxq_set_rx_hash</a> (struct doca_eth_rxq *eth_rxq, uint8_t enable_rx_hash)</td></tr>
<tr class="memdesc:gae66fc9ed99ac00173b168675a7fef942"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setter to enable RX hash support. User can retrieve RX hash per packet when this is enabled. can only be called before calling <a class="el" href="group__DOCA__CTX.html#ga712a2c32ab9113f568d08c379ec506f7" title="Finalizes all configurations, and starts the DOCA CTX.">doca_ctx_start()</a>.  <a href="group__DOCA__ETH.html#gae66fc9ed99ac00173b168675a7fef942">More...</a><br /></td></tr>
<tr class="separator:gae66fc9ed99ac00173b168675a7fef942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73034701d5cf97694ba9277acc46fc7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ETH.html#ga73034701d5cf97694ba9277acc46fc7a">doca_eth_rxq_set_packet_headroom</a> (struct doca_eth_rxq *eth_rxq, uint16_t head_size)</td></tr>
<tr class="memdesc:ga73034701d5cf97694ba9277acc46fc7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setter to enable packet headroom support. User can use doca_buf's headroom of size head_size when this is enabled. can only be called before calling <a class="el" href="group__DOCA__CTX.html#ga712a2c32ab9113f568d08c379ec506f7" title="Finalizes all configurations, and starts the DOCA CTX.">doca_ctx_start()</a>.  <a href="group__DOCA__ETH.html#ga73034701d5cf97694ba9277acc46fc7a">More...</a><br /></td></tr>
<tr class="separator:ga73034701d5cf97694ba9277acc46fc7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22be294e4d7c2af2d42c52348f1ca173"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ETH.html#ga22be294e4d7c2af2d42c52348f1ca173">doca_eth_rxq_set_packet_tailroom</a> (struct doca_eth_rxq *eth_rxq, uint16_t tail_size)</td></tr>
<tr class="memdesc:ga22be294e4d7c2af2d42c52348f1ca173"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setter to enable packet tailroom support. User can use doca_buf's tailroom of size tail_size when this is enabled. can only be called before calling <a class="el" href="group__DOCA__CTX.html#ga712a2c32ab9113f568d08c379ec506f7" title="Finalizes all configurations, and starts the DOCA CTX.">doca_ctx_start()</a>.  <a href="group__DOCA__ETH.html#ga22be294e4d7c2af2d42c52348f1ca173">More...</a><br /></td></tr>
<tr class="separator:ga22be294e4d7c2af2d42c52348f1ca173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f55fac5c0c411b59f2ffe6530bfa036"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ETH.html#ga7f55fac5c0c411b59f2ffe6530bfa036">doca_eth_rxq_set_timestamp</a> (struct doca_eth_rxq *eth_rxq, uint8_t enable_timestamp)</td></tr>
<tr class="memdesc:ga7f55fac5c0c411b59f2ffe6530bfa036"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setter to enable timestamp support. User can retrieve timestamp in nanoseconds per packet when this is enabled. can only be called before calling <a class="el" href="group__DOCA__CTX.html#ga712a2c32ab9113f568d08c379ec506f7" title="Finalizes all configurations, and starts the DOCA CTX.">doca_ctx_start()</a>.  <a href="group__DOCA__ETH.html#ga7f55fac5c0c411b59f2ffe6530bfa036">More...</a><br /></td></tr>
<tr class="separator:ga7f55fac5c0c411b59f2ffe6530bfa036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9cfbba8358fc2b3f65c62fdde5970984"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ETH.html#ga9cfbba8358fc2b3f65c62fdde5970984">doca_eth_rxq_set_max_recv_buf_list_len</a> (struct doca_eth_rxq *eth_rxq, uint32_t max_recv_buf_list_len)</td></tr>
<tr class="memdesc:ga9cfbba8358fc2b3f65c62fdde5970984"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the maximal receive buffer list length for doca_eth_rxq. This value indicated what the maximal number of elements in a doca_buf list is. can only be called before calling <a class="el" href="group__DOCA__CTX.html#ga712a2c32ab9113f568d08c379ec506f7" title="Finalizes all configurations, and starts the DOCA CTX.">doca_ctx_start()</a>.  <a href="group__DOCA__ETH.html#ga9cfbba8358fc2b3f65c62fdde5970984">More...</a><br /></td></tr>
<tr class="separator:ga9cfbba8358fc2b3f65c62fdde5970984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab38fc69755b84bd45454b54b2d9be59c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ETH.html#gab38fc69755b84bd45454b54b2d9be59c">doca_eth_rxq_set_pkt_buf</a> (struct doca_eth_rxq *eth_rxq, struct doca_mmap *<a class="el" href="doca__dpa__dev__buf_8h.html#aa921b3af6cadd5d8828e2f7251f1c6a3">mmap</a>, uint32_t mmap_offset, uint32_t mmap_len)</td></tr>
<tr class="memdesc:gab38fc69755b84bd45454b54b2d9be59c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set Eth packet buffer for a doca_eth_rxq. can only be called before calling <a class="el" href="group__DOCA__CTX.html#ga712a2c32ab9113f568d08c379ec506f7" title="Finalizes all configurations, and starts the DOCA CTX.">doca_ctx_start()</a>.  <a href="group__DOCA__ETH.html#gab38fc69755b84bd45454b54b2d9be59c">More...</a><br /></td></tr>
<tr class="separator:gab38fc69755b84bd45454b54b2d9be59c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga444cd8f8338d0b789e6da4f4001f3e07"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ETH.html#ga444cd8f8338d0b789e6da4f4001f3e07">doca_eth_rxq_set_type</a> (struct doca_eth_rxq *eth_rxq, enum <a class="el" href="group__DOCA__ETH.html#ga0aeb6e81bb2aeb9de36b67d90e0934d4">doca_eth_rxq_type</a> <a class="el" href="upf__accel_8h.html#a5f649fbc43a239b31af8e53c8b76b756">type</a>)</td></tr>
<tr class="memdesc:ga444cd8f8338d0b789e6da4f4001f3e07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set RX queue type property for doca_eth_rxq. can only be called before calling <a class="el" href="group__DOCA__CTX.html#ga712a2c32ab9113f568d08c379ec506f7" title="Finalizes all configurations, and starts the DOCA CTX.">doca_ctx_start()</a>.  <a href="group__DOCA__ETH.html#ga444cd8f8338d0b789e6da4f4001f3e07">More...</a><br /></td></tr>
<tr class="separator:ga444cd8f8338d0b789e6da4f4001f3e07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab126e192a7453d829d2701c43627b7d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ETH.html#gab126e192a7453d829d2701c43627b7d9">doca_eth_rxq_set_notification_moderation</a> (struct doca_eth_rxq *eth_rxq, uint16_t period_usec, uint16_t comp_count)</td></tr>
<tr class="memdesc:gab126e192a7453d829d2701c43627b7d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set notification moderation.  <a href="group__DOCA__ETH.html#gab126e192a7453d829d2701c43627b7d9">More...</a><br /></td></tr>
<tr class="separator:gab126e192a7453d829d2701c43627b7d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fad4686dba9a4d57b693b09733fa552"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ETH.html#ga0fad4686dba9a4d57b693b09733fa552">doca_eth_rxq_get_flow_queue_id</a> (struct doca_eth_rxq *eth_rxq, uint16_t *flow_queue_id)</td></tr>
<tr class="memdesc:ga0fad4686dba9a4d57b693b09733fa552"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the DPDK queue ID of the doca_eth receive queue. can only be called after calling <a class="el" href="group__DOCA__CTX.html#ga712a2c32ab9113f568d08c379ec506f7" title="Finalizes all configurations, and starts the DOCA CTX.">doca_ctx_start()</a>.  <a href="group__DOCA__ETH.html#ga0fad4686dba9a4d57b693b09733fa552">More...</a><br /></td></tr>
<tr class="separator:ga0fad4686dba9a4d57b693b09733fa552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga634d5a251407fb2bc7f341fbb89b3236"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ETH.html#ga634d5a251407fb2bc7f341fbb89b3236">doca_eth_rxq_get_gpu_handle</a> (const struct doca_eth_rxq *eth_rxq, struct doca_gpu_eth_rxq **eth_rxq_ext)</td></tr>
<tr class="memdesc:ga634d5a251407fb2bc7f341fbb89b3236"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a gpu handle of a doca_eth_rxq.  <a href="group__DOCA__ETH.html#ga634d5a251407fb2bc7f341fbb89b3236">More...</a><br /></td></tr>
<tr class="separator:ga634d5a251407fb2bc7f341fbb89b3236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacdc1f261f7fbd5ce1024d9ccab61d3e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ETH.html#gacdc1f261f7fbd5ce1024d9ccab61d3e7">doca_eth_rxq_cap_get_max_burst_size</a> (const struct doca_devinfo *devinfo, uint32_t *max_burst_size)</td></tr>
<tr class="memdesc:gacdc1f261f7fbd5ce1024d9ccab61d3e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum burst size supported by the device.  <a href="group__DOCA__ETH.html#gacdc1f261f7fbd5ce1024d9ccab61d3e7">More...</a><br /></td></tr>
<tr class="separator:gacdc1f261f7fbd5ce1024d9ccab61d3e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga104d5db37495f6d0ada2d45801512b11"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ETH.html#ga104d5db37495f6d0ada2d45801512b11">doca_eth_rxq_cap_get_max_metadata_num</a> (const struct doca_devinfo *devinfo, uint8_t *max_metadata_num)</td></tr>
<tr class="memdesc:ga104d5db37495f6d0ada2d45801512b11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum metadata number supported by the device.  <a href="group__DOCA__ETH.html#ga104d5db37495f6d0ada2d45801512b11">More...</a><br /></td></tr>
<tr class="separator:ga104d5db37495f6d0ada2d45801512b11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4cacfb42153196bf4ee6dca8e3663521"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ETH.html#ga4cacfb42153196bf4ee6dca8e3663521">doca_eth_rxq_cap_get_max_packet_headroom</a> (const struct doca_devinfo *devinfo, uint16_t *max_packet_headroom)</td></tr>
<tr class="memdesc:ga4cacfb42153196bf4ee6dca8e3663521"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum packet headroom size supported by the device.  <a href="group__DOCA__ETH.html#ga4cacfb42153196bf4ee6dca8e3663521">More...</a><br /></td></tr>
<tr class="separator:ga4cacfb42153196bf4ee6dca8e3663521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b6690ce8ce63cb786de69f5b734522e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ETH.html#ga7b6690ce8ce63cb786de69f5b734522e">doca_eth_rxq_cap_get_max_packet_tailroom</a> (const struct doca_devinfo *devinfo, uint16_t *max_packet_tailroom)</td></tr>
<tr class="memdesc:ga7b6690ce8ce63cb786de69f5b734522e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum packet tailroom size supported by the device.  <a href="group__DOCA__ETH.html#ga7b6690ce8ce63cb786de69f5b734522e">More...</a><br /></td></tr>
<tr class="separator:ga7b6690ce8ce63cb786de69f5b734522e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47a5fea6a89967dc45afb1f960f698c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ETH.html#ga47a5fea6a89967dc45afb1f960f698c9">doca_eth_rxq_cap_get_max_recv_buf_list_len</a> (const struct doca_devinfo *devinfo, uint32_t *max_recv_buf_list_len)</td></tr>
<tr class="memdesc:ga47a5fea6a89967dc45afb1f960f698c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum receive buffer list length supported by the device.  <a href="group__DOCA__ETH.html#ga47a5fea6a89967dc45afb1f960f698c9">More...</a><br /></td></tr>
<tr class="separator:ga47a5fea6a89967dc45afb1f960f698c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d4c4afa279adcf6c9a802a9a4a0d857"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ETH.html#ga9d4c4afa279adcf6c9a802a9a4a0d857">doca_eth_rxq_cap_get_max_packet_size</a> (const struct doca_devinfo *devinfo, uint32_t *max_packet_size)</td></tr>
<tr class="memdesc:ga9d4c4afa279adcf6c9a802a9a4a0d857"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum packet size supported by the device.  <a href="group__DOCA__ETH.html#ga9d4c4afa279adcf6c9a802a9a4a0d857">More...</a><br /></td></tr>
<tr class="separator:ga9d4c4afa279adcf6c9a802a9a4a0d857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8252c90087ba4740bc339cd14ef25212"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ETH.html#ga8252c90087ba4740bc339cd14ef25212">doca_eth_rxq_cap_is_type_supported</a> (const struct doca_devinfo *devinfo, enum <a class="el" href="group__DOCA__ETH.html#ga0aeb6e81bb2aeb9de36b67d90e0934d4">doca_eth_rxq_type</a> <a class="el" href="upf__accel_8h.html#a5f649fbc43a239b31af8e53c8b76b756">type</a>, enum <a class="el" href="group__DOCA__ETH.html#gadd255c9ac16a9c7b410661e2d684a7a5">doca_eth_rxq_data_path_type</a> data_path_type)</td></tr>
<tr class="memdesc:ga8252c90087ba4740bc339cd14ef25212"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if RX queue type is supported.  <a href="group__DOCA__ETH.html#ga8252c90087ba4740bc339cd14ef25212">More...</a><br /></td></tr>
<tr class="separator:ga8252c90087ba4740bc339cd14ef25212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade1481e644205f4809d5528786b7b6c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ETH.html#gade1481e644205f4809d5528786b7b6c1">doca_eth_rxq_estimate_packet_buf_size</a> (enum <a class="el" href="group__DOCA__ETH.html#ga0aeb6e81bb2aeb9de36b67d90e0934d4">doca_eth_rxq_type</a> <a class="el" href="upf__accel_8h.html#a5f649fbc43a239b31af8e53c8b76b756">type</a>, uint32_t rate, uint16_t pkt_max_time, uint32_t max_packet_size, uint32_t max_burst_size, uint8_t log_max_lro_pkt_sz, uint16_t head_size, uint16_t tail_size, uint32_t *buf_size)</td></tr>
<tr class="memdesc:gade1481e644205f4809d5528786b7b6c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the recommended size for the mmap buffer of a doca_eth_rxq.  <a href="group__DOCA__ETH.html#gade1481e644205f4809d5528786b7b6c1">More...</a><br /></td></tr>
<tr class="separator:gade1481e644205f4809d5528786b7b6c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>DOCA ETH RXQ library.</p>
<dl class="section note"><dt>Note</dt><dd>There are 2 data path options to use DOCA ETH RXQ context, a GPU managed control path and a CPU managed one. Other than the need to use <a class="el" href="group__DOCA__CTX.html#ga8724abdb5c006c7407b0fb007a90a22d" title="This function binds the DOCA context to a gpu device.">doca_ctx_set_datapath_on_gpu()</a> on a GPU context before starting it, both cases share the same control path functions (unless mentioned otherwise in the function documentation). The data path functions are different for the different options. The GPU managed data path functions are not included in the DOCA ETH RXQ API (check DOCA GPUNetIO). </dd></dl>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gadd255c9ac16a9c7b410661e2d684a7a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd255c9ac16a9c7b410661e2d684a7a5">&#9670;&nbsp;</a></span>doca_eth_rxq_data_path_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__DOCA__ETH.html#gadd255c9ac16a9c7b410661e2d684a7a5">doca_eth_rxq_data_path_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>RX data-path type. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggadd255c9ac16a9c7b410661e2d684a7a5a13fbfd0afde509977ced48832f81c458"></a>DOCA_ETH_RXQ_DATA_PATH_TYPE_CPU&#160;</td><td class="fielddoc"><p>Enable data path management on the CPU </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadd255c9ac16a9c7b410661e2d684a7a5a68a8fc138d9a6145beaa9d9a6eb9dc77"></a>DOCA_ETH_RXQ_DATA_PATH_TYPE_GPU&#160;</td><td class="fielddoc"><p>Enable data path management on the GPU </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="doca__eth__rxq_8h_source.html#l00094">94</a> of file <a class="el" href="doca__eth__rxq_8h_source.html">doca_eth_rxq.h</a>.</p>

</div>
</div>
<a id="ga0aeb6e81bb2aeb9de36b67d90e0934d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0aeb6e81bb2aeb9de36b67d90e0934d4">&#9670;&nbsp;</a></span>doca_eth_rxq_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__DOCA__ETH.html#ga0aeb6e81bb2aeb9de36b67d90e0934d4">doca_eth_rxq_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>RX queue type. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga0aeb6e81bb2aeb9de36b67d90e0934d4a578e9279409a45e19ddd79fbf7d17ba6"></a>DOCA_ETH_RXQ_TYPE_CYCLIC&#160;</td><td class="fielddoc"><p>This mode is optimized for max packet rate. In this mode the library will receive packets in a cyclic manner. The processing time of packets should be faster than the rate in which they are received. If the application did not process the packets fast enough, the packet may be overrun by a new packet once the recv callback has ended. The receive callback should finish processing the packet before returning or copy the content. The user will supply a doca_mmap for DOCA ETH RXQ context. The recommended size of this mmap should be calculated using doca_eth_rxq_estimate_packet_buf_size. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga0aeb6e81bb2aeb9de36b67d90e0934d4a56bc55361d9eda5077f2d2be5fa23a53"></a>DOCA_ETH_RXQ_TYPE_MANAGED_MEMPOOL&#160;</td><td class="fielddoc"><p>In this mode the library will manage the memory and use various HW features to optimize memory consumption while increasing packet rate. The user will supply a doca_mmap for DOCA ETH RXQ context. The recommended size of this mmap should be calculated using doca_eth_rxq_estimate_packet_buf_size. The library assumes the user will release the packet buffer within a bound amount of time. Keeping packets for a long time without freeing it will block receiving incoming packets. NOTE: This type is supported only for DOCA ETH RXQ instance for CPU </p>
</td></tr>
<tr><td class="fieldname"><a id="gga0aeb6e81bb2aeb9de36b67d90e0934d4aee37cffce9715e8b235ebe37fc744cd6"></a>DOCA_ETH_RXQ_TYPE_REGULAR&#160;</td><td class="fielddoc"><p>In this mode the user posts a receive task, telling DOCA_RXQ to which buffer to scatter the incoming packet. NOTE: This type is supported only for DOCA ETH RXQ instance for CPU </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="doca__eth__rxq_8h_source.html#l00064">64</a> of file <a class="el" href="doca__eth__rxq_8h_source.html">doca_eth_rxq.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga92a26bb9e28dfe46ba69a71155cf1829"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga92a26bb9e28dfe46ba69a71155cf1829">&#9670;&nbsp;</a></span>doca_eth_rxq_as_doca_ctx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> struct doca_ctx* doca_eth_rxq_as_doca_ctx </td>
          <td>(</td>
          <td class="paramtype">struct doca_eth_rxq *&#160;</td>
          <td class="paramname"><em>eth_rxq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert doca_eth_rxq instance into a generalized context for use with doca core objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">eth_rxq</td><td>Pointer to doca_eth_rxq instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non NULL upon success, NULL otherwise. </dd></dl>

</div>
</div>
<a id="gacdc1f261f7fbd5ce1024d9ccab61d3e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacdc1f261f7fbd5ce1024d9ccab61d3e7">&#9670;&nbsp;</a></span>doca_eth_rxq_cap_get_max_burst_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_eth_rxq_cap_get_max_burst_size </td>
          <td>(</td>
          <td class="paramtype">const struct doca_devinfo *&#160;</td>
          <td class="paramname"><em>devinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>max_burst_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the maximum burst size supported by the device. </p>
<dl class="section note"><dt>Note</dt><dd>Function is relevant only in the case of context of type DOCA_ETH_RXQ_TYPE_REGULAR (max_burst_size isn't limited in other modes).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">devinfo</td><td>Pointer to doca_devinfo instance. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">max_burst_size</td><td>The max burst size.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - if an invalid parameter was given. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga104d5db37495f6d0ada2d45801512b11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga104d5db37495f6d0ada2d45801512b11">&#9670;&nbsp;</a></span>doca_eth_rxq_cap_get_max_metadata_num()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_eth_rxq_cap_get_max_metadata_num </td>
          <td>(</td>
          <td class="paramtype">const struct doca_devinfo *&#160;</td>
          <td class="paramname"><em>devinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>max_metadata_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the maximum metadata number supported by the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">devinfo</td><td>Pointer to doca_devinfo instance. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">max_metadata_num</td><td>Maximal metadata number to get. (check doca_eth_rxq_set_metadata_num)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - if property set successfully. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - if an invalid parameter was given. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga4cacfb42153196bf4ee6dca8e3663521"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4cacfb42153196bf4ee6dca8e3663521">&#9670;&nbsp;</a></span>doca_eth_rxq_cap_get_max_packet_headroom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_eth_rxq_cap_get_max_packet_headroom </td>
          <td>(</td>
          <td class="paramtype">const struct doca_devinfo *&#160;</td>
          <td class="paramname"><em>devinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>max_packet_headroom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the maximum packet headroom size supported by the device. </p>
<dl class="section note"><dt>Note</dt><dd>In case of context of type DOCA_ETH_RXQ_TYPE_MANAGED_MEMPOOL where headroom (or tailroom) is used, the following should be satisfied: (packet_headroom + packet_tailroom + max_packet_size) &lt;= 8KB</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">devinfo</td><td>Pointer to doca_devinfo instance. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">max_packet_headroom</td><td>Maximal packet headroom size to get. (check doca_eth_rxq_set_packet_headroom)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - if property set successfully. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - if an invalid parameter was given. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga9d4c4afa279adcf6c9a802a9a4a0d857"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d4c4afa279adcf6c9a802a9a4a0d857">&#9670;&nbsp;</a></span>doca_eth_rxq_cap_get_max_packet_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_eth_rxq_cap_get_max_packet_size </td>
          <td>(</td>
          <td class="paramtype">const struct doca_devinfo *&#160;</td>
          <td class="paramname"><em>devinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>max_packet_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the maximum packet size supported by the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">devinfo</td><td>Pointer to doca_devinfo instance. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">max_packet_size</td><td>The max packet size.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - if an invalid parameter was given. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga7b6690ce8ce63cb786de69f5b734522e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b6690ce8ce63cb786de69f5b734522e">&#9670;&nbsp;</a></span>doca_eth_rxq_cap_get_max_packet_tailroom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_eth_rxq_cap_get_max_packet_tailroom </td>
          <td>(</td>
          <td class="paramtype">const struct doca_devinfo *&#160;</td>
          <td class="paramname"><em>devinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>max_packet_tailroom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the maximum packet tailroom size supported by the device. </p>
<dl class="section note"><dt>Note</dt><dd>In case of context of type DOCA_ETH_RXQ_TYPE_MANAGED_MEMPOOL where headroom (or tailroom) is used, the following should be satisfied: (packet_headroom + packet_tailroom + max_packet_size) &lt;= 8KB</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">devinfo</td><td>Pointer to doca_devinfo instance. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">max_packet_tailroom</td><td>Maximal packet tailroom size to get. (check doca_eth_rxq_set_packet_tailroom)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - if property set successfully. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - if an invalid parameter was given. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga47a5fea6a89967dc45afb1f960f698c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga47a5fea6a89967dc45afb1f960f698c9">&#9670;&nbsp;</a></span>doca_eth_rxq_cap_get_max_recv_buf_list_len()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_eth_rxq_cap_get_max_recv_buf_list_len </td>
          <td>(</td>
          <td class="paramtype">const struct doca_devinfo *&#160;</td>
          <td class="paramname"><em>devinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>max_recv_buf_list_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the maximum receive buffer list length supported by the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">devinfo</td><td>Pointer to doca_devinfo instance. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">max_recv_buf_list_len</td><td>Maximal receive buffer list length to get. (check doca_eth_rxq_set_max_recv_buf_list_len)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - if property set successfully. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - if an invalid parameter was given. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga8252c90087ba4740bc339cd14ef25212"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8252c90087ba4740bc339cd14ef25212">&#9670;&nbsp;</a></span>doca_eth_rxq_cap_is_type_supported()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_eth_rxq_cap_is_type_supported </td>
          <td>(</td>
          <td class="paramtype">const struct doca_devinfo *&#160;</td>
          <td class="paramname"><em>devinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__DOCA__ETH.html#ga0aeb6e81bb2aeb9de36b67d90e0934d4">doca_eth_rxq_type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__DOCA__ETH.html#gadd255c9ac16a9c7b410661e2d684a7a5">doca_eth_rxq_data_path_type</a>&#160;</td>
          <td class="paramname"><em>data_path_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if RX queue type is supported. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">devinfo</td><td>Pointer to doca_devinfo instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>RX queue type - see enum doca_eth_rxq_type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data_path_type</td><td>RX data-path type - see enum doca_eth_rxq_data_path_type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - if an invalid parameter was given.</li>
<li>DOCA_ERROR_NOT_SUPPORTED - if type is not supported. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gab0137b30a8fdd981c783ad037bedfa64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab0137b30a8fdd981c783ad037bedfa64">&#9670;&nbsp;</a></span>doca_eth_rxq_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_eth_rxq_create </td>
          <td>(</td>
          <td class="paramtype">struct doca_dev *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_burst_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_packet_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct doca_eth_rxq **&#160;</td>
          <td class="paramname"><em>eth_rxq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a DOCA ETH RXQ instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>Device to bind the context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_burst_size</td><td>Max burst size to use in context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_packet_size</td><td>Max packet size to use in context. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">eth_rxq</td><td>Pointer to pointer to be set to point to the created doca_eth_rxq instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - eth_rxq argument is a NULL pointer.</li>
<li>DOCA_ERROR_NO_MEMORY - failed to allocate resources. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga5e604bf995cfe9f376caffe9a1c9ae4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e604bf995cfe9f376caffe9a1c9ae4c">&#9670;&nbsp;</a></span>doca_eth_rxq_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_eth_rxq_destroy </td>
          <td>(</td>
          <td class="paramtype">struct doca_eth_rxq *&#160;</td>
          <td class="paramname"><em>eth_rxq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a DOCA ETH RXQ instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">eth_rxq</td><td>Pointer to instance to be destroyed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - eth_rxq argument is a NULL pointer.</li>
<li>DOCA_ERROR_BAD_STATE - eth_rxq context state is not idle. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gade1481e644205f4809d5528786b7b6c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade1481e644205f4809d5528786b7b6c1">&#9670;&nbsp;</a></span>doca_eth_rxq_estimate_packet_buf_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_eth_rxq_estimate_packet_buf_size </td>
          <td>(</td>
          <td class="paramtype">enum <a class="el" href="group__DOCA__ETH.html#ga0aeb6e81bb2aeb9de36b67d90e0934d4">doca_eth_rxq_type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>pkt_max_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_packet_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_burst_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>log_max_lro_pkt_sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>head_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>tail_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>buf_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the recommended size for the mmap buffer of a doca_eth_rxq. </p>
<p>This function should be used for calculating the recommended size of the doca_mmap given to <a class="el" href="group__DOCA__ETH.html#gab38fc69755b84bd45454b54b2d9be59c" title="Set Eth packet buffer for a doca_eth_rxq. can only be called before calling doca_ctx_start().">doca_eth_rxq_set_pkt_buf()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Function is irrelevant in the case of context of type DOCA_ETH_RXQ_TYPE_REGULAR.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>Type of DOCA ETH RXQ. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rate</td><td>Rate in [MB/s] in which the doca_rxq is expected to receive traffic. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pkt_max_time</td><td>Max time in [μs] a packet may take to be processed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_packet_size</td><td>Max non-LRO packet size in [B]. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_burst_size</td><td>Max size of packets burst. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_max_lro_pkt_sz</td><td>Log of max LRO packet size. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">head_size</td><td>Packet headroom size. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tail_size</td><td>Packet tailroom size. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buf_size</td><td>The recommended size for the mmap buffer in [B].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - if an invalid parameter was given.</li>
<li>DOCA_ERROR_NOT_SUPPORTED - if the given type does not require packet buffer size. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga0fad4686dba9a4d57b693b09733fa552"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0fad4686dba9a4d57b693b09733fa552">&#9670;&nbsp;</a></span>doca_eth_rxq_get_flow_queue_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_eth_rxq_get_flow_queue_id </td>
          <td>(</td>
          <td class="paramtype">struct doca_eth_rxq *&#160;</td>
          <td class="paramname"><em>eth_rxq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>flow_queue_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the DPDK queue ID of the doca_eth receive queue. can only be called after calling <a class="el" href="group__DOCA__CTX.html#ga712a2c32ab9113f568d08c379ec506f7" title="Finalizes all configurations, and starts the DOCA CTX.">doca_ctx_start()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">eth_rxq</td><td>Pointer to doca_eth_rxq instance. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">flow_queue_id</td><td>The queue ID to be used in rte_flow or doca_flow.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - if an invalid parameter was given.</li>
<li>DOCA_ERROR_BAD_STATE - if context was not started. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga634d5a251407fb2bc7f341fbb89b3236"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga634d5a251407fb2bc7f341fbb89b3236">&#9670;&nbsp;</a></span>doca_eth_rxq_get_gpu_handle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_eth_rxq_get_gpu_handle </td>
          <td>(</td>
          <td class="paramtype">const struct doca_eth_rxq *&#160;</td>
          <td class="paramname"><em>eth_rxq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct doca_gpu_eth_rxq **&#160;</td>
          <td class="paramname"><em>eth_rxq_ext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a gpu handle of a doca_eth_rxq. </p>
<dl class="section note"><dt>Note</dt><dd>Supported for DOCA ETH RXQ instance for GPU only.</dd></dl>
<p>This method should be used after ctx is started. The expected flow is as follows:</p><ol type="1">
<li>bind the ctx to a gpu device using <a class="el" href="group__DOCA__CTX.html#ga8724abdb5c006c7407b0fb007a90a22d" title="This function binds the DOCA context to a gpu device.">doca_ctx_set_datapath_on_gpu()</a></li>
<li>start the ctx using <a class="el" href="group__DOCA__CTX.html#ga712a2c32ab9113f568d08c379ec506f7" title="Finalizes all configurations, and starts the DOCA CTX.">doca_ctx_start()</a></li>
<li>call <a class="el" href="group__DOCA__ETH.html#ga634d5a251407fb2bc7f341fbb89b3236" title="Get a gpu handle of a doca_eth_rxq.">doca_eth_rxq_get_gpu_handle()</a> to get the gpu_handle</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">eth_rxq</td><td>Pointer to doca_eth_rxq instance. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">eth_rxq_ext</td><td>A doca gpu eth_rxq handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - if an invalid parameter was given.</li>
<li>DOCA_ERROR_BAD_STATE - if context is not started.</li>
<li>DOCA_ERROR_NOT_SUPPORTED - in case eth_rxq isn't an instance for GPU. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga0e4193716cf95d66cd7215a0b6e7784e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e4193716cf95d66cd7215a0b6e7784e">&#9670;&nbsp;</a></span>doca_eth_rxq_set_flow_tag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_eth_rxq_set_flow_tag </td>
          <td>(</td>
          <td class="paramtype">struct doca_eth_rxq *&#160;</td>
          <td class="paramname"><em>eth_rxq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>enable_flow_tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Setter to enable flow tag support. User can retrieve flow tag per packet when this is enabled. can only be called before calling <a class="el" href="group__DOCA__CTX.html#ga712a2c32ab9113f568d08c379ec506f7" title="Finalizes all configurations, and starts the DOCA CTX.">doca_ctx_start()</a>. </p>
<dl class="section note"><dt>Note</dt><dd>Supported for DOCA ETH RXQ instance for CPU only. </dd>
<dd>
The default configuration is to disable flow tag support.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">eth_rxq</td><td>Pointer to doca_eth_rxq instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enable_flow_tag</td><td>An indicator to enable/disable flow tag.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - if an invalid parameter was given.</li>
<li>DOCA_ERROR_BAD_STATE - if context is not idle. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga3ba098a142ee5dcdb67d27788fef5400"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ba098a142ee5dcdb67d27788fef5400">&#9670;&nbsp;</a></span>doca_eth_rxq_set_max_burst_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_eth_rxq_set_max_burst_size </td>
          <td>(</td>
          <td class="paramtype">struct doca_eth_rxq *&#160;</td>
          <td class="paramname"><em>eth_rxq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_burst_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set max burst size property for doca_eth_rxq. This value dictates the maximal number of packets the HW can handle at the same time. can only be called before calling <a class="el" href="group__DOCA__CTX.html#ga712a2c32ab9113f568d08c379ec506f7" title="Finalizes all configurations, and starts the DOCA CTX.">doca_ctx_start()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">eth_rxq</td><td>Pointer to doca_eth_rxq instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_burst_size</td><td>Max burst size to use in context.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - if an invalid parameter was given.</li>
<li>DOCA_ERROR_BAD_STATE - if context is not idle. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gabae4d6515ceae5184c62c5954ea54c7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabae4d6515ceae5184c62c5954ea54c7b">&#9670;&nbsp;</a></span>doca_eth_rxq_set_max_packet_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_eth_rxq_set_max_packet_size </td>
          <td>(</td>
          <td class="paramtype">struct doca_eth_rxq *&#160;</td>
          <td class="paramname"><em>eth_rxq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_packet_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set max packet size property for doca_eth_rxq. can only be called before calling <a class="el" href="group__DOCA__CTX.html#ga712a2c32ab9113f568d08c379ec506f7" title="Finalizes all configurations, and starts the DOCA CTX.">doca_ctx_start()</a>. </p>
<dl class="section note"><dt>Note</dt><dd>Function is irrelevant in the case of context of type DOCA_ETH_RXQ_TYPE_REGULAR.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">eth_rxq</td><td>Pointer to doca_eth_rxq instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_packet_size</td><td>Max packet size to use in context.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - if an invalid parameter was given.</li>
<li>DOCA_ERROR_BAD_STATE - if context is not idle. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga9cfbba8358fc2b3f65c62fdde5970984"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9cfbba8358fc2b3f65c62fdde5970984">&#9670;&nbsp;</a></span>doca_eth_rxq_set_max_recv_buf_list_len()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_eth_rxq_set_max_recv_buf_list_len </td>
          <td>(</td>
          <td class="paramtype">struct doca_eth_rxq *&#160;</td>
          <td class="paramname"><em>eth_rxq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_recv_buf_list_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the maximal receive buffer list length for doca_eth_rxq. This value indicated what the maximal number of elements in a doca_buf list is. can only be called before calling <a class="el" href="group__DOCA__CTX.html#ga712a2c32ab9113f568d08c379ec506f7" title="Finalizes all configurations, and starts the DOCA CTX.">doca_ctx_start()</a>. </p>
<dl class="section note"><dt>Note</dt><dd>Function is relevant only in the case of context of type DOCA_ETH_RXQ_TYPE_REGULAR. </dd>
<dd>
The default maximal receive buffer list length is 1.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">eth_rxq</td><td>Pointer to doca_eth_rxq instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_recv_buf_list_len</td><td>Maximal receive buffer list length to use in context.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - if property set successfully. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - if an invalid parameter was given.</li>
<li>DOCA_ERROR_BAD_STATE - if context is not idle. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gae478592c3c7d15ad3c1ec470805fdc3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae478592c3c7d15ad3c1ec470805fdc3d">&#9670;&nbsp;</a></span>doca_eth_rxq_set_metadata_num()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_eth_rxq_set_metadata_num </td>
          <td>(</td>
          <td class="paramtype">struct doca_eth_rxq *&#160;</td>
          <td class="paramname"><em>eth_rxq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>metadata_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set metadata number for doca_eth_rxq. can only be called before calling <a class="el" href="group__DOCA__CTX.html#ga712a2c32ab9113f568d08c379ec506f7" title="Finalizes all configurations, and starts the DOCA CTX.">doca_ctx_start()</a>. </p>
<dl class="section note"><dt>Note</dt><dd>Supported for DOCA ETH RXQ instance for CPU only. </dd>
<dd>
The default configuration is to disable metadta support (0 metadata per packet).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">eth_rxq</td><td>Pointer to doca_eth_rxq instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">metadata_num</td><td>Number of metadata per packet.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - if an invalid parameter was given.</li>
<li>DOCA_ERROR_BAD_STATE - if context is not idle. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gab126e192a7453d829d2701c43627b7d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab126e192a7453d829d2701c43627b7d9">&#9670;&nbsp;</a></span>doca_eth_rxq_set_notification_moderation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_eth_rxq_set_notification_moderation </td>
          <td>(</td>
          <td class="paramtype">struct doca_eth_rxq *&#160;</td>
          <td class="paramname"><em>eth_rxq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>period_usec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>comp_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set notification moderation. </p>
<p>Notification moderation affects the number of events Rx completion events. Notification moderation can be modified at run time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">eth_rxq</td><td>Pointer to instance to set the moderation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">period_usec</td><td>(0 disables moderation) Period in microseconds from the first completion until event is fired </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">comp_count</td><td>(0 disables moderation) Number of Rx completions until event is fired</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input.</li>
<li>DOCA_ERROR_BAD_STATE - if context was not started.</li>
<li>DOCA_ERROR_DRIVER - Failed to set moderation. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga73034701d5cf97694ba9277acc46fc7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga73034701d5cf97694ba9277acc46fc7a">&#9670;&nbsp;</a></span>doca_eth_rxq_set_packet_headroom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_eth_rxq_set_packet_headroom </td>
          <td>(</td>
          <td class="paramtype">struct doca_eth_rxq *&#160;</td>
          <td class="paramname"><em>eth_rxq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>head_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Setter to enable packet headroom support. User can use doca_buf's headroom of size head_size when this is enabled. can only be called before calling <a class="el" href="group__DOCA__CTX.html#ga712a2c32ab9113f568d08c379ec506f7" title="Finalizes all configurations, and starts the DOCA CTX.">doca_ctx_start()</a>. </p>
<dl class="section note"><dt>Note</dt><dd>Supported for DOCA ETH RXQ instance for CPU only. </dd>
<dd>
Supported for DOCA_ETH_RXQ_TYPE_MANAGED_MEMPOOL mode only. </dd>
<dd>
The default configuration is to disable packet headroom support.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">eth_rxq</td><td>Pointer to doca_eth_rxq instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">head_size</td><td>Head size to use for packet's headroom.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - if an invalid parameter was given.</li>
<li>DOCA_ERROR_BAD_STATE - if context is not idle. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga22be294e4d7c2af2d42c52348f1ca173"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga22be294e4d7c2af2d42c52348f1ca173">&#9670;&nbsp;</a></span>doca_eth_rxq_set_packet_tailroom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_eth_rxq_set_packet_tailroom </td>
          <td>(</td>
          <td class="paramtype">struct doca_eth_rxq *&#160;</td>
          <td class="paramname"><em>eth_rxq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>tail_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Setter to enable packet tailroom support. User can use doca_buf's tailroom of size tail_size when this is enabled. can only be called before calling <a class="el" href="group__DOCA__CTX.html#ga712a2c32ab9113f568d08c379ec506f7" title="Finalizes all configurations, and starts the DOCA CTX.">doca_ctx_start()</a>. </p>
<dl class="section note"><dt>Note</dt><dd>Supported for DOCA ETH RXQ instance for CPU only. </dd>
<dd>
Supported for DOCA_ETH_RXQ_TYPE_MANAGED_MEMPOOL mode only. </dd>
<dd>
The default configuration is to disable packet tailroom support.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">eth_rxq</td><td>Pointer to doca_eth_rxq instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tail_size</td><td>Tail size to use for packet's tailroom.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - if an invalid parameter was given.</li>
<li>DOCA_ERROR_BAD_STATE - if context is not idle. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gab38fc69755b84bd45454b54b2d9be59c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab38fc69755b84bd45454b54b2d9be59c">&#9670;&nbsp;</a></span>doca_eth_rxq_set_pkt_buf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_eth_rxq_set_pkt_buf </td>
          <td>(</td>
          <td class="paramtype">struct doca_eth_rxq *&#160;</td>
          <td class="paramname"><em>eth_rxq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct doca_mmap *&#160;</td>
          <td class="paramname"><em>mmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mmap_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mmap_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set Eth packet buffer for a doca_eth_rxq. can only be called before calling <a class="el" href="group__DOCA__CTX.html#ga712a2c32ab9113f568d08c379ec506f7" title="Finalizes all configurations, and starts the DOCA CTX.">doca_ctx_start()</a>. </p>
<dl class="section note"><dt>Note</dt><dd>Function is irrelevant in the case of context of type DOCA_ETH_RXQ_TYPE_REGULAR.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">eth_rxq</td><td>Pointer to doca_eth_rxq instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mmap</td><td>The mmap consist of the memrange for the Eth packet buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mmap_offset</td><td>The offset from mmap start to set the packet buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mmap_len</td><td>The mmap length of the packet buffer, starting from offset.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - if an invalid parameter was given.</li>
<li>DOCA_ERROR_BAD_STATE - if context is not idle. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gae66fc9ed99ac00173b168675a7fef942"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae66fc9ed99ac00173b168675a7fef942">&#9670;&nbsp;</a></span>doca_eth_rxq_set_rx_hash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_eth_rxq_set_rx_hash </td>
          <td>(</td>
          <td class="paramtype">struct doca_eth_rxq *&#160;</td>
          <td class="paramname"><em>eth_rxq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>enable_rx_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Setter to enable RX hash support. User can retrieve RX hash per packet when this is enabled. can only be called before calling <a class="el" href="group__DOCA__CTX.html#ga712a2c32ab9113f568d08c379ec506f7" title="Finalizes all configurations, and starts the DOCA CTX.">doca_ctx_start()</a>. </p>
<dl class="section note"><dt>Note</dt><dd>Supported for DOCA ETH RXQ instance for CPU only. </dd>
<dd>
The default configuration is to disable RX hash support.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">eth_rxq</td><td>Pointer to doca_eth_rxq instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enable_rx_hash</td><td>An indicator to enable/disable RX hash.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - if an invalid parameter was given.</li>
<li>DOCA_ERROR_BAD_STATE - if context is not idle. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga7f55fac5c0c411b59f2ffe6530bfa036"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f55fac5c0c411b59f2ffe6530bfa036">&#9670;&nbsp;</a></span>doca_eth_rxq_set_timestamp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_eth_rxq_set_timestamp </td>
          <td>(</td>
          <td class="paramtype">struct doca_eth_rxq *&#160;</td>
          <td class="paramname"><em>eth_rxq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>enable_timestamp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Setter to enable timestamp support. User can retrieve timestamp in nanoseconds per packet when this is enabled. can only be called before calling <a class="el" href="group__DOCA__CTX.html#ga712a2c32ab9113f568d08c379ec506f7" title="Finalizes all configurations, and starts the DOCA CTX.">doca_ctx_start()</a>. </p>
<dl class="section note"><dt>Note</dt><dd>Supported for DOCA ETH RXQ instance for CPU only. </dd>
<dd>
The default configuration is to disable timestamp support. </dd>
<dd>
This feature return the real time in nanoseconds when REAL_TIME_CLOCK_ENABLE ("mlxconfig" parameter) is TRUE.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">eth_rxq</td><td>Pointer to doca_eth_rxq instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enable_timestamp</td><td>An indicator to enable/disable timestamp.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - if an invalid parameter was given.</li>
<li>DOCA_ERROR_BAD_STATE - if context is not idle. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga444cd8f8338d0b789e6da4f4001f3e07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga444cd8f8338d0b789e6da4f4001f3e07">&#9670;&nbsp;</a></span>doca_eth_rxq_set_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_eth_rxq_set_type </td>
          <td>(</td>
          <td class="paramtype">struct doca_eth_rxq *&#160;</td>
          <td class="paramname"><em>eth_rxq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__DOCA__ETH.html#ga0aeb6e81bb2aeb9de36b67d90e0934d4">doca_eth_rxq_type</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set RX queue type property for doca_eth_rxq. can only be called before calling <a class="el" href="group__DOCA__CTX.html#ga712a2c32ab9113f568d08c379ec506f7" title="Finalizes all configurations, and starts the DOCA CTX.">doca_ctx_start()</a>. </p>
<dl class="section note"><dt>Note</dt><dd>The default type is DOCA_ETH_RXQ_TYPE_REGULAR.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">eth_rxq</td><td>Pointer to doca_eth_rxq instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>RX queue type - see enum doca_eth_rxq_type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - if an invalid parameter was given.</li>
<li>DOCA_ERROR_BAD_STATE - if context is not idle. </li>
</ul>
</dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Wed Aug 13 2025 09:23:37 for NVIDIA DOCA SDK by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
