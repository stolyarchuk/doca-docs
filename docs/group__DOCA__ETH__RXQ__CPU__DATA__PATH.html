<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NVIDIA DOCA SDK: DOCA ETH RXQ CPU Data Path</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<!-- Doxygen Awesome CSS -->
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript">
DoxygenAwesomeDarkModeToggle.init()
DoxygenAwesomeFragmentCopyButton.init()
DoxygenAwesomeParagraphLink.init()
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectname">NVIDIA DOCA SDK
  </td>
  <td id="projectbrief">Data Center on a Chip Framework Documentation</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__DOCA__ETH__RXQ__CPU__DATA__PATH.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">DOCA ETH RXQ CPU Data Path<div class="ingroups"><a class="el" href="group__DOCA__ETH.html">DOCA ETH</a> &raquo; <a class="el" href="group__DOCA__ETH__RXQ.html">DOCA ETH RXQ</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for DOCA ETH RXQ CPU Data Path:</div>
<div class="dyncontent">
<div class="center"><img src="group__DOCA__ETH__RXQ__CPU__DATA__PATH.png" border="0" usemap="#agroup____DOCA____ETH____RXQ____CPU____DATA____PATH" alt=""/></div>
<map name="agroup____DOCA____ETH____RXQ____CPU____DATA____PATH" id="agroup____DOCA____ETH____RXQ____CPU____DATA____PATH">
<area shape="rect" title=" " alt="" coords="176,5,396,31"/>
<area shape="rect" href="group__DOCA__ETH__RXQ.html" title=" " alt="" coords="5,5,128,31"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gae92a34197b69d122717ad53361d6f6fc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ETH__RXQ__CPU__DATA__PATH.html#gae92a34197b69d122717ad53361d6f6fc">doca_eth_rxq_event_batch_managed_recv_metadata_array_get_metadata</a>(metadata_array,  metadata_num,  packet_index,  metadata_index)&#160;&#160;&#160;	metadata_array[packet_index * metadata_num + metadata_index]</td></tr>
<tr class="memdesc:gae92a34197b69d122717ad53361d6f6fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This MACRO is used to get a specific metadata of a specific packet from metadata_array from managed receive event batch.  <a href="group__DOCA__ETH__RXQ__CPU__DATA__PATH.html#gae92a34197b69d122717ad53361d6f6fc">More...</a><br /></td></tr>
<tr class="separator:gae92a34197b69d122717ad53361d6f6fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaa2486a6e6e96c83cc4534ae7d0e81486"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ETH__RXQ__CPU__DATA__PATH.html#gaa2486a6e6e96c83cc4534ae7d0e81486">doca_eth_rxq_task_recv_completion_cb_t</a>) (struct doca_eth_rxq_task_recv *task_recv, union <a class="el" href="uniondoca__data.html">doca_data</a> task_user_data, union <a class="el" href="uniondoca__data.html">doca_data</a> ctx_user_data)</td></tr>
<tr class="memdesc:gaa2486a6e6e96c83cc4534ae7d0e81486"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to execute on task completion.  <a href="group__DOCA__ETH__RXQ__CPU__DATA__PATH.html#gaa2486a6e6e96c83cc4534ae7d0e81486">More...</a><br /></td></tr>
<tr class="separator:gaa2486a6e6e96c83cc4534ae7d0e81486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f3f2861ec1aed76a4604903c20f3327"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ETH__RXQ__CPU__DATA__PATH.html#ga9f3f2861ec1aed76a4604903c20f3327">doca_eth_rxq_event_managed_recv_handler_cb_t</a>) (struct doca_eth_rxq_event_managed_recv *event_managed_recv, struct doca_buf *pkt, union <a class="el" href="uniondoca__data.html">doca_data</a> event_user_data)</td></tr>
<tr class="memdesc:ga9f3f2861ec1aed76a4604903c20f3327"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to be executed on managed receive event occurrence.  <a href="group__DOCA__ETH__RXQ__CPU__DATA__PATH.html#ga9f3f2861ec1aed76a4604903c20f3327">More...</a><br /></td></tr>
<tr class="separator:ga9f3f2861ec1aed76a4604903c20f3327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89c6241485d1c000c89e7dbc620d8265"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ETH__RXQ__CPU__DATA__PATH.html#ga89c6241485d1c000c89e7dbc620d8265">doca_eth_rxq_event_batch_managed_recv_handler_cb_t</a>) (struct doca_eth_rxq_event_batch_managed_recv *event_batch_managed_recv, uint16_t events_number, union <a class="el" href="uniondoca__data.html">doca_data</a> event_batch_user_data, <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> status, struct doca_buf **pkt_array)</td></tr>
<tr class="memdesc:ga89c6241485d1c000c89e7dbc620d8265"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to be executed on managed receive event batch occurrence.  <a href="group__DOCA__ETH__RXQ__CPU__DATA__PATH.html#ga89c6241485d1c000c89e7dbc620d8265">More...</a><br /></td></tr>
<tr class="separator:ga89c6241485d1c000c89e7dbc620d8265"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga539bc06a14c08ddba977f25ba4e998b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ETH__RXQ__CPU__DATA__PATH.html#ga539bc06a14c08ddba977f25ba4e998b0">doca_eth_rxq_task_recv_set_conf</a> (struct doca_eth_rxq *eth_rxq, <a class="el" href="group__DOCA__ETH__RXQ__CPU__DATA__PATH.html#gaa2486a6e6e96c83cc4534ae7d0e81486">doca_eth_rxq_task_recv_completion_cb_t</a> <a class="el" href="common__common_8c.html#a9b0d720febe817ac2c06bfe928947a9b">task_completion_cb</a>, <a class="el" href="group__DOCA__ETH__RXQ__CPU__DATA__PATH.html#gaa2486a6e6e96c83cc4534ae7d0e81486">doca_eth_rxq_task_recv_completion_cb_t</a> <a class="el" href="common__common_8c.html#a08b00e93470e60c6ce9421892e080974">task_error_cb</a>, uint32_t task_recv_num)</td></tr>
<tr class="memdesc:ga539bc06a14c08ddba977f25ba4e998b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method sets the doca_eth_rxq_task_recv tasks configuration. can only be called before calling <a class="el" href="group__DOCA__CTX.html#ga712a2c32ab9113f568d08c379ec506f7" title="Finalizes all configurations, and starts the DOCA CTX.">doca_ctx_start()</a>.  <a href="group__DOCA__ETH__RXQ__CPU__DATA__PATH.html#ga539bc06a14c08ddba977f25ba4e998b0">More...</a><br /></td></tr>
<tr class="separator:ga539bc06a14c08ddba977f25ba4e998b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga418429fb52c5625da2311ebf01acbd8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ETH__RXQ__CPU__DATA__PATH.html#ga418429fb52c5625da2311ebf01acbd8f">doca_eth_rxq_event_managed_recv_register</a> (struct doca_eth_rxq *eth_rxq, union <a class="el" href="uniondoca__data.html">doca_data</a> user_data, <a class="el" href="group__DOCA__ETH__RXQ__CPU__DATA__PATH.html#ga9f3f2861ec1aed76a4604903c20f3327">doca_eth_rxq_event_managed_recv_handler_cb_t</a> success_event_handler, <a class="el" href="group__DOCA__ETH__RXQ__CPU__DATA__PATH.html#ga9f3f2861ec1aed76a4604903c20f3327">doca_eth_rxq_event_managed_recv_handler_cb_t</a> error_event_handler)</td></tr>
<tr class="memdesc:ga418429fb52c5625da2311ebf01acbd8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method registers a doca_eth_rxq_event_managed_recv event. can only be called before calling <a class="el" href="group__DOCA__CTX.html#ga712a2c32ab9113f568d08c379ec506f7" title="Finalizes all configurations, and starts the DOCA CTX.">doca_ctx_start()</a>.  <a href="group__DOCA__ETH__RXQ__CPU__DATA__PATH.html#ga418429fb52c5625da2311ebf01acbd8f">More...</a><br /></td></tr>
<tr class="separator:ga418429fb52c5625da2311ebf01acbd8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaead983a8354e4a7799569367a76130e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ETH__RXQ__CPU__DATA__PATH.html#gaead983a8354e4a7799569367a76130e0">doca_eth_rxq_event_batch_managed_recv_register</a> (struct doca_eth_rxq *eth_rxq, enum <a class="el" href="group__DOCA__PE.html#gae634a249acf0a42464e587f76d766e8b">doca_event_batch_events_number</a> events_number_max, enum <a class="el" href="group__DOCA__PE.html#gae634a249acf0a42464e587f76d766e8b">doca_event_batch_events_number</a> events_number_min, union <a class="el" href="uniondoca__data.html">doca_data</a> user_data, <a class="el" href="group__DOCA__ETH__RXQ__CPU__DATA__PATH.html#ga89c6241485d1c000c89e7dbc620d8265">doca_eth_rxq_event_batch_managed_recv_handler_cb_t</a> success_event_batch_handler, <a class="el" href="group__DOCA__ETH__RXQ__CPU__DATA__PATH.html#ga89c6241485d1c000c89e7dbc620d8265">doca_eth_rxq_event_batch_managed_recv_handler_cb_t</a> error_event_batch_handler)</td></tr>
<tr class="memdesc:gaead983a8354e4a7799569367a76130e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method registers a doca_eth_rxq_event_managed_recv event batch. Allows user to get multiple event completions with one callback. can only be called before calling <a class="el" href="group__DOCA__CTX.html#ga712a2c32ab9113f568d08c379ec506f7" title="Finalizes all configurations, and starts the DOCA CTX.">doca_ctx_start()</a>.  <a href="group__DOCA__ETH__RXQ__CPU__DATA__PATH.html#gaead983a8354e4a7799569367a76130e0">More...</a><br /></td></tr>
<tr class="separator:gaead983a8354e4a7799569367a76130e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga133a3358f623e61da7f7507e4d0780bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ETH__RXQ__CPU__DATA__PATH.html#ga133a3358f623e61da7f7507e4d0780bc">doca_eth_rxq_task_recv_allocate_init</a> (struct doca_eth_rxq *eth_rxq, struct doca_buf *pkt, union <a class="el" href="uniondoca__data.html">doca_data</a> user_data, struct doca_eth_rxq_task_recv **task_recv)</td></tr>
<tr class="memdesc:ga133a3358f623e61da7f7507e4d0780bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method allocates and initializes a doca_eth_rxq_task_recv task.  <a href="group__DOCA__ETH__RXQ__CPU__DATA__PATH.html#ga133a3358f623e61da7f7507e4d0780bc">More...</a><br /></td></tr>
<tr class="separator:ga133a3358f623e61da7f7507e4d0780bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga652805709618170b9820f1ebd229d80e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ETH__RXQ__CPU__DATA__PATH.html#ga652805709618170b9820f1ebd229d80e">doca_eth_rxq_task_recv_set_pkt</a> (struct doca_eth_rxq_task_recv *task_recv, struct doca_buf *pkt)</td></tr>
<tr class="memdesc:ga652805709618170b9820f1ebd229d80e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method sets packet buffer to doca_eth_rxq_task_recv task.  <a href="group__DOCA__ETH__RXQ__CPU__DATA__PATH.html#ga652805709618170b9820f1ebd229d80e">More...</a><br /></td></tr>
<tr class="separator:ga652805709618170b9820f1ebd229d80e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22f3f3fd6266effe074fd20ba62ea331"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ETH__RXQ__CPU__DATA__PATH.html#ga22f3f3fd6266effe074fd20ba62ea331">doca_eth_rxq_task_recv_get_pkt</a> (const struct doca_eth_rxq_task_recv *task_recv, struct doca_buf **pkt)</td></tr>
<tr class="memdesc:ga22f3f3fd6266effe074fd20ba62ea331"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method gets packet buffer from doca_eth_rxq_task_recv task.  <a href="group__DOCA__ETH__RXQ__CPU__DATA__PATH.html#ga22f3f3fd6266effe074fd20ba62ea331">More...</a><br /></td></tr>
<tr class="separator:ga22f3f3fd6266effe074fd20ba62ea331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad12889cb149331ba71518c0c9fd71689"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ETH__RXQ__CPU__DATA__PATH.html#gad12889cb149331ba71518c0c9fd71689">doca_eth_rxq_task_recv_get_l3_ok</a> (const struct doca_eth_rxq_task_recv *task_recv, uint8_t *l3_ok)</td></tr>
<tr class="memdesc:gad12889cb149331ba71518c0c9fd71689"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method checks if L3 checksum of finished doca_eth_rxq_task_recv task is ok.  <a href="group__DOCA__ETH__RXQ__CPU__DATA__PATH.html#gad12889cb149331ba71518c0c9fd71689">More...</a><br /></td></tr>
<tr class="separator:gad12889cb149331ba71518c0c9fd71689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab776ce2397ae8cad2b67ba545171a557"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ETH__RXQ__CPU__DATA__PATH.html#gab776ce2397ae8cad2b67ba545171a557">doca_eth_rxq_event_managed_recv_get_l3_ok</a> (const struct doca_eth_rxq_event_managed_recv *event_managed_recv, uint8_t *l3_ok)</td></tr>
<tr class="memdesc:gab776ce2397ae8cad2b67ba545171a557"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method checks if L3 checksum of finished doca_eth_rxq_event_managed_recv event is ok.  <a href="group__DOCA__ETH__RXQ__CPU__DATA__PATH.html#gab776ce2397ae8cad2b67ba545171a557">More...</a><br /></td></tr>
<tr class="separator:gab776ce2397ae8cad2b67ba545171a557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53c52132cb1a3373557d8f5f4942b4e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ETH__RXQ__CPU__DATA__PATH.html#ga53c52132cb1a3373557d8f5f4942b4e2">doca_eth_rxq_event_batch_managed_recv_get_l3_ok_array</a> (const struct doca_eth_rxq_event_batch_managed_recv *event_batch_managed_recv, const uint8_t **l3_ok_array)</td></tr>
<tr class="memdesc:ga53c52132cb1a3373557d8f5f4942b4e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method checks if L3 checksums of received packets in managed receive event batch are ok.  <a href="group__DOCA__ETH__RXQ__CPU__DATA__PATH.html#ga53c52132cb1a3373557d8f5f4942b4e2">More...</a><br /></td></tr>
<tr class="separator:ga53c52132cb1a3373557d8f5f4942b4e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8dfd171dd905c6e79c80eec4b9285e12"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ETH__RXQ__CPU__DATA__PATH.html#ga8dfd171dd905c6e79c80eec4b9285e12">doca_eth_rxq_task_recv_get_l4_ok</a> (const struct doca_eth_rxq_task_recv *task_recv, uint8_t *l4_ok)</td></tr>
<tr class="memdesc:ga8dfd171dd905c6e79c80eec4b9285e12"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method checks if L4 checksum of finished doca_eth_rxq_task_recv task is ok.  <a href="group__DOCA__ETH__RXQ__CPU__DATA__PATH.html#ga8dfd171dd905c6e79c80eec4b9285e12">More...</a><br /></td></tr>
<tr class="separator:ga8dfd171dd905c6e79c80eec4b9285e12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c434e35c40cf951fe10283795683b46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ETH__RXQ__CPU__DATA__PATH.html#ga3c434e35c40cf951fe10283795683b46">doca_eth_rxq_event_managed_recv_get_l4_ok</a> (const struct doca_eth_rxq_event_managed_recv *event_managed_recv, uint8_t *l4_ok)</td></tr>
<tr class="memdesc:ga3c434e35c40cf951fe10283795683b46"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method checks if L4 checksum of finished doca_eth_rxq_event_managed_recv event is ok.  <a href="group__DOCA__ETH__RXQ__CPU__DATA__PATH.html#ga3c434e35c40cf951fe10283795683b46">More...</a><br /></td></tr>
<tr class="separator:ga3c434e35c40cf951fe10283795683b46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40b90332cbb3a04e59184b485ead26ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ETH__RXQ__CPU__DATA__PATH.html#ga40b90332cbb3a04e59184b485ead26ae">doca_eth_rxq_event_batch_managed_recv_get_l4_ok_array</a> (const struct doca_eth_rxq_event_batch_managed_recv *event_batch_managed_recv, const uint8_t **l4_ok_array)</td></tr>
<tr class="memdesc:ga40b90332cbb3a04e59184b485ead26ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method checks if L4 checksums of received packets in managed receive event batch are ok.  <a href="group__DOCA__ETH__RXQ__CPU__DATA__PATH.html#ga40b90332cbb3a04e59184b485ead26ae">More...</a><br /></td></tr>
<tr class="separator:ga40b90332cbb3a04e59184b485ead26ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab08cd1f7d079e5cac192653ad0c00af7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ETH__RXQ__CPU__DATA__PATH.html#gab08cd1f7d079e5cac192653ad0c00af7">doca_eth_rxq_task_recv_get_metadata_array</a> (const struct doca_eth_rxq_task_recv *task_recv, const uint32_t **metadata_array)</td></tr>
<tr class="memdesc:gab08cd1f7d079e5cac192653ad0c00af7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method gets metadata array for the packet received by receive task.  <a href="group__DOCA__ETH__RXQ__CPU__DATA__PATH.html#gab08cd1f7d079e5cac192653ad0c00af7">More...</a><br /></td></tr>
<tr class="separator:gab08cd1f7d079e5cac192653ad0c00af7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga516b100095ce7a72c3e19931ad9a8e66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ETH__RXQ__CPU__DATA__PATH.html#ga516b100095ce7a72c3e19931ad9a8e66">doca_eth_rxq_event_managed_recv_get_metadata_array</a> (const struct doca_eth_rxq_event_managed_recv *event_managed_recv, const uint32_t **metadata_array)</td></tr>
<tr class="memdesc:ga516b100095ce7a72c3e19931ad9a8e66"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method gets metadata array for the packet received by managed receive event.  <a href="group__DOCA__ETH__RXQ__CPU__DATA__PATH.html#ga516b100095ce7a72c3e19931ad9a8e66">More...</a><br /></td></tr>
<tr class="separator:ga516b100095ce7a72c3e19931ad9a8e66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga273481c79df5df09e49b93c613cb8b0f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ETH__RXQ__CPU__DATA__PATH.html#ga273481c79df5df09e49b93c613cb8b0f">doca_eth_rxq_event_batch_managed_recv_get_metadata_array</a> (const struct doca_eth_rxq_event_batch_managed_recv *event_batch_managed_recv, const uint32_t **metadata_array)</td></tr>
<tr class="memdesc:ga273481c79df5df09e49b93c613cb8b0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method gets metadata array for the packet received by managed receive event batch.  <a href="group__DOCA__ETH__RXQ__CPU__DATA__PATH.html#ga273481c79df5df09e49b93c613cb8b0f">More...</a><br /></td></tr>
<tr class="separator:ga273481c79df5df09e49b93c613cb8b0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga126430f407167a1c2d9015c0be4034d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ETH__RXQ__CPU__DATA__PATH.html#ga126430f407167a1c2d9015c0be4034d2">doca_eth_rxq_task_recv_get_flow_tag</a> (const struct doca_eth_rxq_task_recv *task_recv, uint32_t *flow_tag)</td></tr>
<tr class="memdesc:ga126430f407167a1c2d9015c0be4034d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method gets the flow tag of a finished receive task.  <a href="group__DOCA__ETH__RXQ__CPU__DATA__PATH.html#ga126430f407167a1c2d9015c0be4034d2">More...</a><br /></td></tr>
<tr class="separator:ga126430f407167a1c2d9015c0be4034d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga975ab0d2ff4aa156911b8be5451c5ead"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ETH__RXQ__CPU__DATA__PATH.html#ga975ab0d2ff4aa156911b8be5451c5ead">doca_eth_rxq_event_managed_recv_get_flow_tag</a> (const struct doca_eth_rxq_event_managed_recv *event_managed_recv, uint32_t *flow_tag)</td></tr>
<tr class="memdesc:ga975ab0d2ff4aa156911b8be5451c5ead"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method gets the flow tag of a managed receive event.  <a href="group__DOCA__ETH__RXQ__CPU__DATA__PATH.html#ga975ab0d2ff4aa156911b8be5451c5ead">More...</a><br /></td></tr>
<tr class="separator:ga975ab0d2ff4aa156911b8be5451c5ead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga545bea91ae65a38ddeb5162bbbb0ce54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ETH__RXQ__CPU__DATA__PATH.html#ga545bea91ae65a38ddeb5162bbbb0ce54">doca_eth_rxq_event_batch_managed_recv_get_flow_tag_array</a> (const struct doca_eth_rxq_event_batch_managed_recv *event_batch_managed_recv, const uint32_t **flow_tag_array)</td></tr>
<tr class="memdesc:ga545bea91ae65a38ddeb5162bbbb0ce54"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method gets the flow tag array of a managed receive event batch.  <a href="group__DOCA__ETH__RXQ__CPU__DATA__PATH.html#ga545bea91ae65a38ddeb5162bbbb0ce54">More...</a><br /></td></tr>
<tr class="separator:ga545bea91ae65a38ddeb5162bbbb0ce54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad02d9496a09744d2bb413f40aba43ff9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ETH__RXQ__CPU__DATA__PATH.html#gad02d9496a09744d2bb413f40aba43ff9">doca_eth_rxq_task_recv_get_rx_hash</a> (const struct doca_eth_rxq_task_recv *task_recv, uint32_t *rx_hash)</td></tr>
<tr class="memdesc:gad02d9496a09744d2bb413f40aba43ff9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method gets the RX hash of a finished receive task.  <a href="group__DOCA__ETH__RXQ__CPU__DATA__PATH.html#gad02d9496a09744d2bb413f40aba43ff9">More...</a><br /></td></tr>
<tr class="separator:gad02d9496a09744d2bb413f40aba43ff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga961d78ec6eb729accba9fef85d14409a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ETH__RXQ__CPU__DATA__PATH.html#ga961d78ec6eb729accba9fef85d14409a">doca_eth_rxq_event_managed_recv_get_rx_hash</a> (const struct doca_eth_rxq_event_managed_recv *event_managed_recv, uint32_t *rx_hash)</td></tr>
<tr class="memdesc:ga961d78ec6eb729accba9fef85d14409a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method gets the RX hash of a managed receive event.  <a href="group__DOCA__ETH__RXQ__CPU__DATA__PATH.html#ga961d78ec6eb729accba9fef85d14409a">More...</a><br /></td></tr>
<tr class="separator:ga961d78ec6eb729accba9fef85d14409a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaddbc415d07378ba0318165a11297963a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ETH__RXQ__CPU__DATA__PATH.html#gaddbc415d07378ba0318165a11297963a">doca_eth_rxq_event_batch_managed_recv_get_rx_hash_array</a> (const struct doca_eth_rxq_event_batch_managed_recv *event_batch_managed_recv, const uint32_t **rx_hash_array)</td></tr>
<tr class="memdesc:gaddbc415d07378ba0318165a11297963a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method gets the RX hash array of a managed receive event batch.  <a href="group__DOCA__ETH__RXQ__CPU__DATA__PATH.html#gaddbc415d07378ba0318165a11297963a">More...</a><br /></td></tr>
<tr class="separator:gaddbc415d07378ba0318165a11297963a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac71c985a3491e3b65899dad1da8a5650"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ETH__RXQ__CPU__DATA__PATH.html#gac71c985a3491e3b65899dad1da8a5650">doca_eth_rxq_task_recv_get_timestamp</a> (const struct doca_eth_rxq_task_recv *task_recv, uint64_t *<a class="el" href="telemetry__export__sample_8c.html#a606aa1ee160bd75a5ca9129ae61c51ba">timestamp</a>)</td></tr>
<tr class="memdesc:gac71c985a3491e3b65899dad1da8a5650"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method gets the timestamp of a finished receive task.  <a href="group__DOCA__ETH__RXQ__CPU__DATA__PATH.html#gac71c985a3491e3b65899dad1da8a5650">More...</a><br /></td></tr>
<tr class="separator:gac71c985a3491e3b65899dad1da8a5650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0330b7e5dedb1f75df5d1e20d36f01af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ETH__RXQ__CPU__DATA__PATH.html#ga0330b7e5dedb1f75df5d1e20d36f01af">doca_eth_rxq_event_managed_recv_get_timestamp</a> (const struct doca_eth_rxq_event_managed_recv *event_managed_recv, uint64_t *<a class="el" href="telemetry__export__sample_8c.html#a606aa1ee160bd75a5ca9129ae61c51ba">timestamp</a>)</td></tr>
<tr class="memdesc:ga0330b7e5dedb1f75df5d1e20d36f01af"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method gets the timestamp of a managed receive event.  <a href="group__DOCA__ETH__RXQ__CPU__DATA__PATH.html#ga0330b7e5dedb1f75df5d1e20d36f01af">More...</a><br /></td></tr>
<tr class="separator:ga0330b7e5dedb1f75df5d1e20d36f01af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a25aabba362d7fcabc6ba6788e44300"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ETH__RXQ__CPU__DATA__PATH.html#ga5a25aabba362d7fcabc6ba6788e44300">doca_eth_rxq_event_batch_managed_recv_get_timestamp_array</a> (const struct doca_eth_rxq_event_batch_managed_recv *event_batch_managed_recv, const uint64_t **timestamp_array)</td></tr>
<tr class="memdesc:ga5a25aabba362d7fcabc6ba6788e44300"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method gets the timestamp array of a managed receive event batch.  <a href="group__DOCA__ETH__RXQ__CPU__DATA__PATH.html#ga5a25aabba362d7fcabc6ba6788e44300">More...</a><br /></td></tr>
<tr class="separator:ga5a25aabba362d7fcabc6ba6788e44300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19f60c6c05eda426cd07f1f1e319724c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ETH__RXQ__CPU__DATA__PATH.html#ga19f60c6c05eda426cd07f1f1e319724c">doca_eth_rxq_event_managed_recv_get_status</a> (const struct doca_eth_rxq_event_managed_recv *event_managed_recv)</td></tr>
<tr class="memdesc:ga19f60c6c05eda426cd07f1f1e319724c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method gets status of finished doca_eth_rxq_event_managed_recv event.  <a href="group__DOCA__ETH__RXQ__CPU__DATA__PATH.html#ga19f60c6c05eda426cd07f1f1e319724c">More...</a><br /></td></tr>
<tr class="separator:ga19f60c6c05eda426cd07f1f1e319724c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e40e7c070af8ff20e0bcc0309f217bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ETH__RXQ__CPU__DATA__PATH.html#ga4e40e7c070af8ff20e0bcc0309f217bb">doca_eth_rxq_event_batch_managed_recv_pkt_array_free</a> (struct doca_buf **pkt_array)</td></tr>
<tr class="memdesc:ga4e40e7c070af8ff20e0bcc0309f217bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method frees the packet array acquired using managed receive event batch and returns it to the ownership of the library. This function is an optimized approach of freeing packets returned from a single managed receive event batch. User should free the packets returned from a single event batch either by calling <a class="el" href="group__DOCA__BUF.html#ga1dac3c119cb35434e4e4c92deffb713d" title="Decrease the object reference count by 1, if 0 reached, return the element back to the inventory.">doca_buf_dec_refcount()</a> per packet or calling this function with the original pkt_array returned in the CB. User can't mix both approaches per event batch (but can on different event batches).  <a href="group__DOCA__ETH__RXQ__CPU__DATA__PATH.html#ga4e40e7c070af8ff20e0bcc0309f217bb">More...</a><br /></td></tr>
<tr class="separator:ga4e40e7c070af8ff20e0bcc0309f217bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab13ba584843b8eca881a48434221523f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> struct doca_ctx *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ETH__RXQ__CPU__DATA__PATH.html#gab13ba584843b8eca881a48434221523f">doca_eth_rxq_event_managed_recv_get_ctx</a> (const struct doca_eth_rxq_event_managed_recv *event_managed_recv)</td></tr>
<tr class="memdesc:gab13ba584843b8eca881a48434221523f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method gets context of finished doca_eth_rxq_event_managed_recv event.  <a href="group__DOCA__ETH__RXQ__CPU__DATA__PATH.html#gab13ba584843b8eca881a48434221523f">More...</a><br /></td></tr>
<tr class="separator:gab13ba584843b8eca881a48434221523f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2eac630251ccaff744d9626aaa126a11"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> struct doca_ctx *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ETH__RXQ__CPU__DATA__PATH.html#ga2eac630251ccaff744d9626aaa126a11">doca_eth_rxq_event_batch_managed_recv_get_ctx</a> (const struct doca_eth_rxq_event_batch_managed_recv *event_batch_managed_recv)</td></tr>
<tr class="memdesc:ga2eac630251ccaff744d9626aaa126a11"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method gets context of finished doca_eth_rxq_event_batch_managed_recv event.  <a href="group__DOCA__ETH__RXQ__CPU__DATA__PATH.html#ga2eac630251ccaff744d9626aaa126a11">More...</a><br /></td></tr>
<tr class="separator:ga2eac630251ccaff744d9626aaa126a11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad56217638fa7f9273c01615d182168e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> struct doca_task *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ETH__RXQ__CPU__DATA__PATH.html#gad56217638fa7f9273c01615d182168e8">doca_eth_rxq_task_recv_as_doca_task</a> (struct doca_eth_rxq_task_recv *task_recv)</td></tr>
<tr class="memdesc:gad56217638fa7f9273c01615d182168e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method converts a doca_eth_rxq_task_recv task to doca_task.  <a href="group__DOCA__ETH__RXQ__CPU__DATA__PATH.html#gad56217638fa7f9273c01615d182168e8">More...</a><br /></td></tr>
<tr class="separator:gad56217638fa7f9273c01615d182168e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>DOCA ETH RXQ library. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gae92a34197b69d122717ad53361d6f6fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae92a34197b69d122717ad53361d6f6fc">&#9670;&nbsp;</a></span>doca_eth_rxq_event_batch_managed_recv_metadata_array_get_metadata</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define doca_eth_rxq_event_batch_managed_recv_metadata_array_get_metadata</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">metadata_array, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">metadata_num, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">packet_index, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">metadata_index&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;	metadata_array[packet_index * metadata_num + metadata_index]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This MACRO is used to get a specific metadata of a specific packet from metadata_array from managed receive event batch. </p>
<dl class="section note"><dt>Note</dt><dd>Supported for DOCA ETH RXQ instance for CPU only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">metadata_array</td><td>Metadata array returned from managed receive event batch. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">metadata_num</td><td>Metadata number that was set by "doca_eth_rxq_set_metadata_num()". </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">packet_index</td><td>Index of the packet to get its metadata. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">metadata_index</td><td>Index of metadata to get.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>requested metadata </dd></dl>

<p class="definition">Definition at line <a class="el" href="doca__eth__rxq__cpu__data__path_8h_source.html#l00676">676</a> of file <a class="el" href="doca__eth__rxq__cpu__data__path_8h_source.html">doca_eth_rxq_cpu_data_path.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga89c6241485d1c000c89e7dbc620d8265"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga89c6241485d1c000c89e7dbc620d8265">&#9670;&nbsp;</a></span>doca_eth_rxq_event_batch_managed_recv_handler_cb_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* doca_eth_rxq_event_batch_managed_recv_handler_cb_t) (struct doca_eth_rxq_event_batch_managed_recv *event_batch_managed_recv, uint16_t events_number, union <a class="el" href="uniondoca__data.html">doca_data</a> event_batch_user_data, <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> status, struct doca_buf **pkt_array)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to be executed on managed receive event batch occurrence. </p>
<dl class="section note"><dt>Note</dt><dd>The packet buffers returned are valid as long as they weren't freed by the user. Holding the buffers for a long period of time might block receiving incoming packets as mentioned above for the DOCA_ETH_RXQ_TYPE_MANAGED_MEMPOOL type.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event_batch_managed_recv</td><td>The managed receive event batch. The implementation can assume this value is not NULL. It's valid only during the CB. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">events_number</td><td>Number of retrieved events, each representing a received packet (0 in case of error callback). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">event_batch_user_data</td><td>user_data attached to the event batch. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">status</td><td>Status of retrieved event batch. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pkt_array</td><td>Array of doca_bufs containing the received packets (NULL in case of error callback). Notes:<ul>
<li>This buffer array is valid until the user returns it to the context.</li>
<li>User can't use <a class="el" href="group__DOCA__BUF__INVENTORY.html#ga5604ad0838508ceed481fe3e18e1a2a2" title="Duplicates content of the buf argument into element allocated from buffer inventory....">doca_buf_inventory_buf_dup()</a> on these buffers. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="doca__eth__rxq__cpu__data__path_8h_source.html#l00137">137</a> of file <a class="el" href="doca__eth__rxq__cpu__data__path_8h_source.html">doca_eth_rxq_cpu_data_path.h</a>.</p>

</div>
</div>
<a id="ga9f3f2861ec1aed76a4604903c20f3327"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f3f2861ec1aed76a4604903c20f3327">&#9670;&nbsp;</a></span>doca_eth_rxq_event_managed_recv_handler_cb_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* doca_eth_rxq_event_managed_recv_handler_cb_t) (struct doca_eth_rxq_event_managed_recv *event_managed_recv, struct doca_buf *pkt, union <a class="el" href="uniondoca__data.html">doca_data</a> event_user_data)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to be executed on managed receive event occurrence. </p>
<dl class="section note"><dt>Note</dt><dd>The packet buffer returned is valid as long as it wasn't freed by the user. Holding the buffer for a long period of time might block receiving incoming packets as mentioned above for the DOCA_ETH_RXQ_TYPE_MANAGED_MEMPOOL type.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event_managed_recv</td><td>The managed receive event. The implementation can assume this value is not NULL. It's valid only during the CB. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pkt</td><td>doca_buf containing the received packet (NULL in case of error callback). Notes:<ul>
<li>This buffer is valid until the user returns it to the context.</li>
<li>User can't use r <a class="el" href="group__DOCA__BUF__INVENTORY.html#ga5604ad0838508ceed481fe3e18e1a2a2" title="Duplicates content of the buf argument into element allocated from buffer inventory....">doca_buf_inventory_buf_dup()</a> on this buffer. </li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">event_user_data</td><td>user_data attached to the event. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="doca__eth__rxq__cpu__data__path_8h_source.html#l00111">111</a> of file <a class="el" href="doca__eth__rxq__cpu__data__path_8h_source.html">doca_eth_rxq_cpu_data_path.h</a>.</p>

</div>
</div>
<a id="gaa2486a6e6e96c83cc4534ae7d0e81486"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa2486a6e6e96c83cc4534ae7d0e81486">&#9670;&nbsp;</a></span>doca_eth_rxq_task_recv_completion_cb_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* doca_eth_rxq_task_recv_completion_cb_t) (struct doca_eth_rxq_task_recv *task_recv, union <a class="el" href="uniondoca__data.html">doca_data</a> task_user_data, union <a class="el" href="uniondoca__data.html">doca_data</a> ctx_user_data)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to execute on task completion. </p>
<p>DOCA ETH RXQ event batch for receiving multiple packets. Supported in DOCA_ETH_RXQ_TYPE_MANAGED_MEMPOOL mode.</p>
<p>This function is called by <a class="el" href="group__DOCA__PE.html#ga9a0e5d8d7a584dcc3db5c612875887cb" title="Run the progress engine.">doca_pe_progress()</a> when related task identified as completed successfully. When this function called the ownership of the task object passed from DOCA back to user. Inside this callback user may decide on the task object:</p><ul>
<li>re-submit task with <a class="el" href="group__DOCA__PE.html#ga632e751030cb01805462495099773776" title="Submit a task to a progress engine.">doca_task_submit()</a>; task object ownership passed to DOCA</li>
<li>release task with <a class="el" href="group__DOCA__PE.html#gae916a784f1e4119ded756ab1253abbed" title="Free a task back to where it was allocated from.">doca_task_free()</a>; task object ownership passed to DOCA</li>
<li>keep the task object for future re-use; user keeps the ownership on the task object Inside this callback the user shouldn't call <a class="el" href="group__DOCA__PE.html#ga9a0e5d8d7a584dcc3db5c612875887cb" title="Run the progress engine.">doca_pe_progress()</a>. Any failure/error inside this function should be handled internally or differed; due to the mode of nested in <a class="el" href="group__DOCA__PE.html#ga9a0e5d8d7a584dcc3db5c612875887cb" title="Run the progress engine.">doca_pe_progress()</a> execution this callback doesn't return error.</li>
</ul>
<p>NOTE: this callback type utilized successful &amp; failed task completions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task_recv</td><td>The successfully completed task. The implementation can assume this value is not NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">task_user_data</td><td>user_data attached to the task. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx_user_data</td><td>user_data attached to the ctx. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="doca__eth__rxq__cpu__data__path_8h_source.html#l00089">89</a> of file <a class="el" href="doca__eth__rxq__cpu__data__path_8h_source.html">doca_eth_rxq_cpu_data_path.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga2eac630251ccaff744d9626aaa126a11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2eac630251ccaff744d9626aaa126a11">&#9670;&nbsp;</a></span>doca_eth_rxq_event_batch_managed_recv_get_ctx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> struct doca_ctx* doca_eth_rxq_event_batch_managed_recv_get_ctx </td>
          <td>(</td>
          <td class="paramtype">const struct doca_eth_rxq_event_batch_managed_recv *&#160;</td>
          <td class="paramname"><em>event_batch_managed_recv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method gets context of finished doca_eth_rxq_event_batch_managed_recv event. </p>
<dl class="section note"><dt>Note</dt><dd>Supported for DOCA ETH RXQ instance for CPU only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event_batch_managed_recv</td><td>The event to get the context from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>doca_ctx - the context associated with the event batch. </dd></dl>

</div>
</div>
<a id="ga545bea91ae65a38ddeb5162bbbb0ce54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga545bea91ae65a38ddeb5162bbbb0ce54">&#9670;&nbsp;</a></span>doca_eth_rxq_event_batch_managed_recv_get_flow_tag_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_eth_rxq_event_batch_managed_recv_get_flow_tag_array </td>
          <td>(</td>
          <td class="paramtype">const struct doca_eth_rxq_event_batch_managed_recv *&#160;</td>
          <td class="paramname"><em>event_batch_managed_recv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t **&#160;</td>
          <td class="paramname"><em>flow_tag_array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method gets the flow tag array of a managed receive event batch. </p>
<dl class="section note"><dt>Note</dt><dd>Supported for DOCA ETH RXQ instance for CPU only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event_batch_managed_recv</td><td>The event batch to get from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">flow_tag_array</td><td>Array of flow tag per packet to get. Array is valid only during the CB.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - in case one of the arguments is NULL. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga53c52132cb1a3373557d8f5f4942b4e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga53c52132cb1a3373557d8f5f4942b4e2">&#9670;&nbsp;</a></span>doca_eth_rxq_event_batch_managed_recv_get_l3_ok_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_eth_rxq_event_batch_managed_recv_get_l3_ok_array </td>
          <td>(</td>
          <td class="paramtype">const struct doca_eth_rxq_event_batch_managed_recv *&#160;</td>
          <td class="paramname"><em>event_batch_managed_recv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t **&#160;</td>
          <td class="paramname"><em>l3_ok_array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method checks if L3 checksums of received packets in managed receive event batch are ok. </p>
<dl class="section note"><dt>Note</dt><dd>Supported for DOCA ETH RXQ instance for CPU only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event_batch_managed_recv</td><td>The event batch to get from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">l3_ok_array</td><td>Array of indicators for whether L3 checksum is ok or not per packet. Array is valid only during the CB.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - in case one of the arguments is NULL. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga40b90332cbb3a04e59184b485ead26ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga40b90332cbb3a04e59184b485ead26ae">&#9670;&nbsp;</a></span>doca_eth_rxq_event_batch_managed_recv_get_l4_ok_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_eth_rxq_event_batch_managed_recv_get_l4_ok_array </td>
          <td>(</td>
          <td class="paramtype">const struct doca_eth_rxq_event_batch_managed_recv *&#160;</td>
          <td class="paramname"><em>event_batch_managed_recv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t **&#160;</td>
          <td class="paramname"><em>l4_ok_array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method checks if L4 checksums of received packets in managed receive event batch are ok. </p>
<dl class="section note"><dt>Note</dt><dd>Supported for DOCA ETH RXQ instance for CPU only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event_batch_managed_recv</td><td>The event batch to get from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">l4_ok_array</td><td>Array of indicators for whether L4 checksum is ok or not per packet. Array is valid only during the CB.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - in case one of the arguments is NULL. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga273481c79df5df09e49b93c613cb8b0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga273481c79df5df09e49b93c613cb8b0f">&#9670;&nbsp;</a></span>doca_eth_rxq_event_batch_managed_recv_get_metadata_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_eth_rxq_event_batch_managed_recv_get_metadata_array </td>
          <td>(</td>
          <td class="paramtype">const struct doca_eth_rxq_event_batch_managed_recv *&#160;</td>
          <td class="paramname"><em>event_batch_managed_recv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t **&#160;</td>
          <td class="paramname"><em>metadata_array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method gets metadata array for the packet received by managed receive event batch. </p>
<dl class="section note"><dt>Note</dt><dd>Supported for DOCA ETH RXQ instance for CPU only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event_batch_managed_recv</td><td>The event batch to get from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">metadata_array</td><td>Array of metadata for the received packet. Array is valid only during the CB. Its length is metadata_num (set by "doca_eth_rxq_set_metadata_num()") * number of received packets in the event batch. See "doca_eth_rxq_event_batch_managed_recv_metadata_array_get_metadata()".</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - in case one of the arguments is NULL. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaddbc415d07378ba0318165a11297963a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaddbc415d07378ba0318165a11297963a">&#9670;&nbsp;</a></span>doca_eth_rxq_event_batch_managed_recv_get_rx_hash_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_eth_rxq_event_batch_managed_recv_get_rx_hash_array </td>
          <td>(</td>
          <td class="paramtype">const struct doca_eth_rxq_event_batch_managed_recv *&#160;</td>
          <td class="paramname"><em>event_batch_managed_recv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t **&#160;</td>
          <td class="paramname"><em>rx_hash_array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method gets the RX hash array of a managed receive event batch. </p>
<dl class="section note"><dt>Note</dt><dd>Supported for DOCA ETH RXQ instance for CPU only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event_batch_managed_recv</td><td>The event batch to get from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rx_hash_array</td><td>Array of RX hash per packet to get. Array is valid only during the CB.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - in case one of the arguments is NULL. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga5a25aabba362d7fcabc6ba6788e44300"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a25aabba362d7fcabc6ba6788e44300">&#9670;&nbsp;</a></span>doca_eth_rxq_event_batch_managed_recv_get_timestamp_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_eth_rxq_event_batch_managed_recv_get_timestamp_array </td>
          <td>(</td>
          <td class="paramtype">const struct doca_eth_rxq_event_batch_managed_recv *&#160;</td>
          <td class="paramname"><em>event_batch_managed_recv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t **&#160;</td>
          <td class="paramname"><em>timestamp_array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method gets the timestamp array of a managed receive event batch. </p>
<dl class="section note"><dt>Note</dt><dd>Supported for DOCA ETH RXQ instance for CPU only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event_batch_managed_recv</td><td>The event batch to get from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">timestamp_array</td><td>Array of timestamp in nanoseconds per packet to get. Array is valid only during the CB.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - in case one of the arguments is NULL. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga4e40e7c070af8ff20e0bcc0309f217bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4e40e7c070af8ff20e0bcc0309f217bb">&#9670;&nbsp;</a></span>doca_eth_rxq_event_batch_managed_recv_pkt_array_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> void doca_eth_rxq_event_batch_managed_recv_pkt_array_free </td>
          <td>(</td>
          <td class="paramtype">struct doca_buf **&#160;</td>
          <td class="paramname"><em>pkt_array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method frees the packet array acquired using managed receive event batch and returns it to the ownership of the library. This function is an optimized approach of freeing packets returned from a single managed receive event batch. User should free the packets returned from a single event batch either by calling <a class="el" href="group__DOCA__BUF.html#ga1dac3c119cb35434e4e4c92deffb713d" title="Decrease the object reference count by 1, if 0 reached, return the element back to the inventory.">doca_buf_dec_refcount()</a> per packet or calling this function with the original pkt_array returned in the CB. User can't mix both approaches per event batch (but can on different event batches). </p>
<dl class="section note"><dt>Note</dt><dd>Supported for DOCA ETH RXQ instance for CPU only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pkt_array</td><td>The packet array acquired using managed receive event batch. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaead983a8354e4a7799569367a76130e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaead983a8354e4a7799569367a76130e0">&#9670;&nbsp;</a></span>doca_eth_rxq_event_batch_managed_recv_register()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_eth_rxq_event_batch_managed_recv_register </td>
          <td>(</td>
          <td class="paramtype">struct doca_eth_rxq *&#160;</td>
          <td class="paramname"><em>eth_rxq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__DOCA__PE.html#gae634a249acf0a42464e587f76d766e8b">doca_event_batch_events_number</a>&#160;</td>
          <td class="paramname"><em>events_number_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__DOCA__PE.html#gae634a249acf0a42464e587f76d766e8b">doca_event_batch_events_number</a>&#160;</td>
          <td class="paramname"><em>events_number_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">union <a class="el" href="uniondoca__data.html">doca_data</a>&#160;</td>
          <td class="paramname"><em>user_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DOCA__ETH__RXQ__CPU__DATA__PATH.html#ga89c6241485d1c000c89e7dbc620d8265">doca_eth_rxq_event_batch_managed_recv_handler_cb_t</a>&#160;</td>
          <td class="paramname"><em>success_event_batch_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DOCA__ETH__RXQ__CPU__DATA__PATH.html#ga89c6241485d1c000c89e7dbc620d8265">doca_eth_rxq_event_batch_managed_recv_handler_cb_t</a>&#160;</td>
          <td class="paramname"><em>error_event_batch_handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method registers a doca_eth_rxq_event_managed_recv event batch. Allows user to get multiple event completions with one callback. can only be called before calling <a class="el" href="group__DOCA__CTX.html#ga712a2c32ab9113f568d08c379ec506f7" title="Finalizes all configurations, and starts the DOCA CTX.">doca_ctx_start()</a>. </p>
<dl class="section note"><dt>Note</dt><dd>Supported for DOCA ETH RXQ instance for CPU only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">eth_rxq</td><td>Pointer to doca_eth_rxq instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">events_number_max</td><td>Maximum number of completed events per callback. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">events_number_min</td><td>Minimum number of completed events per callback. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user_data</td><td><a class="el" href="uniondoca__data.html" title="Convenience type for representing opaque data.">doca_data</a> to attach to the event batch. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">success_event_batch_handler</td><td>Method that is invoked once a successful event batch is triggered </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">error_event_batch_handler</td><td>Method that is invoked once an error event batch is triggered</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - in case one of the arguments is NULL.</li>
<li>DOCA_ERROR_BAD_STATE - eth_rxq context state is not idle. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gab13ba584843b8eca881a48434221523f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab13ba584843b8eca881a48434221523f">&#9670;&nbsp;</a></span>doca_eth_rxq_event_managed_recv_get_ctx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> struct doca_ctx* doca_eth_rxq_event_managed_recv_get_ctx </td>
          <td>(</td>
          <td class="paramtype">const struct doca_eth_rxq_event_managed_recv *&#160;</td>
          <td class="paramname"><em>event_managed_recv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method gets context of finished doca_eth_rxq_event_managed_recv event. </p>
<dl class="section note"><dt>Note</dt><dd>Supported for DOCA ETH RXQ instance for CPU only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event_managed_recv</td><td>The event to get the context from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>doca_ctx - the context associated with the event. </dd></dl>

</div>
</div>
<a id="ga975ab0d2ff4aa156911b8be5451c5ead"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga975ab0d2ff4aa156911b8be5451c5ead">&#9670;&nbsp;</a></span>doca_eth_rxq_event_managed_recv_get_flow_tag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_eth_rxq_event_managed_recv_get_flow_tag </td>
          <td>(</td>
          <td class="paramtype">const struct doca_eth_rxq_event_managed_recv *&#160;</td>
          <td class="paramname"><em>event_managed_recv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>flow_tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method gets the flow tag of a managed receive event. </p>
<dl class="section note"><dt>Note</dt><dd>Supported for DOCA ETH RXQ instance for CPU only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event_managed_recv</td><td>The event to get from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">flow_tag</td><td>flow tag to get.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - in case one of the arguments is NULL. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gab776ce2397ae8cad2b67ba545171a557"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab776ce2397ae8cad2b67ba545171a557">&#9670;&nbsp;</a></span>doca_eth_rxq_event_managed_recv_get_l3_ok()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_eth_rxq_event_managed_recv_get_l3_ok </td>
          <td>(</td>
          <td class="paramtype">const struct doca_eth_rxq_event_managed_recv *&#160;</td>
          <td class="paramname"><em>event_managed_recv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>l3_ok</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method checks if L3 checksum of finished doca_eth_rxq_event_managed_recv event is ok. </p>
<dl class="section note"><dt>Note</dt><dd>Supported for DOCA ETH RXQ instance for CPU only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event_managed_recv</td><td>The event to get from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">l3_ok</td><td>Indicator whether L3 checksum is ok or not.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - in case one of the arguments is NULL. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga3c434e35c40cf951fe10283795683b46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c434e35c40cf951fe10283795683b46">&#9670;&nbsp;</a></span>doca_eth_rxq_event_managed_recv_get_l4_ok()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_eth_rxq_event_managed_recv_get_l4_ok </td>
          <td>(</td>
          <td class="paramtype">const struct doca_eth_rxq_event_managed_recv *&#160;</td>
          <td class="paramname"><em>event_managed_recv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>l4_ok</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method checks if L4 checksum of finished doca_eth_rxq_event_managed_recv event is ok. </p>
<dl class="section note"><dt>Note</dt><dd>Supported for DOCA ETH RXQ instance for CPU only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event_managed_recv</td><td>The event to get from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">l4_ok</td><td>Indicator whether L4 checksum is ok or not.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - in case one of the arguments is NULL. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga516b100095ce7a72c3e19931ad9a8e66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga516b100095ce7a72c3e19931ad9a8e66">&#9670;&nbsp;</a></span>doca_eth_rxq_event_managed_recv_get_metadata_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_eth_rxq_event_managed_recv_get_metadata_array </td>
          <td>(</td>
          <td class="paramtype">const struct doca_eth_rxq_event_managed_recv *&#160;</td>
          <td class="paramname"><em>event_managed_recv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t **&#160;</td>
          <td class="paramname"><em>metadata_array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method gets metadata array for the packet received by managed receive event. </p>
<dl class="section note"><dt>Note</dt><dd>Supported for DOCA ETH RXQ instance for CPU only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event_managed_recv</td><td>The event to get from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">metadata_array</td><td>Array of metadata for the received packet. Its length is metadata_num (set by "doca_eth_rxq_set_metadata_num()").</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - in case one of the arguments is NULL. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga961d78ec6eb729accba9fef85d14409a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga961d78ec6eb729accba9fef85d14409a">&#9670;&nbsp;</a></span>doca_eth_rxq_event_managed_recv_get_rx_hash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_eth_rxq_event_managed_recv_get_rx_hash </td>
          <td>(</td>
          <td class="paramtype">const struct doca_eth_rxq_event_managed_recv *&#160;</td>
          <td class="paramname"><em>event_managed_recv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>rx_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method gets the RX hash of a managed receive event. </p>
<dl class="section note"><dt>Note</dt><dd>Supported for DOCA ETH RXQ instance for CPU only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event_managed_recv</td><td>The event to get from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rx_hash</td><td>RX hash to get.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - in case one of the arguments is NULL. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga19f60c6c05eda426cd07f1f1e319724c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga19f60c6c05eda426cd07f1f1e319724c">&#9670;&nbsp;</a></span>doca_eth_rxq_event_managed_recv_get_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_eth_rxq_event_managed_recv_get_status </td>
          <td>(</td>
          <td class="paramtype">const struct doca_eth_rxq_event_managed_recv *&#160;</td>
          <td class="paramname"><em>event_managed_recv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method gets status of finished doca_eth_rxq_event_managed_recv event. </p>
<dl class="section note"><dt>Note</dt><dd>Supported for DOCA ETH RXQ instance for CPU only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event_managed_recv</td><td>The event to get status from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. Any other doca_error_t indicates that the event failed (event depended) </dd></dl>

</div>
</div>
<a id="ga0330b7e5dedb1f75df5d1e20d36f01af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0330b7e5dedb1f75df5d1e20d36f01af">&#9670;&nbsp;</a></span>doca_eth_rxq_event_managed_recv_get_timestamp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_eth_rxq_event_managed_recv_get_timestamp </td>
          <td>(</td>
          <td class="paramtype">const struct doca_eth_rxq_event_managed_recv *&#160;</td>
          <td class="paramname"><em>event_managed_recv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>timestamp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method gets the timestamp of a managed receive event. </p>
<dl class="section note"><dt>Note</dt><dd>Supported for DOCA ETH RXQ instance for CPU only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event_managed_recv</td><td>The event to get from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">timestamp</td><td>Timestamp to get in nanoseconds.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - in case one of the arguments is NULL. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga418429fb52c5625da2311ebf01acbd8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga418429fb52c5625da2311ebf01acbd8f">&#9670;&nbsp;</a></span>doca_eth_rxq_event_managed_recv_register()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_eth_rxq_event_managed_recv_register </td>
          <td>(</td>
          <td class="paramtype">struct doca_eth_rxq *&#160;</td>
          <td class="paramname"><em>eth_rxq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">union <a class="el" href="uniondoca__data.html">doca_data</a>&#160;</td>
          <td class="paramname"><em>user_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DOCA__ETH__RXQ__CPU__DATA__PATH.html#ga9f3f2861ec1aed76a4604903c20f3327">doca_eth_rxq_event_managed_recv_handler_cb_t</a>&#160;</td>
          <td class="paramname"><em>success_event_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DOCA__ETH__RXQ__CPU__DATA__PATH.html#ga9f3f2861ec1aed76a4604903c20f3327">doca_eth_rxq_event_managed_recv_handler_cb_t</a>&#160;</td>
          <td class="paramname"><em>error_event_handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method registers a doca_eth_rxq_event_managed_recv event. can only be called before calling <a class="el" href="group__DOCA__CTX.html#ga712a2c32ab9113f568d08c379ec506f7" title="Finalizes all configurations, and starts the DOCA CTX.">doca_ctx_start()</a>. </p>
<dl class="section note"><dt>Note</dt><dd>Supported for DOCA ETH RXQ instance for CPU only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">eth_rxq</td><td>Pointer to doca_eth_rxq instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user_data</td><td><a class="el" href="uniondoca__data.html" title="Convenience type for representing opaque data.">doca_data</a> to attach to the event. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">success_event_handler</td><td>Method that is invoked once a successful event is triggered </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">error_event_handler</td><td>Method that is invoked once an error event is triggered</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - in case one of the arguments is NULL.</li>
<li>DOCA_ERROR_BAD_STATE - eth_rxq context state is not idle. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga133a3358f623e61da7f7507e4d0780bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga133a3358f623e61da7f7507e4d0780bc">&#9670;&nbsp;</a></span>doca_eth_rxq_task_recv_allocate_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_eth_rxq_task_recv_allocate_init </td>
          <td>(</td>
          <td class="paramtype">struct doca_eth_rxq *&#160;</td>
          <td class="paramname"><em>eth_rxq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct doca_buf *&#160;</td>
          <td class="paramname"><em>pkt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">union <a class="el" href="uniondoca__data.html">doca_data</a>&#160;</td>
          <td class="paramname"><em>user_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct doca_eth_rxq_task_recv **&#160;</td>
          <td class="paramname"><em>task_recv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method allocates and initializes a doca_eth_rxq_task_recv task. </p>
<dl class="section note"><dt>Note</dt><dd>Supported for DOCA ETH RXQ instance for CPU only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">eth_rxq</td><td>Pointer to doca_eth_rxq instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pkt</td><td>Buffer to receive packet. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user_data</td><td><a class="el" href="uniondoca__data.html" title="Convenience type for representing opaque data.">doca_data</a> to attach to the task. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">task_recv</td><td>doca_eth_rxq_task_recv task that was allocated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - in case one of the arguments is NULL.</li>
<li>DOCA_ERROR_NO_MEMORY - no more tasks to allocate.</li>
<li>DOCA_ERROR_BAD_STATE - eth_rxq context state is not running.</li>
<li>DOCA_ERROR_NOT_CONNECTED - in case eth_rxq is not is not connected to a DOCA Progress Engine.</li>
<li>DOCA_ERROR_NOT_SUPPORTED - in case eth_rxq is not an instance for CPU. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gad56217638fa7f9273c01615d182168e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad56217638fa7f9273c01615d182168e8">&#9670;&nbsp;</a></span>doca_eth_rxq_task_recv_as_doca_task()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> struct doca_task* doca_eth_rxq_task_recv_as_doca_task </td>
          <td>(</td>
          <td class="paramtype">struct doca_eth_rxq_task_recv *&#160;</td>
          <td class="paramname"><em>task_recv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method converts a doca_eth_rxq_task_recv task to doca_task. </p>
<dl class="section note"><dt>Note</dt><dd>Supported for DOCA ETH RXQ instance for CPU only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task_recv</td><td>doca_eth_rxq_task_recv task.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>doca_task </dd></dl>

</div>
</div>
<a id="ga126430f407167a1c2d9015c0be4034d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga126430f407167a1c2d9015c0be4034d2">&#9670;&nbsp;</a></span>doca_eth_rxq_task_recv_get_flow_tag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_eth_rxq_task_recv_get_flow_tag </td>
          <td>(</td>
          <td class="paramtype">const struct doca_eth_rxq_task_recv *&#160;</td>
          <td class="paramname"><em>task_recv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>flow_tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method gets the flow tag of a finished receive task. </p>
<dl class="section note"><dt>Note</dt><dd>Supported for DOCA ETH RXQ instance for CPU only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task_recv</td><td>The task to get from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">flow_tag</td><td>flow tag to get.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - in case one of the arguments is NULL. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gad12889cb149331ba71518c0c9fd71689"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad12889cb149331ba71518c0c9fd71689">&#9670;&nbsp;</a></span>doca_eth_rxq_task_recv_get_l3_ok()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_eth_rxq_task_recv_get_l3_ok </td>
          <td>(</td>
          <td class="paramtype">const struct doca_eth_rxq_task_recv *&#160;</td>
          <td class="paramname"><em>task_recv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>l3_ok</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method checks if L3 checksum of finished doca_eth_rxq_task_recv task is ok. </p>
<dl class="section note"><dt>Note</dt><dd>Supported for DOCA ETH RXQ instance for CPU only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task_recv</td><td>The task to get from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">l3_ok</td><td>Indicator whether L3 checksum is ok or not.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - in case one of the arguments is NULL. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga8dfd171dd905c6e79c80eec4b9285e12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8dfd171dd905c6e79c80eec4b9285e12">&#9670;&nbsp;</a></span>doca_eth_rxq_task_recv_get_l4_ok()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_eth_rxq_task_recv_get_l4_ok </td>
          <td>(</td>
          <td class="paramtype">const struct doca_eth_rxq_task_recv *&#160;</td>
          <td class="paramname"><em>task_recv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>l4_ok</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method checks if L4 checksum of finished doca_eth_rxq_task_recv task is ok. </p>
<dl class="section note"><dt>Note</dt><dd>Supported for DOCA ETH RXQ instance for CPU only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task_recv</td><td>The task to get from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">l4_ok</td><td>Indicator whether L4 checksum is ok or not.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - in case one of the arguments is NULL. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gab08cd1f7d079e5cac192653ad0c00af7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab08cd1f7d079e5cac192653ad0c00af7">&#9670;&nbsp;</a></span>doca_eth_rxq_task_recv_get_metadata_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_eth_rxq_task_recv_get_metadata_array </td>
          <td>(</td>
          <td class="paramtype">const struct doca_eth_rxq_task_recv *&#160;</td>
          <td class="paramname"><em>task_recv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t **&#160;</td>
          <td class="paramname"><em>metadata_array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method gets metadata array for the packet received by receive task. </p>
<dl class="section note"><dt>Note</dt><dd>Supported for DOCA ETH RXQ instance for CPU only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task_recv</td><td>The task to get from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">metadata_array</td><td>Array of metadata for the received packet. Its length is metadata_num (set by "doca_eth_rxq_set_metadata_num()").</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - in case one of the arguments is NULL. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga22f3f3fd6266effe074fd20ba62ea331"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga22f3f3fd6266effe074fd20ba62ea331">&#9670;&nbsp;</a></span>doca_eth_rxq_task_recv_get_pkt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_eth_rxq_task_recv_get_pkt </td>
          <td>(</td>
          <td class="paramtype">const struct doca_eth_rxq_task_recv *&#160;</td>
          <td class="paramname"><em>task_recv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct doca_buf **&#160;</td>
          <td class="paramname"><em>pkt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method gets packet buffer from doca_eth_rxq_task_recv task. </p>
<dl class="section note"><dt>Note</dt><dd>Supported for DOCA ETH RXQ instance for CPU only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task_recv</td><td>The task to get from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pkt</td><td>Packet buffer to get.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - in case one of the arguments is NULL. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gad02d9496a09744d2bb413f40aba43ff9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad02d9496a09744d2bb413f40aba43ff9">&#9670;&nbsp;</a></span>doca_eth_rxq_task_recv_get_rx_hash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_eth_rxq_task_recv_get_rx_hash </td>
          <td>(</td>
          <td class="paramtype">const struct doca_eth_rxq_task_recv *&#160;</td>
          <td class="paramname"><em>task_recv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>rx_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method gets the RX hash of a finished receive task. </p>
<dl class="section note"><dt>Note</dt><dd>Supported for DOCA ETH RXQ instance for CPU only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task_recv</td><td>The task to get from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rx_hash</td><td>RX hash to get.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - in case one of the arguments is NULL. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gac71c985a3491e3b65899dad1da8a5650"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac71c985a3491e3b65899dad1da8a5650">&#9670;&nbsp;</a></span>doca_eth_rxq_task_recv_get_timestamp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_eth_rxq_task_recv_get_timestamp </td>
          <td>(</td>
          <td class="paramtype">const struct doca_eth_rxq_task_recv *&#160;</td>
          <td class="paramname"><em>task_recv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>timestamp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method gets the timestamp of a finished receive task. </p>
<dl class="section note"><dt>Note</dt><dd>Supported for DOCA ETH RXQ instance for CPU only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task_recv</td><td>The task to get from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">timestamp</td><td>Timestamp to get in nanoseconds.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - in case one of the arguments is NULL. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga539bc06a14c08ddba977f25ba4e998b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga539bc06a14c08ddba977f25ba4e998b0">&#9670;&nbsp;</a></span>doca_eth_rxq_task_recv_set_conf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_eth_rxq_task_recv_set_conf </td>
          <td>(</td>
          <td class="paramtype">struct doca_eth_rxq *&#160;</td>
          <td class="paramname"><em>eth_rxq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DOCA__ETH__RXQ__CPU__DATA__PATH.html#gaa2486a6e6e96c83cc4534ae7d0e81486">doca_eth_rxq_task_recv_completion_cb_t</a>&#160;</td>
          <td class="paramname"><em>task_completion_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DOCA__ETH__RXQ__CPU__DATA__PATH.html#gaa2486a6e6e96c83cc4534ae7d0e81486">doca_eth_rxq_task_recv_completion_cb_t</a>&#160;</td>
          <td class="paramname"><em>task_error_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>task_recv_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method sets the doca_eth_rxq_task_recv tasks configuration. can only be called before calling <a class="el" href="group__DOCA__CTX.html#ga712a2c32ab9113f568d08c379ec506f7" title="Finalizes all configurations, and starts the DOCA CTX.">doca_ctx_start()</a>. </p>
<dl class="section note"><dt>Note</dt><dd>Supported for DOCA ETH RXQ instance for CPU only. Function is relevant only in the case of context of type DOCA_ETH_RXQ_TYPE_REGULAR.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">eth_rxq</td><td>Pointer to doca_eth_rxq instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">task_completion_cb</td><td>Task completion callback. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">task_error_cb</td><td>Task error callback. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">task_recv_num</td><td>Number of doca_eth_rxq_task_recv tasks.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - eth_rxq argument is a NULL pointer.</li>
<li>DOCA_ERROR_BAD_STATE - eth_rxq context state is not idle. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga652805709618170b9820f1ebd229d80e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga652805709618170b9820f1ebd229d80e">&#9670;&nbsp;</a></span>doca_eth_rxq_task_recv_set_pkt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> void doca_eth_rxq_task_recv_set_pkt </td>
          <td>(</td>
          <td class="paramtype">struct doca_eth_rxq_task_recv *&#160;</td>
          <td class="paramname"><em>task_recv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct doca_buf *&#160;</td>
          <td class="paramname"><em>pkt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method sets packet buffer to doca_eth_rxq_task_recv task. </p>
<dl class="section note"><dt>Note</dt><dd>Supported for DOCA ETH RXQ instance for CPU only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task_recv</td><td>The task to set to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pkt</td><td>Packet buffer to set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Wed Aug 13 2025 09:23:37 for NVIDIA DOCA SDK by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
