<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NVIDIA DOCA SDK: DOCA ETH TXQ</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<!-- Doxygen Awesome CSS -->
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript">
DoxygenAwesomeDarkModeToggle.init()
DoxygenAwesomeFragmentCopyButton.init()
DoxygenAwesomeParagraphLink.init()
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectname">NVIDIA DOCA SDK
  </td>
  <td id="projectbrief">Data Center on a Chip Framework Documentation</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__DOCA__ETH__TXQ.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">DOCA ETH TXQ<div class="ingroups"><a class="el" href="group__DOCA__ETH.html">DOCA ETH</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for DOCA ETH TXQ:</div>
<div class="dyncontent">
<div class="center"><img src="group__DOCA__ETH__TXQ.png" border="0" usemap="#agroup____DOCA____ETH____TXQ" alt=""/></div>
<map name="agroup____DOCA____ETH____TXQ" id="agroup____DOCA____ETH____TXQ">
<area shape="rect" href="group__DOCA__ETH__TXQ__CPU__DATA__PATH.html" title=" " alt="" coords="314,5,533,31"/>
<area shape="rect" title=" " alt="" coords="144,31,265,56"/>
<area shape="rect" href="group__DOCA__ETH__TXQ__GPU__DATA__PATH.html" title=" " alt="" coords="313,55,533,80"/>
<area shape="rect" href="group__DOCA__ETH.html" title=" " alt="" coords="5,31,96,56"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__DOCA__ETH__TXQ__CPU__DATA__PATH"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ETH__TXQ__CPU__DATA__PATH.html">DOCA ETH TXQ CPU Data Path</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__DOCA__ETH__TXQ__GPU__DATA__PATH"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ETH__TXQ__GPU__DATA__PATH.html">DOCA ETH TXQ GPU Data Path</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gaeb933b4a15ce154b83be2e7dc16ff24a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ETH__TXQ.html#gaeb933b4a15ce154b83be2e7dc16ff24a">doca_eth_txq_type</a> { <a class="el" href="group__DOCA__ETH__TXQ.html#ggaeb933b4a15ce154b83be2e7dc16ff24aaa2922a4c44e772d0d40dcc9a34747ddb">DOCA_ETH_TXQ_TYPE_REGULAR</a> = 0
 }</td></tr>
<tr class="separator:gaeb933b4a15ce154b83be2e7dc16ff24a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a6e95f32753b1d1f087ecde62325bfd"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ETH__TXQ.html#ga4a6e95f32753b1d1f087ecde62325bfd">doca_eth_txq_data_path_type</a> { <a class="el" href="group__DOCA__ETH__TXQ.html#gga4a6e95f32753b1d1f087ecde62325bfdaa8247094eb36b24a1f127e215086039b">DOCA_ETH_TXQ_DATA_PATH_TYPE_CPU</a> = 0
, <a class="el" href="group__DOCA__ETH__TXQ.html#gga4a6e95f32753b1d1f087ecde62325bfdabf19245ff3bf22ae375dc897184a331c">DOCA_ETH_TXQ_DATA_PATH_TYPE_GPU</a>
 }</td></tr>
<tr class="separator:ga4a6e95f32753b1d1f087ecde62325bfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga66f838bc506b48722b36a081665464c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ETH__TXQ.html#ga66f838bc506b48722b36a081665464c6">doca_eth_txq_create</a> (struct doca_dev *dev, uint32_t max_burst_size, struct doca_eth_txq **eth_txq)</td></tr>
<tr class="memdesc:ga66f838bc506b48722b36a081665464c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a DOCA ETH TXQ instance.  <a href="group__DOCA__ETH__TXQ.html#ga66f838bc506b48722b36a081665464c6">More...</a><br /></td></tr>
<tr class="separator:ga66f838bc506b48722b36a081665464c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fcd463f2f2c65e49c54eaa7e75bbe32"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ETH__TXQ.html#ga7fcd463f2f2c65e49c54eaa7e75bbe32">doca_eth_txq_destroy</a> (struct doca_eth_txq *eth_txq)</td></tr>
<tr class="memdesc:ga7fcd463f2f2c65e49c54eaa7e75bbe32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a DOCA ETH TXQ instance.  <a href="group__DOCA__ETH__TXQ.html#ga7fcd463f2f2c65e49c54eaa7e75bbe32">More...</a><br /></td></tr>
<tr class="separator:ga7fcd463f2f2c65e49c54eaa7e75bbe32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25624066580dd507cc42fd8a3ed42cc5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> struct doca_ctx *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ETH__TXQ.html#ga25624066580dd507cc42fd8a3ed42cc5">doca_eth_txq_as_doca_ctx</a> (struct doca_eth_txq *eth_txq)</td></tr>
<tr class="memdesc:ga25624066580dd507cc42fd8a3ed42cc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert doca_eth_txq instance into a generalized context for use with doca core objects.  <a href="group__DOCA__ETH__TXQ.html#ga25624066580dd507cc42fd8a3ed42cc5">More...</a><br /></td></tr>
<tr class="separator:ga25624066580dd507cc42fd8a3ed42cc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa37161b76e0b5121b27e0d6484fcc68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ETH__TXQ.html#gafa37161b76e0b5121b27e0d6484fcc68">doca_eth_txq_set_max_burst_size</a> (struct doca_eth_txq *eth_txq, uint32_t max_burst_size)</td></tr>
<tr class="memdesc:gafa37161b76e0b5121b27e0d6484fcc68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set max burst size property for doca_eth_txq. This value dictates the maximal number of packets the HW can handle at the same time. can only be called before calling <a class="el" href="group__DOCA__CTX.html#ga712a2c32ab9113f568d08c379ec506f7" title="Finalizes all configurations, and starts the DOCA CTX.">doca_ctx_start()</a>.  <a href="group__DOCA__ETH__TXQ.html#gafa37161b76e0b5121b27e0d6484fcc68">More...</a><br /></td></tr>
<tr class="separator:gafa37161b76e0b5121b27e0d6484fcc68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b8571cde263cc3705a1bbc463fbdabe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ETH__TXQ.html#ga7b8571cde263cc3705a1bbc463fbdabe">doca_eth_txq_set_max_send_buf_list_len</a> (struct doca_eth_txq *eth_txq, uint32_t max_send_buf_list_len)</td></tr>
<tr class="memdesc:ga7b8571cde263cc3705a1bbc463fbdabe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the maximal send buffer list length for doca_eth_txq. This value indicated what the maximal number of elements in a doca_buf list is. can only be called before calling <a class="el" href="group__DOCA__CTX.html#ga712a2c32ab9113f568d08c379ec506f7" title="Finalizes all configurations, and starts the DOCA CTX.">doca_ctx_start()</a>.  <a href="group__DOCA__ETH__TXQ.html#ga7b8571cde263cc3705a1bbc463fbdabe">More...</a><br /></td></tr>
<tr class="separator:ga7b8571cde263cc3705a1bbc463fbdabe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56e7887dd1ea11d9b87a4a17824cca1a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ETH__TXQ.html#ga56e7887dd1ea11d9b87a4a17824cca1a">doca_eth_txq_set_metadata_num</a> (struct doca_eth_txq *eth_txq, uint8_t metadata_num)</td></tr>
<tr class="memdesc:ga56e7887dd1ea11d9b87a4a17824cca1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set metadata number for doca_eth_txq. This value is the number of metadata per packet. can only be called before calling <a class="el" href="group__DOCA__CTX.html#ga712a2c32ab9113f568d08c379ec506f7" title="Finalizes all configurations, and starts the DOCA CTX.">doca_ctx_start()</a>.  <a href="group__DOCA__ETH__TXQ.html#ga56e7887dd1ea11d9b87a4a17824cca1a">More...</a><br /></td></tr>
<tr class="separator:ga56e7887dd1ea11d9b87a4a17824cca1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa991c407214ee6f34001cfe1871c34c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ETH__TXQ.html#gaa991c407214ee6f34001cfe1871c34c9">doca_eth_txq_set_mss</a> (struct doca_eth_txq *eth_txq, uint16_t mss)</td></tr>
<tr class="memdesc:gaa991c407214ee6f34001cfe1871c34c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the Maximum Segment Size for doca_eth_txq. This value will be used per LSO send task / task_batch unless user overrides it (by setting MSS on the specific task / task_batch). This value is the maximum data size that can be sent in each segment of the LSO packet. can only be called before calling <a class="el" href="group__DOCA__CTX.html#ga712a2c32ab9113f568d08c379ec506f7" title="Finalizes all configurations, and starts the DOCA CTX.">doca_ctx_start()</a>.  <a href="group__DOCA__ETH__TXQ.html#gaa991c407214ee6f34001cfe1871c34c9">More...</a><br /></td></tr>
<tr class="separator:gaa991c407214ee6f34001cfe1871c34c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab12893dc8d9e80e4135e6597d6640933"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ETH__TXQ.html#gab12893dc8d9e80e4135e6597d6640933">doca_eth_txq_set_max_lso_header_size</a> (struct doca_eth_txq *eth_txq, uint16_t max_lso_header_size)</td></tr>
<tr class="memdesc:gab12893dc8d9e80e4135e6597d6640933"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the maximum LSO header size for doca_eth_txq. This value is the maximum header size of the LSO packet can only be called before calling <a class="el" href="group__DOCA__CTX.html#ga712a2c32ab9113f568d08c379ec506f7" title="Finalizes all configurations, and starts the DOCA CTX.">doca_ctx_start()</a>.  <a href="group__DOCA__ETH__TXQ.html#gab12893dc8d9e80e4135e6597d6640933">More...</a><br /></td></tr>
<tr class="separator:gab12893dc8d9e80e4135e6597d6640933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ed06108ae87bff6f5909e66aedfb013"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ETH__TXQ.html#ga9ed06108ae87bff6f5909e66aedfb013">doca_eth_txq_set_type</a> (struct doca_eth_txq *eth_txq, enum <a class="el" href="group__DOCA__ETH__TXQ.html#gaeb933b4a15ce154b83be2e7dc16ff24a">doca_eth_txq_type</a> <a class="el" href="upf__accel_8h.html#a5f649fbc43a239b31af8e53c8b76b756">type</a>)</td></tr>
<tr class="memdesc:ga9ed06108ae87bff6f5909e66aedfb013"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set TX queue type property for doca_eth_txq. can only be called before calling <a class="el" href="group__DOCA__CTX.html#ga712a2c32ab9113f568d08c379ec506f7" title="Finalizes all configurations, and starts the DOCA CTX.">doca_ctx_start()</a>.  <a href="group__DOCA__ETH__TXQ.html#ga9ed06108ae87bff6f5909e66aedfb013">More...</a><br /></td></tr>
<tr class="separator:ga9ed06108ae87bff6f5909e66aedfb013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7af05a61f236a7e68f43027fa162eb71"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ETH__TXQ.html#ga7af05a61f236a7e68f43027fa162eb71">doca_eth_txq_set_l3_chksum_offload</a> (struct doca_eth_txq *eth_txq, uint8_t enable_l3_chksum)</td></tr>
<tr class="memdesc:ga7af05a61f236a7e68f43027fa162eb71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set offload for the calculation of IPv4 checksum (L3) on transmitted packets. If the users enables L3 checksum offloading, then the HW will calculate the checksum value and write it into the specific field in the packet. This offload is enabled/disabled to every task / task_batch by default. User can change this by modifying the ol_flag value (See "enum doca_eth_txq_ol_flags"). can only be called before calling <a class="el" href="group__DOCA__CTX.html#ga712a2c32ab9113f568d08c379ec506f7" title="Finalizes all configurations, and starts the DOCA CTX.">doca_ctx_start()</a>.  <a href="group__DOCA__ETH__TXQ.html#ga7af05a61f236a7e68f43027fa162eb71">More...</a><br /></td></tr>
<tr class="separator:ga7af05a61f236a7e68f43027fa162eb71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga963e72d80c67204d8339a725a59b6a45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ETH__TXQ.html#ga963e72d80c67204d8339a725a59b6a45">doca_eth_txq_set_l4_chksum_offload</a> (struct doca_eth_txq *eth_txq, uint8_t enable_l4_chksum)</td></tr>
<tr class="memdesc:ga963e72d80c67204d8339a725a59b6a45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set offload for the calculation of TCP/UDP checksum (L4) on transmitted packets. If the users enables L4 checksum offloading, then the HW will calculate the checksum value and write it into the specific field in the packet. This offload is enabled/disabled to every task / task_batch by default. User can change this by modifying the ol_flag value (See "enum doca_eth_txq_ol_flags"). can only be called before calling <a class="el" href="group__DOCA__CTX.html#ga712a2c32ab9113f568d08c379ec506f7" title="Finalizes all configurations, and starts the DOCA CTX.">doca_ctx_start()</a>.  <a href="group__DOCA__ETH__TXQ.html#ga963e72d80c67204d8339a725a59b6a45">More...</a><br /></td></tr>
<tr class="separator:ga963e72d80c67204d8339a725a59b6a45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a0140195fd872433f6cc26eca6f4983"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ETH__TXQ.html#ga3a0140195fd872433f6cc26eca6f4983">doca_eth_txq_set_wait_on_time_offload</a> (struct doca_eth_txq *eth_txq)</td></tr>
<tr class="memdesc:ga3a0140195fd872433f6cc26eca6f4983"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set offload to enable wait on time feature on the queue. can only be called before calling <a class="el" href="group__DOCA__CTX.html#ga712a2c32ab9113f568d08c379ec506f7" title="Finalizes all configurations, and starts the DOCA CTX.">doca_ctx_start()</a>.  <a href="group__DOCA__ETH__TXQ.html#ga3a0140195fd872433f6cc26eca6f4983">More...</a><br /></td></tr>
<tr class="separator:ga3a0140195fd872433f6cc26eca6f4983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga301963cf94006e4b93c5deba28f9db25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ETH__TXQ.html#ga301963cf94006e4b93c5deba28f9db25">doca_eth_txq_get_gpu_handle</a> (const struct doca_eth_txq *eth_txq, struct doca_gpu_eth_txq **eth_txq_ext)</td></tr>
<tr class="memdesc:ga301963cf94006e4b93c5deba28f9db25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a gpu handle of a doca_eth_txq.  <a href="group__DOCA__ETH__TXQ.html#ga301963cf94006e4b93c5deba28f9db25">More...</a><br /></td></tr>
<tr class="separator:ga301963cf94006e4b93c5deba28f9db25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e436c812005719dc18720f88d18da6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ETH__TXQ.html#ga2e436c812005719dc18720f88d18da6a">doca_eth_txq_cap_get_max_burst_size</a> (const struct doca_devinfo *devinfo, uint32_t max_send_buf_list_len, uint16_t max_lso_header_size, uint32_t *max_burst_size)</td></tr>
<tr class="memdesc:ga2e436c812005719dc18720f88d18da6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum burst size supported by the device.  <a href="group__DOCA__ETH__TXQ.html#ga2e436c812005719dc18720f88d18da6a">More...</a><br /></td></tr>
<tr class="separator:ga2e436c812005719dc18720f88d18da6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07afc42eb6f23c713067d76fb35a7bf3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ETH__TXQ.html#ga07afc42eb6f23c713067d76fb35a7bf3">doca_eth_txq_cap_get_max_send_buf_list_len</a> (const struct doca_devinfo *devinfo, uint32_t *max_send_buf_list_len)</td></tr>
<tr class="memdesc:ga07afc42eb6f23c713067d76fb35a7bf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum send buffer list length supported by the device.  <a href="group__DOCA__ETH__TXQ.html#ga07afc42eb6f23c713067d76fb35a7bf3">More...</a><br /></td></tr>
<tr class="separator:ga07afc42eb6f23c713067d76fb35a7bf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d0049d9486ec6b003f0358c7898e59f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ETH__TXQ.html#ga1d0049d9486ec6b003f0358c7898e59f">doca_eth_txq_cap_get_max_metadata_num</a> (const struct doca_devinfo *devinfo, uint8_t *max_metadata_num)</td></tr>
<tr class="memdesc:ga1d0049d9486ec6b003f0358c7898e59f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum metadata number supported by the device.  <a href="group__DOCA__ETH__TXQ.html#ga1d0049d9486ec6b003f0358c7898e59f">More...</a><br /></td></tr>
<tr class="separator:ga1d0049d9486ec6b003f0358c7898e59f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba71354b897db00c653945072f692893"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ETH__TXQ.html#gaba71354b897db00c653945072f692893">doca_eth_txq_cap_get_max_lso_header_size</a> (const struct doca_devinfo *devinfo, uint16_t *max_lso_header_size)</td></tr>
<tr class="memdesc:gaba71354b897db00c653945072f692893"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum header size of an LSO packet supported by the device.  <a href="group__DOCA__ETH__TXQ.html#gaba71354b897db00c653945072f692893">More...</a><br /></td></tr>
<tr class="separator:gaba71354b897db00c653945072f692893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa56ba40934bd7f1db8a6b9064fb6ed18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ETH__TXQ.html#gaa56ba40934bd7f1db8a6b9064fb6ed18">doca_eth_txq_cap_is_type_supported</a> (const struct doca_devinfo *devinfo, enum <a class="el" href="group__DOCA__ETH__TXQ.html#gaeb933b4a15ce154b83be2e7dc16ff24a">doca_eth_txq_type</a> <a class="el" href="upf__accel_8h.html#a5f649fbc43a239b31af8e53c8b76b756">type</a>, enum <a class="el" href="group__DOCA__ETH__TXQ.html#ga4a6e95f32753b1d1f087ecde62325bfd">doca_eth_txq_data_path_type</a> data_path_type)</td></tr>
<tr class="memdesc:gaa56ba40934bd7f1db8a6b9064fb6ed18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if TX queue type is supported.  <a href="group__DOCA__ETH__TXQ.html#gaa56ba40934bd7f1db8a6b9064fb6ed18">More...</a><br /></td></tr>
<tr class="separator:gaa56ba40934bd7f1db8a6b9064fb6ed18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35a7bfd0acac58ea5186bf15adf657bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ETH__TXQ.html#ga35a7bfd0acac58ea5186bf15adf657bd">doca_eth_txq_cap_is_l3_chksum_offload_supported</a> (const struct doca_devinfo *devinfo)</td></tr>
<tr class="memdesc:ga35a7bfd0acac58ea5186bf15adf657bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if L3 checksum offload is supported by the device.  <a href="group__DOCA__ETH__TXQ.html#ga35a7bfd0acac58ea5186bf15adf657bd">More...</a><br /></td></tr>
<tr class="separator:ga35a7bfd0acac58ea5186bf15adf657bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18cb77529e61fb0a4fe6eb388c2fe90a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ETH__TXQ.html#ga18cb77529e61fb0a4fe6eb388c2fe90a">doca_eth_txq_cap_is_l4_chksum_offload_supported</a> (const struct doca_devinfo *devinfo)</td></tr>
<tr class="memdesc:ga18cb77529e61fb0a4fe6eb388c2fe90a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if L4 checksum offload is supported by the device.  <a href="group__DOCA__ETH__TXQ.html#ga18cb77529e61fb0a4fe6eb388c2fe90a">More...</a><br /></td></tr>
<tr class="separator:ga18cb77529e61fb0a4fe6eb388c2fe90a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3a24cbaea4f684ee1fd2a83f6898d32"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ETH__TXQ.html#gaf3a24cbaea4f684ee1fd2a83f6898d32">doca_eth_txq_cap_get_max_lso_msg_size</a> (const struct doca_devinfo *devinfo, uint32_t *max_lso_msg_size)</td></tr>
<tr class="memdesc:gaf3a24cbaea4f684ee1fd2a83f6898d32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the max LSO message size by the network device.  <a href="group__DOCA__ETH__TXQ.html#gaf3a24cbaea4f684ee1fd2a83f6898d32">More...</a><br /></td></tr>
<tr class="separator:gaf3a24cbaea4f684ee1fd2a83f6898d32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9fb7368dd5e31358ca9ee37ed59873a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ETH__TXQ.html#ga9fb7368dd5e31358ca9ee37ed59873a9">doca_eth_txq_cap_get_wait_on_time_offload_supported</a> (const struct doca_devinfo *devinfo, enum <a class="el" href="group__DOCA__TYPES.html#gaeb4bedee6eb0dea18c0663aaa32d57a1">doca_eth_wait_on_time_type</a> *wait_on_time_mode)</td></tr>
<tr class="memdesc:ga9fb7368dd5e31358ca9ee37ed59873a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if wait on time offload is supported by the network device.  <a href="group__DOCA__ETH__TXQ.html#ga9fb7368dd5e31358ca9ee37ed59873a9">More...</a><br /></td></tr>
<tr class="separator:ga9fb7368dd5e31358ca9ee37ed59873a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf272c9a9fcc37f82db585e353b929946"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ETH__TXQ.html#gaf272c9a9fcc37f82db585e353b929946">doca_eth_txq_calculate_timestamp</a> (struct doca_eth_txq *eth_txq, uint64_t timestamp_ns, uint64_t *wait_on_time_value)</td></tr>
<tr class="memdesc:gaf272c9a9fcc37f82db585e353b929946"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate timestamp to use when setting the wait on time on the Tx queue.  <a href="group__DOCA__ETH__TXQ.html#gaf272c9a9fcc37f82db585e353b929946">More...</a><br /></td></tr>
<tr class="separator:gaf272c9a9fcc37f82db585e353b929946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87237bad54d08badcce3e436dbcab8cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__ETH__TXQ.html#ga87237bad54d08badcce3e436dbcab8cf">doca_eth_txq_get_flow_queue_id</a> (struct doca_eth_txq *eth_txq, uint16_t *flow_queue_id)</td></tr>
<tr class="memdesc:ga87237bad54d08badcce3e436dbcab8cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the DPDK queue ID of the doca_eth send queue. can only be called after calling <a class="el" href="group__DOCA__CTX.html#ga712a2c32ab9113f568d08c379ec506f7" title="Finalizes all configurations, and starts the DOCA CTX.">doca_ctx_start()</a>.  <a href="group__DOCA__ETH__TXQ.html#ga87237bad54d08badcce3e436dbcab8cf">More...</a><br /></td></tr>
<tr class="separator:ga87237bad54d08badcce3e436dbcab8cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>DOCA ETH TXQ library.</p>
<dl class="section note"><dt>Note</dt><dd>There are 2 data path options to use DOCA ETH TXQ context, a GPU managed control path and a CPU managed one. Other than the need to use <a class="el" href="group__DOCA__CTX.html#ga8724abdb5c006c7407b0fb007a90a22d" title="This function binds the DOCA context to a gpu device.">doca_ctx_set_datapath_on_gpu()</a> on a GPU context before starting it, both cases share the same control path functions (unless mentioned otherwise in the function documentation). The data path functions are different for the different options. The GPU managed data path functions are not included in the DOCA ETH TXQ API (check DOCA GPUNetIO). </dd></dl>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga4a6e95f32753b1d1f087ecde62325bfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4a6e95f32753b1d1f087ecde62325bfd">&#9670;&nbsp;</a></span>doca_eth_txq_data_path_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__DOCA__ETH__TXQ.html#ga4a6e95f32753b1d1f087ecde62325bfd">doca_eth_txq_data_path_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>TX data-path type. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga4a6e95f32753b1d1f087ecde62325bfdaa8247094eb36b24a1f127e215086039b"></a>DOCA_ETH_TXQ_DATA_PATH_TYPE_CPU&#160;</td><td class="fielddoc"><p>Enable data path management on the CPU </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4a6e95f32753b1d1f087ecde62325bfdabf19245ff3bf22ae375dc897184a331c"></a>DOCA_ETH_TXQ_DATA_PATH_TYPE_GPU&#160;</td><td class="fielddoc"><p>Enable data path management on the GPU </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="doca__eth__txq_8h_source.html#l00071">71</a> of file <a class="el" href="doca__eth__txq_8h_source.html">doca_eth_txq.h</a>.</p>

</div>
</div>
<a id="gaeb933b4a15ce154b83be2e7dc16ff24a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb933b4a15ce154b83be2e7dc16ff24a">&#9670;&nbsp;</a></span>doca_eth_txq_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__DOCA__ETH__TXQ.html#gaeb933b4a15ce154b83be2e7dc16ff24a">doca_eth_txq_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>TX queue type. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaeb933b4a15ce154b83be2e7dc16ff24aaa2922a4c44e772d0d40dcc9a34747ddb"></a>DOCA_ETH_TXQ_TYPE_REGULAR&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="doca__eth__txq_8h_source.html#l00064">64</a> of file <a class="el" href="doca__eth__txq_8h_source.html">doca_eth_txq.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga25624066580dd507cc42fd8a3ed42cc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga25624066580dd507cc42fd8a3ed42cc5">&#9670;&nbsp;</a></span>doca_eth_txq_as_doca_ctx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> struct doca_ctx* doca_eth_txq_as_doca_ctx </td>
          <td>(</td>
          <td class="paramtype">struct doca_eth_txq *&#160;</td>
          <td class="paramname"><em>eth_txq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert doca_eth_txq instance into a generalized context for use with doca core objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">eth_txq</td><td>Pointer to doca_eth_txq instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non NULL upon success, NULL otherwise. </dd></dl>

</div>
</div>
<a id="gaf272c9a9fcc37f82db585e353b929946"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf272c9a9fcc37f82db585e353b929946">&#9670;&nbsp;</a></span>doca_eth_txq_calculate_timestamp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_eth_txq_calculate_timestamp </td>
          <td>(</td>
          <td class="paramtype">struct doca_eth_txq *&#160;</td>
          <td class="paramname"><em>eth_txq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>timestamp_ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>wait_on_time_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate timestamp to use when setting the wait on time on the Tx queue. </p>
<dl class="section note"><dt>Note</dt><dd>Supported for DOCA ETH TXQ instance for GPU only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">eth_txq</td><td>Pointer to doca_eth_txq instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timestamp_ns</td><td>Timestamp to indicate when send packets. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">wait_on_time_value</td><td>Value to use to enqueue wait on time in send queue.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - if an invalid parameter was given.</li>
<li>DOCA_ERROR_DRIVER - error query underlying network card driver</li>
<li>DOCA_ERROR_NOT_PERMITTED - wait on time clock is not enabled on the network card. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga2e436c812005719dc18720f88d18da6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2e436c812005719dc18720f88d18da6a">&#9670;&nbsp;</a></span>doca_eth_txq_cap_get_max_burst_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_eth_txq_cap_get_max_burst_size </td>
          <td>(</td>
          <td class="paramtype">const struct doca_devinfo *&#160;</td>
          <td class="paramname"><em>devinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_send_buf_list_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>max_lso_header_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>max_burst_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the maximum burst size supported by the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">devinfo</td><td>Pointer to doca_devinfo instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_send_buf_list_len</td><td>Maximal send buffer list length to use in context. (check doca_eth_txq_set_max_send_buf_list_len) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_lso_header_size</td><td>Maximum header size of an LSO packet to use in context. Can be 0 in case user isn't planning to use LSO tasks. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">max_burst_size</td><td>The max burst size supported by the device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - if an invalid parameter was given. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaba71354b897db00c653945072f692893"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba71354b897db00c653945072f692893">&#9670;&nbsp;</a></span>doca_eth_txq_cap_get_max_lso_header_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_eth_txq_cap_get_max_lso_header_size </td>
          <td>(</td>
          <td class="paramtype">const struct doca_devinfo *&#160;</td>
          <td class="paramname"><em>devinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>max_lso_header_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the maximum header size of an LSO packet supported by the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">devinfo</td><td>Pointer to doca_devinfo instance. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">max_lso_header_size</td><td>Maximum header size of an LSO packet</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - if property set successfully. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - if an invalid parameter was given.</li>
<li>DOCA_ERROR_DRIVER - error query underlying network card driver.</li>
<li>DOCA_ERROR_NOT_SUPPORTED - if LSO is not supported. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaf3a24cbaea4f684ee1fd2a83f6898d32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf3a24cbaea4f684ee1fd2a83f6898d32">&#9670;&nbsp;</a></span>doca_eth_txq_cap_get_max_lso_msg_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_eth_txq_cap_get_max_lso_msg_size </td>
          <td>(</td>
          <td class="paramtype">const struct doca_devinfo *&#160;</td>
          <td class="paramname"><em>devinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>max_lso_msg_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the max LSO message size by the network device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">devinfo</td><td>Pointer to doca_devinfo instance. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">max_lso_msg_size</td><td>Maximum LSO message supported.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - if an invalid parameter was given.</li>
<li>DOCA_ERROR_DRIVER - error query underlying network card driver.</li>
<li>DOCA_ERROR_NOT_SUPPORTED - if LSO is not supported. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga1d0049d9486ec6b003f0358c7898e59f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d0049d9486ec6b003f0358c7898e59f">&#9670;&nbsp;</a></span>doca_eth_txq_cap_get_max_metadata_num()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_eth_txq_cap_get_max_metadata_num </td>
          <td>(</td>
          <td class="paramtype">const struct doca_devinfo *&#160;</td>
          <td class="paramname"><em>devinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>max_metadata_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the maximum metadata number supported by the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">devinfo</td><td>Pointer to doca_devinfo instance. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">max_metadata_num</td><td>Maximal metadata number to get. (check doca_eth_txq_set_metadata_num)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - if property set successfully. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - if an invalid parameter was given. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga07afc42eb6f23c713067d76fb35a7bf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga07afc42eb6f23c713067d76fb35a7bf3">&#9670;&nbsp;</a></span>doca_eth_txq_cap_get_max_send_buf_list_len()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_eth_txq_cap_get_max_send_buf_list_len </td>
          <td>(</td>
          <td class="paramtype">const struct doca_devinfo *&#160;</td>
          <td class="paramname"><em>devinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>max_send_buf_list_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the maximum send buffer list length supported by the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">devinfo</td><td>Pointer to doca_devinfo instance. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">max_send_buf_list_len</td><td>Maximal send buffer list length to get. (check doca_eth_txq_set_max_send_buf_list_len)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - if property set successfully. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - if an invalid parameter was given. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga9fb7368dd5e31358ca9ee37ed59873a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9fb7368dd5e31358ca9ee37ed59873a9">&#9670;&nbsp;</a></span>doca_eth_txq_cap_get_wait_on_time_offload_supported()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_eth_txq_cap_get_wait_on_time_offload_supported </td>
          <td>(</td>
          <td class="paramtype">const struct doca_devinfo *&#160;</td>
          <td class="paramname"><em>devinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__DOCA__TYPES.html#gaeb4bedee6eb0dea18c0663aaa32d57a1">doca_eth_wait_on_time_type</a> *&#160;</td>
          <td class="paramname"><em>wait_on_time_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if wait on time offload is supported by the network device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">devinfo</td><td>Pointer to doca_devinfo instance. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">wait_on_time_mode</td><td>Offload wait on time mode (native or DPDK).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - if an invalid parameter was given.</li>
<li>DOCA_ERROR_DRIVER - error query underlying network card driver</li>
<li>DOCA_ERROR_NOT_SUPPORTED - real-time clock is not enable on the network card. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga35a7bfd0acac58ea5186bf15adf657bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga35a7bfd0acac58ea5186bf15adf657bd">&#9670;&nbsp;</a></span>doca_eth_txq_cap_is_l3_chksum_offload_supported()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_eth_txq_cap_is_l3_chksum_offload_supported </td>
          <td>(</td>
          <td class="paramtype">const struct doca_devinfo *&#160;</td>
          <td class="paramname"><em>devinfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if L3 checksum offload is supported by the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">devinfo</td><td>Pointer to doca_devinfo instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - if an invalid parameter was given.</li>
<li>DOCA_ERROR_NOT_SUPPORTED - if L3 checksum offload is not supported. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga18cb77529e61fb0a4fe6eb388c2fe90a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga18cb77529e61fb0a4fe6eb388c2fe90a">&#9670;&nbsp;</a></span>doca_eth_txq_cap_is_l4_chksum_offload_supported()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_eth_txq_cap_is_l4_chksum_offload_supported </td>
          <td>(</td>
          <td class="paramtype">const struct doca_devinfo *&#160;</td>
          <td class="paramname"><em>devinfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if L4 checksum offload is supported by the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">devinfo</td><td>Pointer to doca_devinfo instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - if an invalid parameter was given.</li>
<li>DOCA_ERROR_NOT_SUPPORTED - if L4 checksum offload is not supported. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaa56ba40934bd7f1db8a6b9064fb6ed18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa56ba40934bd7f1db8a6b9064fb6ed18">&#9670;&nbsp;</a></span>doca_eth_txq_cap_is_type_supported()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_eth_txq_cap_is_type_supported </td>
          <td>(</td>
          <td class="paramtype">const struct doca_devinfo *&#160;</td>
          <td class="paramname"><em>devinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__DOCA__ETH__TXQ.html#gaeb933b4a15ce154b83be2e7dc16ff24a">doca_eth_txq_type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__DOCA__ETH__TXQ.html#ga4a6e95f32753b1d1f087ecde62325bfd">doca_eth_txq_data_path_type</a>&#160;</td>
          <td class="paramname"><em>data_path_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if TX queue type is supported. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">devinfo</td><td>Pointer to doca_devinfo instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>TX queue type - see enum doca_eth_txq_type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data_path_type</td><td>TX data-path type - see enum doca_eth_txq_data_path_type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - if an invalid parameter was given.</li>
<li>DOCA_ERROR_NOT_SUPPORTED - if type is not supported. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga66f838bc506b48722b36a081665464c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga66f838bc506b48722b36a081665464c6">&#9670;&nbsp;</a></span>doca_eth_txq_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_eth_txq_create </td>
          <td>(</td>
          <td class="paramtype">struct doca_dev *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_burst_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct doca_eth_txq **&#160;</td>
          <td class="paramname"><em>eth_txq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a DOCA ETH TXQ instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>Device to bind the context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_burst_size</td><td>Max burst size to use in context. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">eth_txq</td><td>Pointer to pointer to be set to point to the created doca_eth_txq instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - if an invalid parameter was given.</li>
<li>DOCA_ERROR_NO_MEMORY - failed to alloc doca_eth_txq. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga7fcd463f2f2c65e49c54eaa7e75bbe32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7fcd463f2f2c65e49c54eaa7e75bbe32">&#9670;&nbsp;</a></span>doca_eth_txq_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_eth_txq_destroy </td>
          <td>(</td>
          <td class="paramtype">struct doca_eth_txq *&#160;</td>
          <td class="paramname"><em>eth_txq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a DOCA ETH TXQ instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">eth_txq</td><td>Pointer to instance to be destroyed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - eth_txq argument is a NULL pointer.</li>
<li>DOCA_ERROR_BAD_STATE - eth_txq context state is not idle. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga87237bad54d08badcce3e436dbcab8cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87237bad54d08badcce3e436dbcab8cf">&#9670;&nbsp;</a></span>doca_eth_txq_get_flow_queue_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_eth_txq_get_flow_queue_id </td>
          <td>(</td>
          <td class="paramtype">struct doca_eth_txq *&#160;</td>
          <td class="paramname"><em>eth_txq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>flow_queue_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the DPDK queue ID of the doca_eth send queue. can only be called after calling <a class="el" href="group__DOCA__CTX.html#ga712a2c32ab9113f568d08c379ec506f7" title="Finalizes all configurations, and starts the DOCA CTX.">doca_ctx_start()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">eth_txq</td><td>Pointer to doca_eth_txq instance. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">flow_queue_id</td><td>The queue ID to be used in rte_flow or doca_flow.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - if an invalid parameter was given.</li>
<li>DOCA_ERROR_BAD_STATE - if context was not started. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga301963cf94006e4b93c5deba28f9db25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga301963cf94006e4b93c5deba28f9db25">&#9670;&nbsp;</a></span>doca_eth_txq_get_gpu_handle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_eth_txq_get_gpu_handle </td>
          <td>(</td>
          <td class="paramtype">const struct doca_eth_txq *&#160;</td>
          <td class="paramname"><em>eth_txq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct doca_gpu_eth_txq **&#160;</td>
          <td class="paramname"><em>eth_txq_ext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a gpu handle of a doca_eth_txq. </p>
<dl class="section note"><dt>Note</dt><dd>Supported for DOCA ETH TXQ instance for GPU only.</dd></dl>
<p>This method should be used after ctx is started. The expected flow is as follows:</p><ol type="1">
<li>bind the ctx to a gpu device using <a class="el" href="group__DOCA__CTX.html#ga8724abdb5c006c7407b0fb007a90a22d" title="This function binds the DOCA context to a gpu device.">doca_ctx_set_datapath_on_gpu()</a></li>
<li>start the ctx using <a class="el" href="group__DOCA__CTX.html#ga712a2c32ab9113f568d08c379ec506f7" title="Finalizes all configurations, and starts the DOCA CTX.">doca_ctx_start()</a></li>
<li>call <a class="el" href="group__DOCA__ETH__TXQ.html#ga301963cf94006e4b93c5deba28f9db25" title="Get a gpu handle of a doca_eth_txq.">doca_eth_txq_get_gpu_handle()</a> to get the gpu_handle</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">eth_txq</td><td>Pointer to doca_eth_txq instance. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">eth_txq_ext</td><td>A doca gpu eth_txq handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - if an invalid parameter was given.</li>
<li>DOCA_ERROR_BAD_STATE - if context is not idle.</li>
<li>DOCA_ERROR_NOT_SUPPORTED - in case eth_txq isn't an instance for GPU. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga7af05a61f236a7e68f43027fa162eb71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7af05a61f236a7e68f43027fa162eb71">&#9670;&nbsp;</a></span>doca_eth_txq_set_l3_chksum_offload()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_eth_txq_set_l3_chksum_offload </td>
          <td>(</td>
          <td class="paramtype">struct doca_eth_txq *&#160;</td>
          <td class="paramname"><em>eth_txq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>enable_l3_chksum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set offload for the calculation of IPv4 checksum (L3) on transmitted packets. If the users enables L3 checksum offloading, then the HW will calculate the checksum value and write it into the specific field in the packet. This offload is enabled/disabled to every task / task_batch by default. User can change this by modifying the ol_flag value (See "enum doca_eth_txq_ol_flags"). can only be called before calling <a class="el" href="group__DOCA__CTX.html#ga712a2c32ab9113f568d08c379ec506f7" title="Finalizes all configurations, and starts the DOCA CTX.">doca_ctx_start()</a>. </p>
<dl class="section note"><dt>Note</dt><dd>The default configuration is to disable L3 checksum offloading.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">eth_txq</td><td>Pointer to doca_eth_txq instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enable_l3_chksum</td><td>An indicator to enable/disable L3 checksum.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - if an invalid parameter was given.</li>
<li>DOCA_ERROR_BAD_STATE - if context is not idle. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga963e72d80c67204d8339a725a59b6a45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga963e72d80c67204d8339a725a59b6a45">&#9670;&nbsp;</a></span>doca_eth_txq_set_l4_chksum_offload()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_eth_txq_set_l4_chksum_offload </td>
          <td>(</td>
          <td class="paramtype">struct doca_eth_txq *&#160;</td>
          <td class="paramname"><em>eth_txq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>enable_l4_chksum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set offload for the calculation of TCP/UDP checksum (L4) on transmitted packets. If the users enables L4 checksum offloading, then the HW will calculate the checksum value and write it into the specific field in the packet. This offload is enabled/disabled to every task / task_batch by default. User can change this by modifying the ol_flag value (See "enum doca_eth_txq_ol_flags"). can only be called before calling <a class="el" href="group__DOCA__CTX.html#ga712a2c32ab9113f568d08c379ec506f7" title="Finalizes all configurations, and starts the DOCA CTX.">doca_ctx_start()</a>. </p>
<dl class="section note"><dt>Note</dt><dd>The default configuration is to disable L4 checksum offloading.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">eth_txq</td><td>Pointer to doca_eth_txq instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enable_l4_chksum</td><td>An indicator to enable/disable L4 checksum.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - if an invalid parameter was given.</li>
<li>DOCA_ERROR_BAD_STATE - if context is not idle. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gafa37161b76e0b5121b27e0d6484fcc68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa37161b76e0b5121b27e0d6484fcc68">&#9670;&nbsp;</a></span>doca_eth_txq_set_max_burst_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_eth_txq_set_max_burst_size </td>
          <td>(</td>
          <td class="paramtype">struct doca_eth_txq *&#160;</td>
          <td class="paramname"><em>eth_txq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_burst_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set max burst size property for doca_eth_txq. This value dictates the maximal number of packets the HW can handle at the same time. can only be called before calling <a class="el" href="group__DOCA__CTX.html#ga712a2c32ab9113f568d08c379ec506f7" title="Finalizes all configurations, and starts the DOCA CTX.">doca_ctx_start()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">eth_txq</td><td>Pointer to doca_eth_txq instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_burst_size</td><td>Max burst size to use in context.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - if an invalid parameter was given.</li>
<li>DOCA_ERROR_BAD_STATE - if context is not idle. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gab12893dc8d9e80e4135e6597d6640933"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab12893dc8d9e80e4135e6597d6640933">&#9670;&nbsp;</a></span>doca_eth_txq_set_max_lso_header_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_eth_txq_set_max_lso_header_size </td>
          <td>(</td>
          <td class="paramtype">struct doca_eth_txq *&#160;</td>
          <td class="paramname"><em>eth_txq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>max_lso_header_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the maximum LSO header size for doca_eth_txq. This value is the maximum header size of the LSO packet can only be called before calling <a class="el" href="group__DOCA__CTX.html#ga712a2c32ab9113f568d08c379ec506f7" title="Finalizes all configurations, and starts the DOCA CTX.">doca_ctx_start()</a>. </p>
<dl class="section note"><dt>Note</dt><dd>The default maximum LSO header size is 74. </dd>
<dd>
This setter is relevant only in case of using LSO send tasks.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">eth_txq</td><td>Pointer to doca_eth_txq instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_lso_header_size</td><td>Maximum LSO header size to use in context.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - if property set successfully. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - if an invalid parameter was given.</li>
<li>DOCA_ERROR_BAD_STATE - if context is not idle. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga7b8571cde263cc3705a1bbc463fbdabe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b8571cde263cc3705a1bbc463fbdabe">&#9670;&nbsp;</a></span>doca_eth_txq_set_max_send_buf_list_len()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_eth_txq_set_max_send_buf_list_len </td>
          <td>(</td>
          <td class="paramtype">struct doca_eth_txq *&#160;</td>
          <td class="paramname"><em>eth_txq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_send_buf_list_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the maximal send buffer list length for doca_eth_txq. This value indicated what the maximal number of elements in a doca_buf list is. can only be called before calling <a class="el" href="group__DOCA__CTX.html#ga712a2c32ab9113f568d08c379ec506f7" title="Finalizes all configurations, and starts the DOCA CTX.">doca_ctx_start()</a>. </p>
<dl class="section note"><dt>Note</dt><dd>The default maximal send buffer list length is 1.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">eth_txq</td><td>Pointer to doca_eth_txq instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_send_buf_list_len</td><td>Maximal send buffer list length to use in context.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - if property set successfully. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - if an invalid parameter was given.</li>
<li>DOCA_ERROR_BAD_STATE - if context is not idle. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga56e7887dd1ea11d9b87a4a17824cca1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga56e7887dd1ea11d9b87a4a17824cca1a">&#9670;&nbsp;</a></span>doca_eth_txq_set_metadata_num()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_eth_txq_set_metadata_num </td>
          <td>(</td>
          <td class="paramtype">struct doca_eth_txq *&#160;</td>
          <td class="paramname"><em>eth_txq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>metadata_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set metadata number for doca_eth_txq. This value is the number of metadata per packet. can only be called before calling <a class="el" href="group__DOCA__CTX.html#ga712a2c32ab9113f568d08c379ec506f7" title="Finalizes all configurations, and starts the DOCA CTX.">doca_ctx_start()</a>. </p>
<dl class="section note"><dt>Note</dt><dd>Supported for DOCA ETH TXQ instance for CPU only. </dd>
<dd>
The default metadata number is 0.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">eth_txq</td><td>Pointer to doca_eth_txq instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">metadata_num</td><td>metadata number to use in context.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - if property set successfully. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - if an invalid parameter was given.</li>
<li>DOCA_ERROR_BAD_STATE - if context is not idle. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaa991c407214ee6f34001cfe1871c34c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa991c407214ee6f34001cfe1871c34c9">&#9670;&nbsp;</a></span>doca_eth_txq_set_mss()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_eth_txq_set_mss </td>
          <td>(</td>
          <td class="paramtype">struct doca_eth_txq *&#160;</td>
          <td class="paramname"><em>eth_txq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>mss</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the Maximum Segment Size for doca_eth_txq. This value will be used per LSO send task / task_batch unless user overrides it (by setting MSS on the specific task / task_batch). This value is the maximum data size that can be sent in each segment of the LSO packet. can only be called before calling <a class="el" href="group__DOCA__CTX.html#ga712a2c32ab9113f568d08c379ec506f7" title="Finalizes all configurations, and starts the DOCA CTX.">doca_ctx_start()</a>. </p>
<dl class="section note"><dt>Note</dt><dd>The default MSS is 1500. </dd>
<dd>
This setter is relevant only in case of using LSO send task / task_batch.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">eth_txq</td><td>Pointer to doca_eth_txq instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mss</td><td>Maximum Segment Size to use in context.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - if property set successfully. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - if an invalid parameter was given.</li>
<li>DOCA_ERROR_BAD_STATE - if context is not idle. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga9ed06108ae87bff6f5909e66aedfb013"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ed06108ae87bff6f5909e66aedfb013">&#9670;&nbsp;</a></span>doca_eth_txq_set_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_eth_txq_set_type </td>
          <td>(</td>
          <td class="paramtype">struct doca_eth_txq *&#160;</td>
          <td class="paramname"><em>eth_txq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__DOCA__ETH__TXQ.html#gaeb933b4a15ce154b83be2e7dc16ff24a">doca_eth_txq_type</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set TX queue type property for doca_eth_txq. can only be called before calling <a class="el" href="group__DOCA__CTX.html#ga712a2c32ab9113f568d08c379ec506f7" title="Finalizes all configurations, and starts the DOCA CTX.">doca_ctx_start()</a>. </p>
<dl class="section note"><dt>Note</dt><dd>The default type is DOCA_ETH_TXQ_TYPE_REGULAR.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">eth_txq</td><td>Pointer to doca_eth_txq instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>TX queue type - see enum doca_eth_txq_type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - if an invalid parameter was given.</li>
<li>DOCA_ERROR_BAD_STATE - if context is not idle. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga3a0140195fd872433f6cc26eca6f4983"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a0140195fd872433f6cc26eca6f4983">&#9670;&nbsp;</a></span>doca_eth_txq_set_wait_on_time_offload()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_eth_txq_set_wait_on_time_offload </td>
          <td>(</td>
          <td class="paramtype">struct doca_eth_txq *&#160;</td>
          <td class="paramname"><em>eth_txq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set offload to enable wait on time feature on the queue. can only be called before calling <a class="el" href="group__DOCA__CTX.html#ga712a2c32ab9113f568d08c379ec506f7" title="Finalizes all configurations, and starts the DOCA CTX.">doca_ctx_start()</a>. </p>
<dl class="section note"><dt>Note</dt><dd>Supported for DOCA ETH TXQ instance for GPU only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">eth_txq</td><td>Pointer to doca_eth_txq instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - if an invalid parameter was given.</li>
<li>DOCA_ERROR_BAD_STATE - if context is not idle.</li>
<li>DOCA_ERROR_NOT_PERMITTED - wait on time HW support but network device clock is not in REAL TIME mode. </li>
</ul>
</dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Wed Aug 13 2025 08:00:17 for NVIDIA DOCA SDK by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
