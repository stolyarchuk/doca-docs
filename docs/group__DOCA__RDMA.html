<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NVIDIA DOCA SDK: DOCA RDMA</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<!-- Doxygen Awesome CSS -->
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript">
DoxygenAwesomeDarkModeToggle.init()
DoxygenAwesomeFragmentCopyButton.init()
DoxygenAwesomeParagraphLink.init()
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectname">NVIDIA DOCA SDK
  </td>
  <td id="projectbrief">Data Center on a Chip Framework Documentation</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__DOCA__RDMA.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">DOCA RDMA</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdoca__rdma__gid.html">doca_rdma_gid</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gadb533b1f5e0b511e7eec6d74e738193b"><td class="memItemLeft" align="right" valign="top">typedef uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#gadb533b1f5e0b511e7eec6d74e738193b">doca_dpa_dev_rdma_t</a></td></tr>
<tr class="separator:gadb533b1f5e0b511e7eec6d74e738193b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32d1ed957b273e7c459a8d0f71dded3f"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga32d1ed957b273e7c459a8d0f71dded3f">doca_rdma_connection_request_cb_t</a>) (struct doca_rdma_connection *rdma_connection, union <a class="el" href="uniondoca__data.html">doca_data</a> ctx_user_data)</td></tr>
<tr class="memdesc:ga32d1ed957b273e7c459a8d0f71dded3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to execute on connection request event.  <a href="group__DOCA__RDMA.html#ga32d1ed957b273e7c459a8d0f71dded3f">More...</a><br /></td></tr>
<tr class="separator:ga32d1ed957b273e7c459a8d0f71dded3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac64a10cc83ec29159975883df89b9507"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#gac64a10cc83ec29159975883df89b9507">doca_rdma_connection_established_cb_t</a>) (struct doca_rdma_connection *rdma_connection, union <a class="el" href="uniondoca__data.html">doca_data</a> connection_user_data, union <a class="el" href="uniondoca__data.html">doca_data</a> ctx_user_data)</td></tr>
<tr class="memdesc:gac64a10cc83ec29159975883df89b9507"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to execute on connection established event.  <a href="group__DOCA__RDMA.html#gac64a10cc83ec29159975883df89b9507">More...</a><br /></td></tr>
<tr class="separator:gac64a10cc83ec29159975883df89b9507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga759d54b2fef283bc8f92c2ae29187fce"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga759d54b2fef283bc8f92c2ae29187fce">doca_rdma_connection_failure_cb_t</a>) (struct doca_rdma_connection *rdma_connection, union <a class="el" href="uniondoca__data.html">doca_data</a> connection_user_data, union <a class="el" href="uniondoca__data.html">doca_data</a> ctx_user_data)</td></tr>
<tr class="memdesc:ga759d54b2fef283bc8f92c2ae29187fce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to execute on connection failure event.  <a href="group__DOCA__RDMA.html#ga759d54b2fef283bc8f92c2ae29187fce">More...</a><br /></td></tr>
<tr class="separator:ga759d54b2fef283bc8f92c2ae29187fce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c9391e450ddc64b3d26700a26dedba7"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga5c9391e450ddc64b3d26700a26dedba7">doca_rdma_connection_disconnection_cb_t</a>) (struct doca_rdma_connection *rdma_connection, union <a class="el" href="uniondoca__data.html">doca_data</a> connection_user_data, union <a class="el" href="uniondoca__data.html">doca_data</a> ctx_user_data)</td></tr>
<tr class="memdesc:ga5c9391e450ddc64b3d26700a26dedba7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to execute on connection disconnection event.  <a href="group__DOCA__RDMA.html#ga5c9391e450ddc64b3d26700a26dedba7">More...</a><br /></td></tr>
<tr class="separator:ga5c9391e450ddc64b3d26700a26dedba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0408ed0a480a862797dcede45efee761"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga0408ed0a480a862797dcede45efee761">doca_rdma_task_receive_completion_cb_t</a>) (struct doca_rdma_task_receive *task, union <a class="el" href="uniondoca__data.html">doca_data</a> task_user_data, union <a class="el" href="uniondoca__data.html">doca_data</a> ctx_user_data)</td></tr>
<tr class="memdesc:ga0408ed0a480a862797dcede45efee761"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to execute on completion of a receive task.  <a href="group__DOCA__RDMA.html#ga0408ed0a480a862797dcede45efee761">More...</a><br /></td></tr>
<tr class="separator:ga0408ed0a480a862797dcede45efee761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e87e2039e435abe52200598623f0cac"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga8e87e2039e435abe52200598623f0cac">doca_rdma_task_send_completion_cb_t</a>) (struct doca_rdma_task_send *task, union <a class="el" href="uniondoca__data.html">doca_data</a> task_user_data, union <a class="el" href="uniondoca__data.html">doca_data</a> ctx_user_data)</td></tr>
<tr class="memdesc:ga8e87e2039e435abe52200598623f0cac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to execute on completion of a send task.  <a href="group__DOCA__RDMA.html#ga8e87e2039e435abe52200598623f0cac">More...</a><br /></td></tr>
<tr class="separator:ga8e87e2039e435abe52200598623f0cac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86fa09af84fd6b25a24ba2e64e8d0360"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga86fa09af84fd6b25a24ba2e64e8d0360">doca_rdma_task_send_imm_completion_cb_t</a>) (struct doca_rdma_task_send_imm *task, union <a class="el" href="uniondoca__data.html">doca_data</a> task_user_data, union <a class="el" href="uniondoca__data.html">doca_data</a> ctx_user_data)</td></tr>
<tr class="memdesc:ga86fa09af84fd6b25a24ba2e64e8d0360"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to execute on completion of a send with immediate task.  <a href="group__DOCA__RDMA.html#ga86fa09af84fd6b25a24ba2e64e8d0360">More...</a><br /></td></tr>
<tr class="separator:ga86fa09af84fd6b25a24ba2e64e8d0360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc2c0386e7673546d9808fe3fda055f5"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#gabc2c0386e7673546d9808fe3fda055f5">doca_rdma_task_read_completion_cb_t</a>) (struct doca_rdma_task_read *task, union <a class="el" href="uniondoca__data.html">doca_data</a> task_user_data, union <a class="el" href="uniondoca__data.html">doca_data</a> ctx_user_data)</td></tr>
<tr class="memdesc:gabc2c0386e7673546d9808fe3fda055f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to execute on completion of a read task.  <a href="group__DOCA__RDMA.html#gabc2c0386e7673546d9808fe3fda055f5">More...</a><br /></td></tr>
<tr class="separator:gabc2c0386e7673546d9808fe3fda055f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf81a8b85901e3017b44eba70873cc322"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#gaf81a8b85901e3017b44eba70873cc322">doca_rdma_task_write_completion_cb_t</a>) (struct doca_rdma_task_write *task, union <a class="el" href="uniondoca__data.html">doca_data</a> task_user_data, union <a class="el" href="uniondoca__data.html">doca_data</a> ctx_user_data)</td></tr>
<tr class="memdesc:gaf81a8b85901e3017b44eba70873cc322"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to execute on completion of a write task.  <a href="group__DOCA__RDMA.html#gaf81a8b85901e3017b44eba70873cc322">More...</a><br /></td></tr>
<tr class="separator:gaf81a8b85901e3017b44eba70873cc322"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf46528474ecc323adb02c804fca60edc"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#gaf46528474ecc323adb02c804fca60edc">doca_rdma_task_write_imm_completion_cb_t</a>) (struct doca_rdma_task_write_imm *task, union <a class="el" href="uniondoca__data.html">doca_data</a> task_user_data, union <a class="el" href="uniondoca__data.html">doca_data</a> ctx_user_data)</td></tr>
<tr class="memdesc:gaf46528474ecc323adb02c804fca60edc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to execute on completion of a write with immediate task.  <a href="group__DOCA__RDMA.html#gaf46528474ecc323adb02c804fca60edc">More...</a><br /></td></tr>
<tr class="separator:gaf46528474ecc323adb02c804fca60edc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e23f2dcdf3c9e342c204a5623865b8e"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga0e23f2dcdf3c9e342c204a5623865b8e">doca_rdma_task_atomic_cmp_swp_completion_cb_t</a>) (struct doca_rdma_task_atomic_cmp_swp *task, union <a class="el" href="uniondoca__data.html">doca_data</a> task_user_data, union <a class="el" href="uniondoca__data.html">doca_data</a> ctx_user_data)</td></tr>
<tr class="memdesc:ga0e23f2dcdf3c9e342c204a5623865b8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to execute on completion of an atomic compare and swap task.  <a href="group__DOCA__RDMA.html#ga0e23f2dcdf3c9e342c204a5623865b8e">More...</a><br /></td></tr>
<tr class="separator:ga0e23f2dcdf3c9e342c204a5623865b8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16c1f55e5724609d494ae369d81421a0"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga16c1f55e5724609d494ae369d81421a0">doca_rdma_task_atomic_fetch_add_completion_cb_t</a>) (struct doca_rdma_task_atomic_fetch_add *task, union <a class="el" href="uniondoca__data.html">doca_data</a> task_user_data, union <a class="el" href="uniondoca__data.html">doca_data</a> ctx_user_data)</td></tr>
<tr class="memdesc:ga16c1f55e5724609d494ae369d81421a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to execute on completion of an atomic fetch and add task.  <a href="group__DOCA__RDMA.html#ga16c1f55e5724609d494ae369d81421a0">More...</a><br /></td></tr>
<tr class="separator:ga16c1f55e5724609d494ae369d81421a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9dcb777cfd90aaa306faba7c4f7aad14"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga9dcb777cfd90aaa306faba7c4f7aad14">doca_rdma_task_remote_net_sync_event_get_completion_cb_t</a>) (struct doca_rdma_task_remote_net_sync_event_get *task, union <a class="el" href="uniondoca__data.html">doca_data</a> task_user_data, union <a class="el" href="uniondoca__data.html">doca_data</a> ctx_user_data)</td></tr>
<tr class="memdesc:ga9dcb777cfd90aaa306faba7c4f7aad14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to execute on completion of a remote_net_sync_event_get task.  <a href="group__DOCA__RDMA.html#ga9dcb777cfd90aaa306faba7c4f7aad14">More...</a><br /></td></tr>
<tr class="separator:ga9dcb777cfd90aaa306faba7c4f7aad14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga856a75fbd80e9fda88005b6012fd3d52"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga856a75fbd80e9fda88005b6012fd3d52">doca_rdma_task_remote_net_sync_event_notify_set_completion_cb_t</a>) (struct doca_rdma_task_remote_net_sync_event_notify_set *task, union <a class="el" href="uniondoca__data.html">doca_data</a> task_user_data, union <a class="el" href="uniondoca__data.html">doca_data</a> ctx_user_data)</td></tr>
<tr class="memdesc:ga856a75fbd80e9fda88005b6012fd3d52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to execute on completion of a remote_net_sync_event_notify_set task.  <a href="group__DOCA__RDMA.html#ga856a75fbd80e9fda88005b6012fd3d52">More...</a><br /></td></tr>
<tr class="separator:ga856a75fbd80e9fda88005b6012fd3d52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17916c135eaba7a8bc303a5cc072e9dd"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga17916c135eaba7a8bc303a5cc072e9dd">doca_rdma_task_remote_net_sync_event_notify_add_completion_cb_t</a>) (struct doca_rdma_task_remote_net_sync_event_notify_add *task, union <a class="el" href="uniondoca__data.html">doca_data</a> task_user_data, union <a class="el" href="uniondoca__data.html">doca_data</a> ctx_user_data)</td></tr>
<tr class="memdesc:ga17916c135eaba7a8bc303a5cc072e9dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to execute on completion of a remote_net_sync_event_notify_add task.  <a href="group__DOCA__RDMA.html#ga17916c135eaba7a8bc303a5cc072e9dd">More...</a><br /></td></tr>
<tr class="separator:ga17916c135eaba7a8bc303a5cc072e9dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gaa5f02468536d7f851c155978d0867e3a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#gaa5f02468536d7f851c155978d0867e3a">doca_rdma_transport_type</a> { <a class="el" href="group__DOCA__RDMA.html#ggaa5f02468536d7f851c155978d0867e3aa86dbd3ef7516ae39bd929edccc3125d6">DOCA_RDMA_TRANSPORT_TYPE_RC</a>
, <a class="el" href="group__DOCA__RDMA.html#ggaa5f02468536d7f851c155978d0867e3aac1943626da460015b184ebbb408d99a2">DOCA_RDMA_TRANSPORT_TYPE_DC</a>
 }</td></tr>
<tr class="separator:gaa5f02468536d7f851c155978d0867e3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b86300b1a5ece749397138a3aeba419"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga9b86300b1a5ece749397138a3aeba419">doca_rdma_addr_type</a> { <a class="el" href="group__DOCA__RDMA.html#gga9b86300b1a5ece749397138a3aeba419a6e010baf02bb36a44eee8258af188946">DOCA_RDMA_ADDR_TYPE_IPv4</a>
, <a class="el" href="group__DOCA__RDMA.html#gga9b86300b1a5ece749397138a3aeba419a1614698a02125c8240c71c2fc6ba0725">DOCA_RDMA_ADDR_TYPE_IPv6</a>
, <a class="el" href="group__DOCA__RDMA.html#gga9b86300b1a5ece749397138a3aeba419aec5dccb65f1a17d4342357ab51508f17">DOCA_RDMA_ADDR_TYPE_GID</a>
 }</td></tr>
<tr class="separator:ga9b86300b1a5ece749397138a3aeba419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3cbcdbcd5adcbc7aa0b4eae4376ec9c8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga3cbcdbcd5adcbc7aa0b4eae4376ec9c8">doca_rdma_opcode</a> { <a class="el" href="group__DOCA__RDMA.html#gga3cbcdbcd5adcbc7aa0b4eae4376ec9c8ab50cced97b070060f324b3cfc28331dd">DOCA_RDMA_OPCODE_RECV_SEND</a> = 0
, <a class="el" href="group__DOCA__RDMA.html#gga3cbcdbcd5adcbc7aa0b4eae4376ec9c8aded1221acba0fa765e4b03c6036b6319">DOCA_RDMA_OPCODE_RECV_SEND_WITH_IMM</a>
, <a class="el" href="group__DOCA__RDMA.html#gga3cbcdbcd5adcbc7aa0b4eae4376ec9c8a026515412e9e5a760c8fa686e571db76">DOCA_RDMA_OPCODE_RECV_WRITE_WITH_IMM</a>
 }</td></tr>
<tr class="separator:ga3cbcdbcd5adcbc7aa0b4eae4376ec9c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gae83132a3cc3fdd30a76dabf11c975eef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#gae83132a3cc3fdd30a76dabf11c975eef">doca_rdma_create</a> (struct doca_dev *dev, struct doca_rdma **rdma)</td></tr>
<tr class="memdesc:gae83132a3cc3fdd30a76dabf11c975eef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a DOCA RDMA instance.  <a href="group__DOCA__RDMA.html#gae83132a3cc3fdd30a76dabf11c975eef">More...</a><br /></td></tr>
<tr class="separator:gae83132a3cc3fdd30a76dabf11c975eef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga240e41c4dff9525db19b8db498489e38"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga240e41c4dff9525db19b8db498489e38">doca_rdma_destroy</a> (struct doca_rdma *rdma)</td></tr>
<tr class="memdesc:ga240e41c4dff9525db19b8db498489e38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a DOCA RDMA instance.  <a href="group__DOCA__RDMA.html#ga240e41c4dff9525db19b8db498489e38">More...</a><br /></td></tr>
<tr class="separator:ga240e41c4dff9525db19b8db498489e38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadab302408c4c1cfe749328aa70c6502d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> struct doca_ctx *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#gadab302408c4c1cfe749328aa70c6502d">doca_rdma_as_ctx</a> (struct doca_rdma *rdma)</td></tr>
<tr class="memdesc:gadab302408c4c1cfe749328aa70c6502d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert doca_rdma instance into a generalized context for use with doca core objects.  <a href="group__DOCA__RDMA.html#gadab302408c4c1cfe749328aa70c6502d">More...</a><br /></td></tr>
<tr class="separator:gadab302408c4c1cfe749328aa70c6502d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa96c93d0552c0cc44891db06bc3c2080"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#gaa96c93d0552c0cc44891db06bc3c2080">doca_rdma_export</a> (struct doca_rdma *rdma, const void **local_rdma_conn_details, <a class="el" href="____stddef__size__t_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a> *local_rdma_conn_details_size, struct doca_rdma_connection **rdma_connection)</td></tr>
<tr class="memdesc:gaa96c93d0552c0cc44891db06bc3c2080"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export doca_rdma connection details object The doca_rdma_conn_details are used in <a class="el" href="group__DOCA__RDMA.html#gae3b3eeb7682db1bbb5f8021c2302d60f" title="Connect to remote doca_rdma peer. Can only be called when the ctx is in DOCA_CTX_STATE_STARTING state...">doca_rdma_connect()</a>. Can only be called after calling <a class="el" href="group__DOCA__CTX.html#ga712a2c32ab9113f568d08c379ec506f7" title="Finalizes all configurations, and starts the DOCA CTX.">doca_ctx_start()</a>.  <a href="group__DOCA__RDMA.html#gaa96c93d0552c0cc44891db06bc3c2080">More...</a><br /></td></tr>
<tr class="separator:gaa96c93d0552c0cc44891db06bc3c2080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3b3eeb7682db1bbb5f8021c2302d60f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#gae3b3eeb7682db1bbb5f8021c2302d60f">doca_rdma_connect</a> (struct doca_rdma *rdma, const void *remote_rdma_conn_details, <a class="el" href="____stddef__size__t_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a> remote_rdma_conn_details_size, struct doca_rdma_connection *rdma_connection)</td></tr>
<tr class="memdesc:gae3b3eeb7682db1bbb5f8021c2302d60f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect to remote doca_rdma peer. Can only be called when the ctx is in DOCA_CTX_STATE_STARTING state (after calling <a class="el" href="group__DOCA__CTX.html#ga712a2c32ab9113f568d08c379ec506f7" title="Finalizes all configurations, and starts the DOCA CTX.">doca_ctx_start()</a>). Once called, <a class="el" href="group__DOCA__PE.html#ga9a0e5d8d7a584dcc3db5c612875887cb" title="Run the progress engine.">doca_pe_progress()</a> should be called, in order to transition the ctx to DOCA_CTX_STATE_RUNNING state. Only after that can tasks be allocated and submitted.  <a href="group__DOCA__RDMA.html#gae3b3eeb7682db1bbb5f8021c2302d60f">More...</a><br /></td></tr>
<tr class="separator:gae3b3eeb7682db1bbb5f8021c2302d60f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa05128ab8a15bb3260f29167b7ffc7d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#gaa05128ab8a15bb3260f29167b7ffc7d0">doca_rdma_addr_create</a> (enum <a class="el" href="group__DOCA__RDMA.html#ga9b86300b1a5ece749397138a3aeba419">doca_rdma_addr_type</a> addr_type, const char *address, uint16_t port, struct doca_rdma_addr **<a class="el" href="doca__dpa__dev__buf_8h.html#a845b126697becc1d429671f8a49e1c37">addr</a>)</td></tr>
<tr class="memdesc:gaa05128ab8a15bb3260f29167b7ffc7d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set connection address object for doca_rdma. The object can be queried using <a class="el" href="group__DOCA__RDMA.html#ga3be468cbf62683acfe30eac98f334aca" title="Get connection address object from a doca_rdma_connection.">doca_rdma_connection_get_addr()</a>.  <a href="group__DOCA__RDMA.html#gaa05128ab8a15bb3260f29167b7ffc7d0">More...</a><br /></td></tr>
<tr class="separator:gaa05128ab8a15bb3260f29167b7ffc7d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b189a1c772fdc94490d874ba81fc731"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga3b189a1c772fdc94490d874ba81fc731">doca_rdma_addr_destroy</a> (struct doca_rdma_addr *<a class="el" href="doca__dpa__dev__buf_8h.html#a845b126697becc1d429671f8a49e1c37">addr</a>)</td></tr>
<tr class="memdesc:ga3b189a1c772fdc94490d874ba81fc731"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy connection address object for doca_rdma.  <a href="group__DOCA__RDMA.html#ga3b189a1c772fdc94490d874ba81fc731">More...</a><br /></td></tr>
<tr class="separator:ga3b189a1c772fdc94490d874ba81fc731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa98248c59713a75b205ac90ac2ad2a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#gaaa98248c59713a75b205ac90ac2ad2a8">doca_rdma_start_listen_to_port</a> (struct doca_rdma *rdma, uint16_t port)</td></tr>
<tr class="memdesc:gaaa98248c59713a75b205ac90ac2ad2a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start listening for a connection from a remote doca_rdma peer. Can be called when the ctx is in DOCA_CTX_STATE_RUNNING state. Once called, <a class="el" href="group__DOCA__PE.html#ga9a0e5d8d7a584dcc3db5c612875887cb" title="Run the progress engine.">doca_pe_progress()</a> should be called, in order to evaluate possible connections requests. Only after a connection is established can send tasks be allocated and submitted.  <a href="group__DOCA__RDMA.html#gaaa98248c59713a75b205ac90ac2ad2a8">More...</a><br /></td></tr>
<tr class="separator:gaaa98248c59713a75b205ac90ac2ad2a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ad6e5b3a4c448373441edc6946685dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga3ad6e5b3a4c448373441edc6946685dd">doca_rdma_stop_listen_to_port</a> (struct doca_rdma *rdma, uint16_t port)</td></tr>
<tr class="memdesc:ga3ad6e5b3a4c448373441edc6946685dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">End the listen process for a connection from remote doca_rdma peers. Can be called when the ctx is in DOCA_CTX_STATE_RUNNING state. Once called, Server just stop listening for incoming connection requests and do not disconnect any remote doca_rdma peer.  <a href="group__DOCA__RDMA.html#ga3ad6e5b3a4c448373441edc6946685dd">More...</a><br /></td></tr>
<tr class="separator:ga3ad6e5b3a4c448373441edc6946685dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0cc463915d3e20f38e29d3a14384e4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#gad0cc463915d3e20f38e29d3a14384e4e">doca_rdma_connection_accept</a> (struct doca_rdma_connection *rdma_connection, void *private_data, uint8_t private_data_len)</td></tr>
<tr class="memdesc:gad0cc463915d3e20f38e29d3a14384e4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accept an incoming connection request from remote doca_rdma peer. Can be called when the ctx is in DOCA_CTX_STATE_RUNNING state. Only after a connection is established can send tasks be allocated and submitted.  <a href="group__DOCA__RDMA.html#gad0cc463915d3e20f38e29d3a14384e4e">More...</a><br /></td></tr>
<tr class="separator:gad0cc463915d3e20f38e29d3a14384e4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3bf9df47bd832b381a44cfe2a83bc46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#gac3bf9df47bd832b381a44cfe2a83bc46">doca_rdma_connection_reject</a> (struct doca_rdma_connection *rdma_connection)</td></tr>
<tr class="memdesc:gac3bf9df47bd832b381a44cfe2a83bc46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reject an incoming connection request from remote doca_rdma peer. Can be called when the ctx is in DOCA_CTX_STATE_RUNNING state.  <a href="group__DOCA__RDMA.html#gac3bf9df47bd832b381a44cfe2a83bc46">More...</a><br /></td></tr>
<tr class="separator:gac3bf9df47bd832b381a44cfe2a83bc46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2581e0afb02e52a39424e01aa8690ab3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga2581e0afb02e52a39424e01aa8690ab3">doca_rdma_connect_to_addr</a> (struct doca_rdma *rdma, struct doca_rdma_addr *<a class="el" href="doca__dpa__dev__buf_8h.html#a845b126697becc1d429671f8a49e1c37">addr</a>, union <a class="el" href="uniondoca__data.html">doca_data</a> connection_user_data)</td></tr>
<tr class="memdesc:ga2581e0afb02e52a39424e01aa8690ab3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect to a remote doca_rdma peer listening for a connection. Can be called when the ctx is in DOCA_CTX_STATE_RUNNING state. Once called, <a class="el" href="group__DOCA__PE.html#ga9a0e5d8d7a584dcc3db5c612875887cb" title="Run the progress engine.">doca_pe_progress()</a> should be called, in order to evaluate connection response. Only after a connection is established can send tasks be allocated and submitted.  <a href="group__DOCA__RDMA.html#ga2581e0afb02e52a39424e01aa8690ab3">More...</a><br /></td></tr>
<tr class="separator:ga2581e0afb02e52a39424e01aa8690ab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab10ceeeb6ede67a759bba4b49dbeca98"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#gab10ceeeb6ede67a759bba4b49dbeca98">doca_rdma_connection_disconnect</a> (struct doca_rdma_connection *rdma_connection)</td></tr>
<tr class="memdesc:gab10ceeeb6ede67a759bba4b49dbeca98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize a connection with a remote doca_rdma peer. Can be called when the ctx is in DOCA_CTX_STATE_RUNNING state.  <a href="group__DOCA__RDMA.html#gab10ceeeb6ede67a759bba4b49dbeca98">More...</a><br /></td></tr>
<tr class="separator:gab10ceeeb6ede67a759bba4b49dbeca98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga161593c0bcd2ea98b7b5c2c7844965b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga161593c0bcd2ea98b7b5c2c7844965b1">doca_rdma_bridge_prepare_connection</a> (struct doca_rdma *rdma, struct rdma_cm_id *cm_id, struct doca_rdma_connection **rdma_connection)</td></tr>
<tr class="memdesc:ga161593c0bcd2ea98b7b5c2c7844965b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare the connection and perform the doca connection to client side acting as a bridge. This method acts as a bridge to prepare and perform the doca connection to a connection request from an application that performs the listen process by itself. This function only prepare the DOCA connection, it is necessary to call <a class="el" href="group__DOCA__RDMA.html#ga444674736f797c9089ab45686bf4027b" title="Accept the connection from client side acting as a bridge. This method acts as a bridge to accept a c...">doca_rdma_bridge_accept()</a>, to continue the connection process. Can be called when the ctx is in DOCA_CTX_STATE_RUNNING state.  <a href="group__DOCA__RDMA.html#ga161593c0bcd2ea98b7b5c2c7844965b1">More...</a><br /></td></tr>
<tr class="separator:ga161593c0bcd2ea98b7b5c2c7844965b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga444674736f797c9089ab45686bf4027b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga444674736f797c9089ab45686bf4027b">doca_rdma_bridge_accept</a> (struct doca_rdma *rdma, void *private_data, uint8_t private_data_len, struct doca_rdma_connection *rdma_connection)</td></tr>
<tr class="memdesc:ga444674736f797c9089ab45686bf4027b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accept the connection from client side acting as a bridge. This method acts as a bridge to accept a connection request from an application that performs the listen process by itself. Can be called when the ctx is in DOCA_CTX_STATE_RUNNING state. Only after a connection is established can send tasks be allocated and submitted.  <a href="group__DOCA__RDMA.html#ga444674736f797c9089ab45686bf4027b">More...</a><br /></td></tr>
<tr class="separator:ga444674736f797c9089ab45686bf4027b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25b5a30ec836f0c467efe4cebc2f8fa2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga25b5a30ec836f0c467efe4cebc2f8fa2">doca_rdma_bridge_established</a> (struct doca_rdma *rdma, struct doca_rdma_connection *rdma_connection)</td></tr>
<tr class="memdesc:ga25b5a30ec836f0c467efe4cebc2f8fa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify the server side of the successful established connection with client Can be called when the ctx is in DOCA_CTX_STATE_RUNNING state.  <a href="group__DOCA__RDMA.html#ga25b5a30ec836f0c467efe4cebc2f8fa2">More...</a><br /></td></tr>
<tr class="separator:ga25b5a30ec836f0c467efe4cebc2f8fa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7d69e4a4ecebebd0b26c40a9603702a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#gaa7d69e4a4ecebebd0b26c40a9603702a">doca_rdma_cap_get_max_recv_queue_size</a> (const struct doca_devinfo *devinfo, uint32_t *max_recv_queue_size)</td></tr>
<tr class="memdesc:gaa7d69e4a4ecebebd0b26c40a9603702a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximal recv queue size for a specific device.  <a href="group__DOCA__RDMA.html#gaa7d69e4a4ecebebd0b26c40a9603702a">More...</a><br /></td></tr>
<tr class="separator:gaa7d69e4a4ecebebd0b26c40a9603702a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa749da3cff3fa57824a83eb994931dbc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#gaa749da3cff3fa57824a83eb994931dbc">doca_rdma_cap_get_max_send_queue_size</a> (const struct doca_devinfo *devinfo, uint32_t *max_send_queue_size)</td></tr>
<tr class="separator:gaa749da3cff3fa57824a83eb994931dbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad89662e98acbc23dd434ac05f2f5de4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#gaad89662e98acbc23dd434ac05f2f5de4">doca_rdma_cap_get_max_send_buf_list_len</a> (const struct doca_devinfo *devinfo, uint32_t *max_send_buf_list_len)</td></tr>
<tr class="memdesc:gaad89662e98acbc23dd434ac05f2f5de4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximal buffer list length property for buffers of tasks that are sent to the remote and in which linked list are supported (i.e. send, send_imm, read, write, write_imm).  <a href="group__DOCA__RDMA.html#gaad89662e98acbc23dd434ac05f2f5de4">More...</a><br /></td></tr>
<tr class="separator:gaad89662e98acbc23dd434ac05f2f5de4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf99113245debd46df6ee835b400bb98e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#gaf99113245debd46df6ee835b400bb98e">doca_rdma_cap_get_max_message_size</a> (const struct doca_devinfo *devinfo, uint32_t *max_message_size)</td></tr>
<tr class="memdesc:gaf99113245debd46df6ee835b400bb98e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximal message size for a specific device.  <a href="group__DOCA__RDMA.html#gaf99113245debd46df6ee835b400bb98e">More...</a><br /></td></tr>
<tr class="separator:gaf99113245debd46df6ee835b400bb98e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadeb98de0aebe0c410ec2dcb21d5da4d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#gadeb98de0aebe0c410ec2dcb21d5da4d8">doca_rdma_cap_get_gid_table_size</a> (const struct doca_devinfo *devinfo, uint32_t *gid_table_size)</td></tr>
<tr class="separator:gadeb98de0aebe0c410ec2dcb21d5da4d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d1690963d3d4e892c557cb9eeb51371"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga3d1690963d3d4e892c557cb9eeb51371">doca_rdma_cap_get_gid</a> (const struct doca_devinfo *devinfo, uint32_t start_index, uint32_t num_entries, struct <a class="el" href="structdoca__rdma__gid.html">doca_rdma_gid</a> *gid_array)</td></tr>
<tr class="separator:ga3d1690963d3d4e892c557cb9eeb51371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27dd6f343702a7ec4e1c0d236d50d690"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga27dd6f343702a7ec4e1c0d236d50d690">doca_rdma_cap_transport_type_is_supported</a> (const struct doca_devinfo *devinfo, enum <a class="el" href="group__DOCA__RDMA.html#gaa5f02468536d7f851c155978d0867e3a">doca_rdma_transport_type</a> transport_type)</td></tr>
<tr class="memdesc:ga27dd6f343702a7ec4e1c0d236d50d690"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if DOCA RDMA supports given transport type for a specific device.  <a href="group__DOCA__RDMA.html#ga27dd6f343702a7ec4e1c0d236d50d690">More...</a><br /></td></tr>
<tr class="separator:ga27dd6f343702a7ec4e1c0d236d50d690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b575af5ebdf6da3b0677530325cf635"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga6b575af5ebdf6da3b0677530325cf635">doca_rdma_set_send_queue_size</a> (struct doca_rdma *rdma, uint32_t send_queue_size)</td></tr>
<tr class="memdesc:ga6b575af5ebdf6da3b0677530325cf635"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set send queue size property for doca_rdma. The value can be queried using <a class="el" href="group__DOCA__RDMA.html#gaaa4f70d8e186af9ea2d5d77eccd50489" title="Get send queue size property from doca_rdma. Returns the current send_queue_size set for the doca_rdm...">doca_rdma_get_send_queue_size()</a>. Queue size will be rounded to the next power of 2. can only be called before calling <a class="el" href="group__DOCA__CTX.html#ga712a2c32ab9113f568d08c379ec506f7" title="Finalizes all configurations, and starts the DOCA CTX.">doca_ctx_start()</a>.  <a href="group__DOCA__RDMA.html#ga6b575af5ebdf6da3b0677530325cf635">More...</a><br /></td></tr>
<tr class="separator:ga6b575af5ebdf6da3b0677530325cf635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7acffe08c179eb43c5bd65c7dbaeeafb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga7acffe08c179eb43c5bd65c7dbaeeafb">doca_rdma_set_recv_queue_size</a> (struct doca_rdma *rdma, uint32_t recv_queue_size)</td></tr>
<tr class="memdesc:ga7acffe08c179eb43c5bd65c7dbaeeafb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set recv queue size property for doca_rdma. The value can be queried using <a class="el" href="group__DOCA__RDMA.html#gabff1b72c434f7faabfe8dcb1a6dc4950" title="Get recv queue size property from doca_rdma. Returns the current recv_queue_size set for the doca_rdm...">doca_rdma_get_recv_queue_size()</a>. Queue size will be rounded to the next power of 2.  <a href="group__DOCA__RDMA.html#ga7acffe08c179eb43c5bd65c7dbaeeafb">More...</a><br /></td></tr>
<tr class="separator:ga7acffe08c179eb43c5bd65c7dbaeeafb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafdc92935ee7fad23891df4213341fc04"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#gafdc92935ee7fad23891df4213341fc04">doca_rdma_set_max_send_buf_list_len</a> (struct doca_rdma *rdma, uint32_t max_send_buf_list_len)</td></tr>
<tr class="memdesc:gafdc92935ee7fad23891df4213341fc04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the maximum buffer list length property for local buffers of tasks that are sent to the remote and in which linked list are supported (i.e. send, send_imm, read, write, write_imm). The value in use can be queried using <a class="el" href="group__DOCA__RDMA.html#gad7948de5b8a3439c14324cf74be37543" title="Get the maximum buffer list length property for local buffers of tasks that are sent to the remote an...">doca_rdma_get_max_send_buf_list_len()</a>.  <a href="group__DOCA__RDMA.html#gafdc92935ee7fad23891df4213341fc04">More...</a><br /></td></tr>
<tr class="separator:gafdc92935ee7fad23891df4213341fc04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0665af3556845088dcc39452d9aebd9f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga0665af3556845088dcc39452d9aebd9f">doca_rdma_set_transport_type</a> (struct doca_rdma *rdma, enum <a class="el" href="group__DOCA__RDMA.html#gaa5f02468536d7f851c155978d0867e3a">doca_rdma_transport_type</a> transport_type)</td></tr>
<tr class="memdesc:ga0665af3556845088dcc39452d9aebd9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set transport type for doca_rdma. The value can be queried using <a class="el" href="group__DOCA__RDMA.html#ga646f0f2f92433782190715b8d58e83b9" title="Get transport_type property from doca_rdma. Returns the current transport_type set for the doca_rdma_...">doca_rdma_get_transport_type()</a>. Can only be called before calling <a class="el" href="group__DOCA__CTX.html#ga712a2c32ab9113f568d08c379ec506f7" title="Finalizes all configurations, and starts the DOCA CTX.">doca_ctx_start()</a>.  <a href="group__DOCA__RDMA.html#ga0665af3556845088dcc39452d9aebd9f">More...</a><br /></td></tr>
<tr class="separator:ga0665af3556845088dcc39452d9aebd9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8210867a75ae9e2c13064a6d8ee6c919"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga8210867a75ae9e2c13064a6d8ee6c919">doca_rdma_set_mtu</a> (struct doca_rdma *rdma, enum <a class="el" href="group__DOCA__TYPES.html#ga7925ef067096a2bb0fe8d1c997574ce7">doca_mtu_size</a> mtu)</td></tr>
<tr class="memdesc:ga8210867a75ae9e2c13064a6d8ee6c919"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set MTU for doca_rdma. The value can be queried using <a class="el" href="group__DOCA__RDMA.html#gafa926095c2fb3d94a86e6739ae8648d1" title="Get the MTU property from doca_rdma. Returns the current MTU set for the doca_rdma context.">doca_rdma_get_mtu()</a>. Can only be called before calling <a class="el" href="group__DOCA__CTX.html#ga712a2c32ab9113f568d08c379ec506f7" title="Finalizes all configurations, and starts the DOCA CTX.">doca_ctx_start()</a>.  <a href="group__DOCA__RDMA.html#ga8210867a75ae9e2c13064a6d8ee6c919">More...</a><br /></td></tr>
<tr class="separator:ga8210867a75ae9e2c13064a6d8ee6c919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga477ad6d95232d3805cb561ae1fe42ae7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga477ad6d95232d3805cb561ae1fe42ae7">doca_rdma_set_permissions</a> (struct doca_rdma *rdma, uint32_t permissions)</td></tr>
<tr class="memdesc:ga477ad6d95232d3805cb561ae1fe42ae7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set rdma permissions for doca_rdma. The value can be queried using <a class="el" href="group__DOCA__RDMA.html#gac5c4dec7e158362dc20a7e0e04f67508" title="Get permissions property from doca_rdma. Returns the current permissions set for the doca_rdma_contex...">doca_rdma_get_permissions()</a>. Can only be called after calling doca_ctx_dev_add() and before calling <a class="el" href="group__DOCA__CTX.html#ga712a2c32ab9113f568d08c379ec506f7" title="Finalizes all configurations, and starts the DOCA CTX.">doca_ctx_start()</a>. The supported permissions are the RDMA access flags.  <a href="group__DOCA__RDMA.html#ga477ad6d95232d3805cb561ae1fe42ae7">More...</a><br /></td></tr>
<tr class="separator:ga477ad6d95232d3805cb561ae1fe42ae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39d089dd17b4eb892f3941bd95f27790"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga39d089dd17b4eb892f3941bd95f27790">doca_rdma_set_grh_enabled</a> (struct doca_rdma *rdma, uint8_t grh_enabled)</td></tr>
<tr class="memdesc:ga39d089dd17b4eb892f3941bd95f27790"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set whether to use GRH in connection. The value can be queried using <a class="el" href="group__DOCA__RDMA.html#ga98e4c3bb034bb42de53144ed14fe8f34" title="Get GRH setting from doca_rdma. Get the current GRH setting for doca_rdma.">doca_rdma_get_grh_enabled()</a>. Can only be called before calling <a class="el" href="group__DOCA__CTX.html#ga712a2c32ab9113f568d08c379ec506f7" title="Finalizes all configurations, and starts the DOCA CTX.">doca_ctx_start()</a>.  <a href="group__DOCA__RDMA.html#ga39d089dd17b4eb892f3941bd95f27790">More...</a><br /></td></tr>
<tr class="separator:ga39d089dd17b4eb892f3941bd95f27790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9eb5eec4881e86a12fe3fadf6016999"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#gab9eb5eec4881e86a12fe3fadf6016999">doca_rdma_set_gid_index</a> (struct doca_rdma *rdma, uint32_t gid_index)</td></tr>
<tr class="memdesc:gab9eb5eec4881e86a12fe3fadf6016999"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set GID index for doca_rdma. The value can be queried using <a class="el" href="group__DOCA__RDMA.html#ga838585b7adf5dc400909b5f698546428" title="Get GID index from doca_rdma. Get the current GID index set for doca_rdma.">doca_rdma_get_gid_index()</a>. Can only be called before calling <a class="el" href="group__DOCA__CTX.html#ga712a2c32ab9113f568d08c379ec506f7" title="Finalizes all configurations, and starts the DOCA CTX.">doca_ctx_start()</a>.  <a href="group__DOCA__RDMA.html#gab9eb5eec4881e86a12fe3fadf6016999">More...</a><br /></td></tr>
<tr class="separator:gab9eb5eec4881e86a12fe3fadf6016999"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82689512c344c7e2cc2c6a38f6ea124d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga82689512c344c7e2cc2c6a38f6ea124d">doca_rdma_set_sl</a> (struct doca_rdma *rdma, uint32_t sl)</td></tr>
<tr class="memdesc:ga82689512c344c7e2cc2c6a38f6ea124d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set SL (service level) for doca_rdma. The value can be queried using <a class="el" href="group__DOCA__RDMA.html#ga68a6dc4d7352c6e4aa15ce5f26739643" title="Get SL (service level) from doca_rdma. Get the current SL set for doca_rdma.">doca_rdma_get_sl()</a>. Can only be called before calling <a class="el" href="group__DOCA__CTX.html#ga712a2c32ab9113f568d08c379ec506f7" title="Finalizes all configurations, and starts the DOCA CTX.">doca_ctx_start()</a>.  <a href="group__DOCA__RDMA.html#ga82689512c344c7e2cc2c6a38f6ea124d">More...</a><br /></td></tr>
<tr class="separator:ga82689512c344c7e2cc2c6a38f6ea124d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b399e2fe0befea3621fed7296b5cc26"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga5b399e2fe0befea3621fed7296b5cc26">doca_rdma_set_connection_request_timeout</a> (struct doca_rdma *rdma, uint16_t timeout)</td></tr>
<tr class="memdesc:ga5b399e2fe0befea3621fed7296b5cc26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set timeout property for doca_rdma. The value can be queried using <a class="el" href="group__DOCA__RDMA.html#ga8415240f5ee1d07c37c0f646b2c01a57" title="Get timeout property for doca_rdma. Returns the current timeout set for the connection resolve relate...">doca_rdma_get_connection_request_timeout()</a>.  <a href="group__DOCA__RDMA.html#ga5b399e2fe0befea3621fed7296b5cc26">More...</a><br /></td></tr>
<tr class="separator:ga5b399e2fe0befea3621fed7296b5cc26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5aac5afb092f77ee296b9ddf25ca8d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#gaf5aac5afb092f77ee296b9ddf25ca8d2">doca_rdma_connection_set_user_data</a> (struct doca_rdma_connection *rdma_connection, union <a class="el" href="uniondoca__data.html">doca_data</a> connection_user_data)</td></tr>
<tr class="memdesc:gaf5aac5afb092f77ee296b9ddf25ca8d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set user data to include in each connection.  <a href="group__DOCA__RDMA.html#gaf5aac5afb092f77ee296b9ddf25ca8d2">More...</a><br /></td></tr>
<tr class="separator:gaf5aac5afb092f77ee296b9ddf25ca8d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa16a128957eeff1f9947cc294171d0a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#gaa16a128957eeff1f9947cc294171d0a2">doca_rdma_set_max_num_connections</a> (struct doca_rdma *rdma, uint16_t max_num_connections)</td></tr>
<tr class="memdesc:gaa16a128957eeff1f9947cc294171d0a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the maximum number of connections property for a context. The value can be queried using <a class="el" href="group__DOCA__RDMA.html#ga75340a49b88e149c75e0cdbc0cfc60df" title="Get maximum number of connections property for doca_rdma. Returns the current maximum number of conne...">doca_rdma_get_max_num_connections()</a>.  <a href="group__DOCA__RDMA.html#gaa16a128957eeff1f9947cc294171d0a2">More...</a><br /></td></tr>
<tr class="separator:gaa16a128957eeff1f9947cc294171d0a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga997557391be9a742645d277a9e199129"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga997557391be9a742645d277a9e199129">doca_rdma_set_rnr_retry_count</a> (struct doca_rdma *rdma, uint8_t rnr_retry_count)</td></tr>
<tr class="memdesc:ga997557391be9a742645d277a9e199129"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the rnr retry count property for a context. The value can be queried using <a class="el" href="group__DOCA__RDMA.html#gaa6ced2e55dd626d11adb045b21edefe6" title="Get rnr retry count property for doca_rdma. Returns the current rnr retry count set for a context.">doca_rdma_get_rnr_retry_count()</a>.  <a href="group__DOCA__RDMA.html#ga997557391be9a742645d277a9e199129">More...</a><br /></td></tr>
<tr class="separator:ga997557391be9a742645d277a9e199129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa4f70d8e186af9ea2d5d77eccd50489"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#gaaa4f70d8e186af9ea2d5d77eccd50489">doca_rdma_get_send_queue_size</a> (const struct doca_rdma *rdma, uint32_t *send_queue_size)</td></tr>
<tr class="memdesc:gaaa4f70d8e186af9ea2d5d77eccd50489"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get send queue size property from doca_rdma. Returns the current send_queue_size set for the doca_rdma_context. The size returned is the actual size being used and might differ from the size set by the user, as the size may be increased.  <a href="group__DOCA__RDMA.html#gaaa4f70d8e186af9ea2d5d77eccd50489">More...</a><br /></td></tr>
<tr class="separator:gaaa4f70d8e186af9ea2d5d77eccd50489"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabff1b72c434f7faabfe8dcb1a6dc4950"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#gabff1b72c434f7faabfe8dcb1a6dc4950">doca_rdma_get_recv_queue_size</a> (const struct doca_rdma *rdma, uint32_t *recv_queue_size)</td></tr>
<tr class="memdesc:gabff1b72c434f7faabfe8dcb1a6dc4950"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get recv queue size property from doca_rdma. Returns the current recv_queue_size set for the doca_rdma_context. The size returned is the actual size being used and might differ from the size set by the user, as the size may be increased.  <a href="group__DOCA__RDMA.html#gabff1b72c434f7faabfe8dcb1a6dc4950">More...</a><br /></td></tr>
<tr class="separator:gabff1b72c434f7faabfe8dcb1a6dc4950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7948de5b8a3439c14324cf74be37543"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#gad7948de5b8a3439c14324cf74be37543">doca_rdma_get_max_send_buf_list_len</a> (const struct doca_rdma *rdma, uint32_t *max_send_buf_list_len)</td></tr>
<tr class="memdesc:gad7948de5b8a3439c14324cf74be37543"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum buffer list length property for local buffers of tasks that are sent to the remote and in which linked list are supported (i.e. send, send_imm, read, write, write_imm).  <a href="group__DOCA__RDMA.html#gad7948de5b8a3439c14324cf74be37543">More...</a><br /></td></tr>
<tr class="separator:gad7948de5b8a3439c14324cf74be37543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga646f0f2f92433782190715b8d58e83b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga646f0f2f92433782190715b8d58e83b9">doca_rdma_get_transport_type</a> (const struct doca_rdma *rdma, enum <a class="el" href="group__DOCA__RDMA.html#gaa5f02468536d7f851c155978d0867e3a">doca_rdma_transport_type</a> *transport_type)</td></tr>
<tr class="memdesc:ga646f0f2f92433782190715b8d58e83b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get transport_type property from doca_rdma. Returns the current transport_type set for the doca_rdma_context.  <a href="group__DOCA__RDMA.html#ga646f0f2f92433782190715b8d58e83b9">More...</a><br /></td></tr>
<tr class="separator:ga646f0f2f92433782190715b8d58e83b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa926095c2fb3d94a86e6739ae8648d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#gafa926095c2fb3d94a86e6739ae8648d1">doca_rdma_get_mtu</a> (const struct doca_rdma *rdma, enum <a class="el" href="group__DOCA__TYPES.html#ga7925ef067096a2bb0fe8d1c997574ce7">doca_mtu_size</a> *mtu)</td></tr>
<tr class="memdesc:gafa926095c2fb3d94a86e6739ae8648d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the MTU property from doca_rdma. Returns the current MTU set for the doca_rdma context.  <a href="group__DOCA__RDMA.html#gafa926095c2fb3d94a86e6739ae8648d1">More...</a><br /></td></tr>
<tr class="separator:gafa926095c2fb3d94a86e6739ae8648d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5c4dec7e158362dc20a7e0e04f67508"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#gac5c4dec7e158362dc20a7e0e04f67508">doca_rdma_get_permissions</a> (struct doca_rdma *rdma, uint32_t *permissions)</td></tr>
<tr class="memdesc:gac5c4dec7e158362dc20a7e0e04f67508"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get permissions property from doca_rdma. Returns the current permissions set for the doca_rdma_context. Can only be called after calling doca_ctx_dev_add().  <a href="group__DOCA__RDMA.html#gac5c4dec7e158362dc20a7e0e04f67508">More...</a><br /></td></tr>
<tr class="separator:gac5c4dec7e158362dc20a7e0e04f67508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98e4c3bb034bb42de53144ed14fe8f34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga98e4c3bb034bb42de53144ed14fe8f34">doca_rdma_get_grh_enabled</a> (const struct doca_rdma *rdma, uint8_t *grh_enabled)</td></tr>
<tr class="memdesc:ga98e4c3bb034bb42de53144ed14fe8f34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get GRH setting from doca_rdma. Get the current GRH setting for doca_rdma.  <a href="group__DOCA__RDMA.html#ga98e4c3bb034bb42de53144ed14fe8f34">More...</a><br /></td></tr>
<tr class="separator:ga98e4c3bb034bb42de53144ed14fe8f34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga838585b7adf5dc400909b5f698546428"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga838585b7adf5dc400909b5f698546428">doca_rdma_get_gid_index</a> (const struct doca_rdma *rdma, uint32_t *gid_index)</td></tr>
<tr class="memdesc:ga838585b7adf5dc400909b5f698546428"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get GID index from doca_rdma. Get the current GID index set for doca_rdma.  <a href="group__DOCA__RDMA.html#ga838585b7adf5dc400909b5f698546428">More...</a><br /></td></tr>
<tr class="separator:ga838585b7adf5dc400909b5f698546428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68a6dc4d7352c6e4aa15ce5f26739643"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga68a6dc4d7352c6e4aa15ce5f26739643">doca_rdma_get_sl</a> (const struct doca_rdma *rdma, uint32_t *sl)</td></tr>
<tr class="memdesc:ga68a6dc4d7352c6e4aa15ce5f26739643"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get SL (service level) from doca_rdma. Get the current SL set for doca_rdma.  <a href="group__DOCA__RDMA.html#ga68a6dc4d7352c6e4aa15ce5f26739643">More...</a><br /></td></tr>
<tr class="separator:ga68a6dc4d7352c6e4aa15ce5f26739643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga702e1059ea42fa21f5e85cc23fd0a898"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga702e1059ea42fa21f5e85cc23fd0a898">doca_rdma_get_dpa_handle</a> (struct doca_rdma *rdma, <a class="el" href="group__DOCA__RDMA.html#gadb533b1f5e0b511e7eec6d74e738193b">doca_dpa_dev_rdma_t</a> *dpa_rdma)</td></tr>
<tr class="memdesc:ga702e1059ea42fa21f5e85cc23fd0a898"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the handle in the dpa memory space of a doca_rdma.  <a href="group__DOCA__RDMA.html#ga702e1059ea42fa21f5e85cc23fd0a898">More...</a><br /></td></tr>
<tr class="separator:ga702e1059ea42fa21f5e85cc23fd0a898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07ff3c69e9c92bcbc828c241681c53d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga07ff3c69e9c92bcbc828c241681c53d4">doca_rdma_get_gpu_handle</a> (struct doca_rdma *rdma, struct doca_gpu_dev_rdma **gpu_rdma)</td></tr>
<tr class="memdesc:ga07ff3c69e9c92bcbc828c241681c53d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the handle in the gpu memory space of a doca_rdma.  <a href="group__DOCA__RDMA.html#ga07ff3c69e9c92bcbc828c241681c53d4">More...</a><br /></td></tr>
<tr class="separator:ga07ff3c69e9c92bcbc828c241681c53d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8415240f5ee1d07c37c0f646b2c01a57"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga8415240f5ee1d07c37c0f646b2c01a57">doca_rdma_get_connection_request_timeout</a> (const struct doca_rdma *rdma, uint16_t *timeout)</td></tr>
<tr class="memdesc:ga8415240f5ee1d07c37c0f646b2c01a57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get timeout property for doca_rdma. Returns the current timeout set for the connection resolve related functions. The size returned is the actual size being used and might differ from the size set by the user, as the size may be increased.  <a href="group__DOCA__RDMA.html#ga8415240f5ee1d07c37c0f646b2c01a57">More...</a><br /></td></tr>
<tr class="separator:ga8415240f5ee1d07c37c0f646b2c01a57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3be468cbf62683acfe30eac98f334aca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga3be468cbf62683acfe30eac98f334aca">doca_rdma_connection_get_addr</a> (const struct doca_rdma_connection *rdma_connection, struct doca_rdma_addr **<a class="el" href="doca__dpa__dev__buf_8h.html#a845b126697becc1d429671f8a49e1c37">addr</a>)</td></tr>
<tr class="memdesc:ga3be468cbf62683acfe30eac98f334aca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get connection address object from a doca_rdma_connection.  <a href="group__DOCA__RDMA.html#ga3be468cbf62683acfe30eac98f334aca">More...</a><br /></td></tr>
<tr class="separator:ga3be468cbf62683acfe30eac98f334aca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2cbac1236b1221787ea483168da8ca55"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga2cbac1236b1221787ea483168da8ca55">doca_rdma_addr_get_params</a> (struct doca_rdma_addr *<a class="el" href="doca__dpa__dev__buf_8h.html#a845b126697becc1d429671f8a49e1c37">addr</a>, enum <a class="el" href="group__DOCA__RDMA.html#ga9b86300b1a5ece749397138a3aeba419">doca_rdma_addr_type</a> *addr_type, const char **address, uint16_t *port)</td></tr>
<tr class="memdesc:ga2cbac1236b1221787ea483168da8ca55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get address object parameters from an address object.  <a href="group__DOCA__RDMA.html#ga2cbac1236b1221787ea483168da8ca55">More...</a><br /></td></tr>
<tr class="separator:ga2cbac1236b1221787ea483168da8ca55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32aa8a402e52a2e01af8e82393ab6c63"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga32aa8a402e52a2e01af8e82393ab6c63">doca_rdma_connection_get_user_data</a> (const struct doca_rdma_connection *rdma_connection, union <a class="el" href="uniondoca__data.html">doca_data</a> *connection_user_data)</td></tr>
<tr class="memdesc:ga32aa8a402e52a2e01af8e82393ab6c63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get user data included in a connection.  <a href="group__DOCA__RDMA.html#ga32aa8a402e52a2e01af8e82393ab6c63">More...</a><br /></td></tr>
<tr class="separator:ga32aa8a402e52a2e01af8e82393ab6c63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74f2ef227b9ed3db6defec06452d6e04"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga74f2ef227b9ed3db6defec06452d6e04">doca_rdma_connection_get_id</a> (const struct doca_rdma_connection *rdma_connection, uint32_t *connection_id)</td></tr>
<tr class="memdesc:ga74f2ef227b9ed3db6defec06452d6e04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get connection ID from an rdma connection.  <a href="group__DOCA__RDMA.html#ga74f2ef227b9ed3db6defec06452d6e04">More...</a><br /></td></tr>
<tr class="separator:ga74f2ef227b9ed3db6defec06452d6e04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75340a49b88e149c75e0cdbc0cfc60df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga75340a49b88e149c75e0cdbc0cfc60df">doca_rdma_get_max_num_connections</a> (struct doca_rdma *rdma, uint16_t *max_num_connections)</td></tr>
<tr class="memdesc:ga75340a49b88e149c75e0cdbc0cfc60df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get maximum number of connections property for doca_rdma. Returns the current maximum number of connections set for a context.  <a href="group__DOCA__RDMA.html#ga75340a49b88e149c75e0cdbc0cfc60df">More...</a><br /></td></tr>
<tr class="separator:ga75340a49b88e149c75e0cdbc0cfc60df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6ced2e55dd626d11adb045b21edefe6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#gaa6ced2e55dd626d11adb045b21edefe6">doca_rdma_get_rnr_retry_count</a> (const struct doca_rdma *rdma, uint8_t *rnr_retry_count)</td></tr>
<tr class="memdesc:gaa6ced2e55dd626d11adb045b21edefe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get rnr retry count property for doca_rdma. Returns the current rnr retry count set for a context.  <a href="group__DOCA__RDMA.html#gaa6ced2e55dd626d11adb045b21edefe6">More...</a><br /></td></tr>
<tr class="separator:gaa6ced2e55dd626d11adb045b21edefe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42e9eeda69f029219b0f1644e0a778a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga42e9eeda69f029219b0f1644e0a778a0">doca_rdma_set_connection_state_callbacks</a> (struct doca_rdma *rdma, <a class="el" href="group__DOCA__RDMA.html#ga32d1ed957b273e7c459a8d0f71dded3f">doca_rdma_connection_request_cb_t</a> doca_rdma_connect_request_cb, <a class="el" href="group__DOCA__RDMA.html#gac64a10cc83ec29159975883df89b9507">doca_rdma_connection_established_cb_t</a> doca_rdma_connect_established_cb, <a class="el" href="group__DOCA__RDMA.html#ga759d54b2fef283bc8f92c2ae29187fce">doca_rdma_connection_failure_cb_t</a> doca_rdma_connect_failure_cb, <a class="el" href="group__DOCA__RDMA.html#ga5c9391e450ddc64b3d26700a26dedba7">doca_rdma_connection_disconnection_cb_t</a> doca_rdma_disconnect_cb)</td></tr>
<tr class="memdesc:ga42e9eeda69f029219b0f1644e0a778a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method set the function executed on RDMA connection events.  <a href="group__DOCA__RDMA.html#ga42e9eeda69f029219b0f1644e0a778a0">More...</a><br /></td></tr>
<tr class="separator:ga42e9eeda69f029219b0f1644e0a778a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2decae4b7b4b05eb41a76f87bc8e127"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#gab2decae4b7b4b05eb41a76f87bc8e127">doca_rdma_cap_task_receive_is_supported</a> (const struct doca_devinfo *devinfo)</td></tr>
<tr class="separator:gab2decae4b7b4b05eb41a76f87bc8e127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d6858ec036a6a5ffc5f24236cfa3d21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga3d6858ec036a6a5ffc5f24236cfa3d21">doca_rdma_cap_task_receive_get_max_dst_buf_list_len</a> (const struct doca_devinfo *devinfo, enum <a class="el" href="group__DOCA__RDMA.html#gaa5f02468536d7f851c155978d0867e3a">doca_rdma_transport_type</a> transport_type, uint32_t *max_buf_list_len)</td></tr>
<tr class="separator:ga3d6858ec036a6a5ffc5f24236cfa3d21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a7a4d6c724e0d918d85282c42d491dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga7a7a4d6c724e0d918d85282c42d491dd">doca_rdma_task_receive_set_conf</a> (struct doca_rdma *rdma, <a class="el" href="group__DOCA__RDMA.html#ga0408ed0a480a862797dcede45efee761">doca_rdma_task_receive_completion_cb_t</a> successful_task_completion_cb, <a class="el" href="group__DOCA__RDMA.html#ga0408ed0a480a862797dcede45efee761">doca_rdma_task_receive_completion_cb_t</a> error_task_completion_cb, uint32_t num_tasks)</td></tr>
<tr class="memdesc:ga7a7a4d6c724e0d918d85282c42d491dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method sets the receive tasks configuration.  <a href="group__DOCA__RDMA.html#ga7a7a4d6c724e0d918d85282c42d491dd">More...</a><br /></td></tr>
<tr class="separator:ga7a7a4d6c724e0d918d85282c42d491dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa747f37e09930ed68a42a3a2f0aec94a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#gaa747f37e09930ed68a42a3a2f0aec94a">doca_rdma_task_receive_set_dst_buf_list_len</a> (struct doca_rdma *rdma, uint32_t buf_list_len)</td></tr>
<tr class="memdesc:gaa747f37e09930ed68a42a3a2f0aec94a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the maximal destination buffer list length property for receive tasks. After starting the DOCA RDMA context the length may be increased and the value in use can be queried using doca_rdma_get_recv_buf_list_len().  <a href="group__DOCA__RDMA.html#gaa747f37e09930ed68a42a3a2f0aec94a">More...</a><br /></td></tr>
<tr class="separator:gaa747f37e09930ed68a42a3a2f0aec94a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab322e884f5510dc205914c6a3d33ab77"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#gab322e884f5510dc205914c6a3d33ab77">doca_rdma_task_receive_get_dst_buf_list_len</a> (const struct doca_rdma *rdma, uint32_t *buf_list_len)</td></tr>
<tr class="memdesc:gab322e884f5510dc205914c6a3d33ab77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximal destination buffer list length property for receive tasks. The returned value is the actual value being used and might differ from the size set by the user, as it may be increased.  <a href="group__DOCA__RDMA.html#gab322e884f5510dc205914c6a3d33ab77">More...</a><br /></td></tr>
<tr class="separator:gab322e884f5510dc205914c6a3d33ab77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga924d2cb1bb97098b43a19e0351e56444"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga924d2cb1bb97098b43a19e0351e56444">doca_rdma_task_receive_allocate_init</a> (struct doca_rdma *rdma, struct doca_buf *dst_buf, union <a class="el" href="uniondoca__data.html">doca_data</a> user_data, struct doca_rdma_task_receive **task)</td></tr>
<tr class="memdesc:ga924d2cb1bb97098b43a19e0351e56444"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method allocates and initializes a receive task.  <a href="group__DOCA__RDMA.html#ga924d2cb1bb97098b43a19e0351e56444">More...</a><br /></td></tr>
<tr class="separator:ga924d2cb1bb97098b43a19e0351e56444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga553f007d0acabb31b3837f2bd15fda34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> struct doca_task *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga553f007d0acabb31b3837f2bd15fda34">doca_rdma_task_receive_as_task</a> (struct doca_rdma_task_receive *task)</td></tr>
<tr class="memdesc:ga553f007d0acabb31b3837f2bd15fda34"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method converts a receive task to a doca_task.  <a href="group__DOCA__RDMA.html#ga553f007d0acabb31b3837f2bd15fda34">More...</a><br /></td></tr>
<tr class="separator:ga553f007d0acabb31b3837f2bd15fda34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadce2104fd412c2a131349e9cee97001c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#gadce2104fd412c2a131349e9cee97001c">doca_rdma_task_receive_set_dst_buf</a> (struct doca_rdma_task_receive *task, struct doca_buf *dst_buf)</td></tr>
<tr class="memdesc:gadce2104fd412c2a131349e9cee97001c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method sets the destination buffer of a receive task.  <a href="group__DOCA__RDMA.html#gadce2104fd412c2a131349e9cee97001c">More...</a><br /></td></tr>
<tr class="separator:gadce2104fd412c2a131349e9cee97001c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00f157a503c56605cedebb5624118d9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> struct doca_buf *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga00f157a503c56605cedebb5624118d9c">doca_rdma_task_receive_get_dst_buf</a> (const struct doca_rdma_task_receive *task)</td></tr>
<tr class="memdesc:ga00f157a503c56605cedebb5624118d9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method gets the destination buffer of a receive task.  <a href="group__DOCA__RDMA.html#ga00f157a503c56605cedebb5624118d9c">More...</a><br /></td></tr>
<tr class="separator:ga00f157a503c56605cedebb5624118d9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga389747420fbfff3ac2c6d9b905efe6ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> enum <a class="el" href="group__DOCA__RDMA.html#ga3cbcdbcd5adcbc7aa0b4eae4376ec9c8">doca_rdma_opcode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga389747420fbfff3ac2c6d9b905efe6ed">doca_rdma_task_receive_get_result_opcode</a> (const struct doca_rdma_task_receive *task)</td></tr>
<tr class="memdesc:ga389747420fbfff3ac2c6d9b905efe6ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method gets the opcode of the operation executed by the peer and received by the task.  <a href="group__DOCA__RDMA.html#ga389747420fbfff3ac2c6d9b905efe6ed">More...</a><br /></td></tr>
<tr class="separator:ga389747420fbfff3ac2c6d9b905efe6ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae26a447dcbf280ea2b9b5ed839df5f63"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#gae26a447dcbf280ea2b9b5ed839df5f63">doca_rdma_task_receive_get_result_len</a> (const struct doca_rdma_task_receive *task)</td></tr>
<tr class="memdesc:gae26a447dcbf280ea2b9b5ed839df5f63"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method gets the length of data received by the task.  <a href="group__DOCA__RDMA.html#gae26a447dcbf280ea2b9b5ed839df5f63">More...</a><br /></td></tr>
<tr class="separator:gae26a447dcbf280ea2b9b5ed839df5f63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18f11933847e06c02ed3b511dead5160"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__TYPES.html#ga37ca3c7aed1aadba64e71712ea0e069f">doca_be32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga18f11933847e06c02ed3b511dead5160">doca_rdma_task_receive_get_result_immediate_data</a> (const struct doca_rdma_task_receive *task)</td></tr>
<tr class="memdesc:ga18f11933847e06c02ed3b511dead5160"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method gets the immediate data received by the task.  <a href="group__DOCA__RDMA.html#ga18f11933847e06c02ed3b511dead5160">More...</a><br /></td></tr>
<tr class="separator:ga18f11933847e06c02ed3b511dead5160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6dae1573a3d8cba7a8cf98624033af2a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> const struct doca_rdma_connection *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga6dae1573a3d8cba7a8cf98624033af2a">doca_rdma_task_receive_get_result_rdma_connection</a> (const struct doca_rdma_task_receive *task)</td></tr>
<tr class="memdesc:ga6dae1573a3d8cba7a8cf98624033af2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method gets the rdma connection of a receive task.  <a href="group__DOCA__RDMA.html#ga6dae1573a3d8cba7a8cf98624033af2a">More...</a><br /></td></tr>
<tr class="separator:ga6dae1573a3d8cba7a8cf98624033af2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedee61ea26e87780c9e5121f40d68295"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#gaedee61ea26e87780c9e5121f40d68295">doca_rdma_cap_task_send_is_supported</a> (const struct doca_devinfo *devinfo)</td></tr>
<tr class="separator:gaedee61ea26e87780c9e5121f40d68295"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15606de845e3940374c61c1a5a7a5782"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga15606de845e3940374c61c1a5a7a5782">doca_rdma_task_send_set_conf</a> (struct doca_rdma *rdma, <a class="el" href="group__DOCA__RDMA.html#ga8e87e2039e435abe52200598623f0cac">doca_rdma_task_send_completion_cb_t</a> successful_task_completion_cb, <a class="el" href="group__DOCA__RDMA.html#ga8e87e2039e435abe52200598623f0cac">doca_rdma_task_send_completion_cb_t</a> error_task_completion_cb, uint32_t num_tasks)</td></tr>
<tr class="memdesc:ga15606de845e3940374c61c1a5a7a5782"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method sets the send tasks configuration.  <a href="group__DOCA__RDMA.html#ga15606de845e3940374c61c1a5a7a5782">More...</a><br /></td></tr>
<tr class="separator:ga15606de845e3940374c61c1a5a7a5782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaced6b369d13e033006d9061e9ebb9745"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#gaced6b369d13e033006d9061e9ebb9745">doca_rdma_task_send_allocate_init</a> (struct doca_rdma *rdma, struct doca_rdma_connection *rdma_connection, const struct doca_buf *src_buf, union <a class="el" href="uniondoca__data.html">doca_data</a> user_data, struct doca_rdma_task_send **task)</td></tr>
<tr class="memdesc:gaced6b369d13e033006d9061e9ebb9745"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method allocates and initializes a send task.  <a href="group__DOCA__RDMA.html#gaced6b369d13e033006d9061e9ebb9745">More...</a><br /></td></tr>
<tr class="separator:gaced6b369d13e033006d9061e9ebb9745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c1347cb733ff6372d7cc2d58ef8379d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> struct doca_task *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga8c1347cb733ff6372d7cc2d58ef8379d">doca_rdma_task_send_as_task</a> (struct doca_rdma_task_send *task)</td></tr>
<tr class="memdesc:ga8c1347cb733ff6372d7cc2d58ef8379d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method converts a send task to a doca_task.  <a href="group__DOCA__RDMA.html#ga8c1347cb733ff6372d7cc2d58ef8379d">More...</a><br /></td></tr>
<tr class="separator:ga8c1347cb733ff6372d7cc2d58ef8379d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fcf031d9e8fd7292a4a225b6aaadd7e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga4fcf031d9e8fd7292a4a225b6aaadd7e">doca_rdma_task_send_set_src_buf</a> (struct doca_rdma_task_send *task, const struct doca_buf *src_buf)</td></tr>
<tr class="memdesc:ga4fcf031d9e8fd7292a4a225b6aaadd7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method sets the source buffer of a send task.  <a href="group__DOCA__RDMA.html#ga4fcf031d9e8fd7292a4a225b6aaadd7e">More...</a><br /></td></tr>
<tr class="separator:ga4fcf031d9e8fd7292a4a225b6aaadd7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e1187c092b6deb22d8e49301ddde1d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> const struct doca_buf *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga3e1187c092b6deb22d8e49301ddde1d5">doca_rdma_task_send_get_src_buf</a> (const struct doca_rdma_task_send *task)</td></tr>
<tr class="memdesc:ga3e1187c092b6deb22d8e49301ddde1d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method gets the source buffer of a send task.  <a href="group__DOCA__RDMA.html#ga3e1187c092b6deb22d8e49301ddde1d5">More...</a><br /></td></tr>
<tr class="separator:ga3e1187c092b6deb22d8e49301ddde1d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c09c589aae170ae6185dda475b9e135"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga9c09c589aae170ae6185dda475b9e135">doca_rdma_task_send_set_rdma_connection</a> (struct doca_rdma_task_send *task, struct doca_rdma_connection *rdma_connection)</td></tr>
<tr class="memdesc:ga9c09c589aae170ae6185dda475b9e135"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method sets the rdma_connection of a send task.  <a href="group__DOCA__RDMA.html#ga9c09c589aae170ae6185dda475b9e135">More...</a><br /></td></tr>
<tr class="separator:ga9c09c589aae170ae6185dda475b9e135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d5c195fa2b645a2a33374db759af72f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> const struct doca_rdma_connection *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga3d5c195fa2b645a2a33374db759af72f">doca_rdma_task_send_get_rdma_connection</a> (const struct doca_rdma_task_send *task)</td></tr>
<tr class="memdesc:ga3d5c195fa2b645a2a33374db759af72f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method gets the rdma connection of a send task.  <a href="group__DOCA__RDMA.html#ga3d5c195fa2b645a2a33374db759af72f">More...</a><br /></td></tr>
<tr class="separator:ga3d5c195fa2b645a2a33374db759af72f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91863c5ad3e9ed8ac9f37861bba6bc70"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga91863c5ad3e9ed8ac9f37861bba6bc70">doca_rdma_cap_task_send_imm_is_supported</a> (const struct doca_devinfo *devinfo)</td></tr>
<tr class="separator:ga91863c5ad3e9ed8ac9f37861bba6bc70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga655423e7adf87dcb3e42127acc5e0c9a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga655423e7adf87dcb3e42127acc5e0c9a">doca_rdma_task_send_imm_set_conf</a> (struct doca_rdma *rdma, <a class="el" href="group__DOCA__RDMA.html#ga86fa09af84fd6b25a24ba2e64e8d0360">doca_rdma_task_send_imm_completion_cb_t</a> successful_task_completion_cb, <a class="el" href="group__DOCA__RDMA.html#ga86fa09af84fd6b25a24ba2e64e8d0360">doca_rdma_task_send_imm_completion_cb_t</a> error_task_completion_cb, uint32_t num_tasks)</td></tr>
<tr class="memdesc:ga655423e7adf87dcb3e42127acc5e0c9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method sets the send with immediate tasks configuration.  <a href="group__DOCA__RDMA.html#ga655423e7adf87dcb3e42127acc5e0c9a">More...</a><br /></td></tr>
<tr class="separator:ga655423e7adf87dcb3e42127acc5e0c9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1873254f7307b4ab29576db45208878d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga1873254f7307b4ab29576db45208878d">doca_rdma_task_send_imm_allocate_init</a> (struct doca_rdma *rdma, struct doca_rdma_connection *rdma_connection, const struct doca_buf *src_buf, <a class="el" href="group__DOCA__TYPES.html#ga37ca3c7aed1aadba64e71712ea0e069f">doca_be32_t</a> immediate_data, union <a class="el" href="uniondoca__data.html">doca_data</a> user_data, struct doca_rdma_task_send_imm **task)</td></tr>
<tr class="memdesc:ga1873254f7307b4ab29576db45208878d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method allocates and initializes a send with immediate task.  <a href="group__DOCA__RDMA.html#ga1873254f7307b4ab29576db45208878d">More...</a><br /></td></tr>
<tr class="separator:ga1873254f7307b4ab29576db45208878d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga394ca996da1e5413ede353c63932869d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> struct doca_task *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga394ca996da1e5413ede353c63932869d">doca_rdma_task_send_imm_as_task</a> (struct doca_rdma_task_send_imm *task)</td></tr>
<tr class="memdesc:ga394ca996da1e5413ede353c63932869d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method converts a send with immediate task to a doca_task.  <a href="group__DOCA__RDMA.html#ga394ca996da1e5413ede353c63932869d">More...</a><br /></td></tr>
<tr class="separator:ga394ca996da1e5413ede353c63932869d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd620c2fd40f4f1d4a3400988430f9f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#gacd620c2fd40f4f1d4a3400988430f9f1">doca_rdma_task_send_imm_set_src_buf</a> (struct doca_rdma_task_send_imm *task, const struct doca_buf *src_buf)</td></tr>
<tr class="memdesc:gacd620c2fd40f4f1d4a3400988430f9f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method sets the source buffer of a send with immediate task.  <a href="group__DOCA__RDMA.html#gacd620c2fd40f4f1d4a3400988430f9f1">More...</a><br /></td></tr>
<tr class="separator:gacd620c2fd40f4f1d4a3400988430f9f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad558ab87c69e6c9a98b91e366cd1f3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> const struct doca_buf *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#gaad558ab87c69e6c9a98b91e366cd1f3d">doca_rdma_task_send_imm_get_src_buf</a> (const struct doca_rdma_task_send_imm *task)</td></tr>
<tr class="memdesc:gaad558ab87c69e6c9a98b91e366cd1f3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method gets the source buffer of a send with immediate task.  <a href="group__DOCA__RDMA.html#gaad558ab87c69e6c9a98b91e366cd1f3d">More...</a><br /></td></tr>
<tr class="separator:gaad558ab87c69e6c9a98b91e366cd1f3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec5cebb393ee713a7080b11f4fbffb1d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#gaec5cebb393ee713a7080b11f4fbffb1d">doca_rdma_task_send_imm_set_immediate_data</a> (struct doca_rdma_task_send_imm *task, <a class="el" href="group__DOCA__TYPES.html#ga37ca3c7aed1aadba64e71712ea0e069f">doca_be32_t</a> immediate_data)</td></tr>
<tr class="memdesc:gaec5cebb393ee713a7080b11f4fbffb1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method sets the immediate data of a send with immediate task.  <a href="group__DOCA__RDMA.html#gaec5cebb393ee713a7080b11f4fbffb1d">More...</a><br /></td></tr>
<tr class="separator:gaec5cebb393ee713a7080b11f4fbffb1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga724b865451587721499c1fcbb6f10df8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__TYPES.html#ga37ca3c7aed1aadba64e71712ea0e069f">doca_be32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga724b865451587721499c1fcbb6f10df8">doca_rdma_task_send_imm_get_immediate_data</a> (const struct doca_rdma_task_send_imm *task)</td></tr>
<tr class="memdesc:ga724b865451587721499c1fcbb6f10df8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method gets the immediate data of a send with immediate task.  <a href="group__DOCA__RDMA.html#ga724b865451587721499c1fcbb6f10df8">More...</a><br /></td></tr>
<tr class="separator:ga724b865451587721499c1fcbb6f10df8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7566d48addd132b1f338036ae6928071"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga7566d48addd132b1f338036ae6928071">doca_rdma_task_send_imm_set_rdma_connection</a> (struct doca_rdma_task_send_imm *task, struct doca_rdma_connection *rdma_connection)</td></tr>
<tr class="memdesc:ga7566d48addd132b1f338036ae6928071"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method sets the rdma_connection of a send with immediate task.  <a href="group__DOCA__RDMA.html#ga7566d48addd132b1f338036ae6928071">More...</a><br /></td></tr>
<tr class="separator:ga7566d48addd132b1f338036ae6928071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d64bdb6b7f4813ad9cb4565d722771b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> const struct doca_rdma_connection *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga0d64bdb6b7f4813ad9cb4565d722771b">doca_rdma_task_send_imm_get_rdma_connection</a> (const struct doca_rdma_task_send_imm *task)</td></tr>
<tr class="memdesc:ga0d64bdb6b7f4813ad9cb4565d722771b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method gets the rdma connection of a send with immediate task.  <a href="group__DOCA__RDMA.html#ga0d64bdb6b7f4813ad9cb4565d722771b">More...</a><br /></td></tr>
<tr class="separator:ga0d64bdb6b7f4813ad9cb4565d722771b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae439f1dd47116a7b844b45a57bb4462e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#gae439f1dd47116a7b844b45a57bb4462e">doca_rdma_cap_task_read_is_supported</a> (const struct doca_devinfo *devinfo)</td></tr>
<tr class="separator:gae439f1dd47116a7b844b45a57bb4462e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga952a6e977e9475cd1e9a12e782aa3186"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga952a6e977e9475cd1e9a12e782aa3186">doca_rdma_task_read_set_conf</a> (struct doca_rdma *rdma, <a class="el" href="group__DOCA__RDMA.html#gabc2c0386e7673546d9808fe3fda055f5">doca_rdma_task_read_completion_cb_t</a> successful_task_completion_cb, <a class="el" href="group__DOCA__RDMA.html#gabc2c0386e7673546d9808fe3fda055f5">doca_rdma_task_read_completion_cb_t</a> error_task_completion_cb, uint32_t num_tasks)</td></tr>
<tr class="memdesc:ga952a6e977e9475cd1e9a12e782aa3186"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method sets the read tasks configuration.  <a href="group__DOCA__RDMA.html#ga952a6e977e9475cd1e9a12e782aa3186">More...</a><br /></td></tr>
<tr class="separator:ga952a6e977e9475cd1e9a12e782aa3186"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fba29df9779dec32ac4682083d599f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga4fba29df9779dec32ac4682083d599f0">doca_rdma_task_read_allocate_init</a> (struct doca_rdma *rdma, struct doca_rdma_connection *rdma_connection, const struct doca_buf *src_buf, struct doca_buf *dst_buf, union <a class="el" href="uniondoca__data.html">doca_data</a> user_data, struct doca_rdma_task_read **task)</td></tr>
<tr class="memdesc:ga4fba29df9779dec32ac4682083d599f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method allocates and initializes a read task.  <a href="group__DOCA__RDMA.html#ga4fba29df9779dec32ac4682083d599f0">More...</a><br /></td></tr>
<tr class="separator:ga4fba29df9779dec32ac4682083d599f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaed3f9c9b3b0195789877979ebde63b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> struct doca_task *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#gaaed3f9c9b3b0195789877979ebde63b3">doca_rdma_task_read_as_task</a> (struct doca_rdma_task_read *task)</td></tr>
<tr class="memdesc:gaaed3f9c9b3b0195789877979ebde63b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method converts a read task to a doca_task.  <a href="group__DOCA__RDMA.html#gaaed3f9c9b3b0195789877979ebde63b3">More...</a><br /></td></tr>
<tr class="separator:gaaed3f9c9b3b0195789877979ebde63b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab99613a47053e922c4f3afeccd7bb194"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#gab99613a47053e922c4f3afeccd7bb194">doca_rdma_task_read_set_src_buf</a> (struct doca_rdma_task_read *task, const struct doca_buf *src_buf)</td></tr>
<tr class="memdesc:gab99613a47053e922c4f3afeccd7bb194"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method sets the source buffer of a read task.  <a href="group__DOCA__RDMA.html#gab99613a47053e922c4f3afeccd7bb194">More...</a><br /></td></tr>
<tr class="separator:gab99613a47053e922c4f3afeccd7bb194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2de872c4af8336beb235d67f824b572"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> const struct doca_buf *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#gab2de872c4af8336beb235d67f824b572">doca_rdma_task_read_get_src_buf</a> (const struct doca_rdma_task_read *task)</td></tr>
<tr class="memdesc:gab2de872c4af8336beb235d67f824b572"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method gets the source buffer of a read task.  <a href="group__DOCA__RDMA.html#gab2de872c4af8336beb235d67f824b572">More...</a><br /></td></tr>
<tr class="separator:gab2de872c4af8336beb235d67f824b572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8abff611cfb5756c78018d3cd72a957d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga8abff611cfb5756c78018d3cd72a957d">doca_rdma_task_read_set_dst_buf</a> (struct doca_rdma_task_read *task, struct doca_buf *dst_buf)</td></tr>
<tr class="memdesc:ga8abff611cfb5756c78018d3cd72a957d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method sets the destination buffer of a read task.  <a href="group__DOCA__RDMA.html#ga8abff611cfb5756c78018d3cd72a957d">More...</a><br /></td></tr>
<tr class="separator:ga8abff611cfb5756c78018d3cd72a957d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafaf7fc6ba81673aae5b0f86ca385192f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> struct doca_buf *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#gafaf7fc6ba81673aae5b0f86ca385192f">doca_rdma_task_read_get_dst_buf</a> (const struct doca_rdma_task_read *task)</td></tr>
<tr class="memdesc:gafaf7fc6ba81673aae5b0f86ca385192f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method gets the destination buffer of a read task.  <a href="group__DOCA__RDMA.html#gafaf7fc6ba81673aae5b0f86ca385192f">More...</a><br /></td></tr>
<tr class="separator:gafaf7fc6ba81673aae5b0f86ca385192f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafaf1b666dff5e9f0c04a5bfde332a70f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#gafaf1b666dff5e9f0c04a5bfde332a70f">doca_rdma_task_read_get_result_len</a> (const struct doca_rdma_task_read *task)</td></tr>
<tr class="memdesc:gafaf1b666dff5e9f0c04a5bfde332a70f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method gets the length of data read by the task.  <a href="group__DOCA__RDMA.html#gafaf1b666dff5e9f0c04a5bfde332a70f">More...</a><br /></td></tr>
<tr class="separator:gafaf1b666dff5e9f0c04a5bfde332a70f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ce927e378146a0e021824dca747118e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga0ce927e378146a0e021824dca747118e">doca_rdma_task_read_set_rdma_connection</a> (struct doca_rdma_task_read *task, struct doca_rdma_connection *rdma_connection)</td></tr>
<tr class="memdesc:ga0ce927e378146a0e021824dca747118e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method sets the rdma_connection of a read task.  <a href="group__DOCA__RDMA.html#ga0ce927e378146a0e021824dca747118e">More...</a><br /></td></tr>
<tr class="separator:ga0ce927e378146a0e021824dca747118e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39dd2efab5304062f816ec1c6ea608f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> const struct doca_rdma_connection *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga39dd2efab5304062f816ec1c6ea608f1">doca_rdma_task_read_get_rdma_connection</a> (const struct doca_rdma_task_read *task)</td></tr>
<tr class="memdesc:ga39dd2efab5304062f816ec1c6ea608f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method gets the rdma connection of a read task.  <a href="group__DOCA__RDMA.html#ga39dd2efab5304062f816ec1c6ea608f1">More...</a><br /></td></tr>
<tr class="separator:ga39dd2efab5304062f816ec1c6ea608f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae20388328da0d158fd090161a474b683"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#gae20388328da0d158fd090161a474b683">doca_rdma_cap_task_write_is_supported</a> (const struct doca_devinfo *devinfo)</td></tr>
<tr class="separator:gae20388328da0d158fd090161a474b683"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e28a390009e2b6caaf6367aadb8a4a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga6e28a390009e2b6caaf6367aadb8a4a2">doca_rdma_task_write_set_conf</a> (struct doca_rdma *rdma, <a class="el" href="group__DOCA__RDMA.html#gaf81a8b85901e3017b44eba70873cc322">doca_rdma_task_write_completion_cb_t</a> successful_task_completion_cb, <a class="el" href="group__DOCA__RDMA.html#gaf81a8b85901e3017b44eba70873cc322">doca_rdma_task_write_completion_cb_t</a> error_task_completion_cb, uint32_t num_tasks)</td></tr>
<tr class="memdesc:ga6e28a390009e2b6caaf6367aadb8a4a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method sets the write tasks configuration.  <a href="group__DOCA__RDMA.html#ga6e28a390009e2b6caaf6367aadb8a4a2">More...</a><br /></td></tr>
<tr class="separator:ga6e28a390009e2b6caaf6367aadb8a4a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef1a6ed8577a70425ae60fa56b907261"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#gaef1a6ed8577a70425ae60fa56b907261">doca_rdma_task_write_allocate_init</a> (struct doca_rdma *rdma, struct doca_rdma_connection *rdma_connection, const struct doca_buf *src_buf, struct doca_buf *dst_buf, union <a class="el" href="uniondoca__data.html">doca_data</a> user_data, struct doca_rdma_task_write **task)</td></tr>
<tr class="memdesc:gaef1a6ed8577a70425ae60fa56b907261"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method allocates and initializes a write task.  <a href="group__DOCA__RDMA.html#gaef1a6ed8577a70425ae60fa56b907261">More...</a><br /></td></tr>
<tr class="separator:gaef1a6ed8577a70425ae60fa56b907261"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52848023475d133b0bfc9db8b24bd05b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> struct doca_task *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga52848023475d133b0bfc9db8b24bd05b">doca_rdma_task_write_as_task</a> (struct doca_rdma_task_write *task)</td></tr>
<tr class="memdesc:ga52848023475d133b0bfc9db8b24bd05b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method converts a write task to a doca_task.  <a href="group__DOCA__RDMA.html#ga52848023475d133b0bfc9db8b24bd05b">More...</a><br /></td></tr>
<tr class="separator:ga52848023475d133b0bfc9db8b24bd05b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga514267dcb068edeed17720ae5b8077a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga514267dcb068edeed17720ae5b8077a5">doca_rdma_task_write_set_src_buf</a> (struct doca_rdma_task_write *task, const struct doca_buf *src_buf)</td></tr>
<tr class="memdesc:ga514267dcb068edeed17720ae5b8077a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method sets the source buffer of a write task.  <a href="group__DOCA__RDMA.html#ga514267dcb068edeed17720ae5b8077a5">More...</a><br /></td></tr>
<tr class="separator:ga514267dcb068edeed17720ae5b8077a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3136356950e85c4c0fd0f3a3a283a1e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> const struct doca_buf *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga3136356950e85c4c0fd0f3a3a283a1e7">doca_rdma_task_write_get_src_buf</a> (const struct doca_rdma_task_write *task)</td></tr>
<tr class="memdesc:ga3136356950e85c4c0fd0f3a3a283a1e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method gets the source buffer of a write task.  <a href="group__DOCA__RDMA.html#ga3136356950e85c4c0fd0f3a3a283a1e7">More...</a><br /></td></tr>
<tr class="separator:ga3136356950e85c4c0fd0f3a3a283a1e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3fcb7db4f0a7ff79eabe5905f12e5d89"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga3fcb7db4f0a7ff79eabe5905f12e5d89">doca_rdma_task_write_set_dst_buf</a> (struct doca_rdma_task_write *task, struct doca_buf *dst_buf)</td></tr>
<tr class="memdesc:ga3fcb7db4f0a7ff79eabe5905f12e5d89"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method sets the destination buffer of a write task.  <a href="group__DOCA__RDMA.html#ga3fcb7db4f0a7ff79eabe5905f12e5d89">More...</a><br /></td></tr>
<tr class="separator:ga3fcb7db4f0a7ff79eabe5905f12e5d89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0550fb803829645be2523d86553f6447"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> struct doca_buf *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga0550fb803829645be2523d86553f6447">doca_rdma_task_write_get_dst_buf</a> (const struct doca_rdma_task_write *task)</td></tr>
<tr class="memdesc:ga0550fb803829645be2523d86553f6447"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method gets the destination buffer of a write task.  <a href="group__DOCA__RDMA.html#ga0550fb803829645be2523d86553f6447">More...</a><br /></td></tr>
<tr class="separator:ga0550fb803829645be2523d86553f6447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga988da927f00a8cd220f577dc73bb0e2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga988da927f00a8cd220f577dc73bb0e2f">doca_rdma_task_write_set_rdma_connection</a> (struct doca_rdma_task_write *task, struct doca_rdma_connection *rdma_connection)</td></tr>
<tr class="memdesc:ga988da927f00a8cd220f577dc73bb0e2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method sets the rdma_connection of a write task.  <a href="group__DOCA__RDMA.html#ga988da927f00a8cd220f577dc73bb0e2f">More...</a><br /></td></tr>
<tr class="separator:ga988da927f00a8cd220f577dc73bb0e2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadeaf1b91b40e2eec573c4305c5991ecd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> const struct doca_rdma_connection *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#gadeaf1b91b40e2eec573c4305c5991ecd">doca_rdma_task_write_get_rdma_connection</a> (const struct doca_rdma_task_write *task)</td></tr>
<tr class="memdesc:gadeaf1b91b40e2eec573c4305c5991ecd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method gets the rdma connection of a write task.  <a href="group__DOCA__RDMA.html#gadeaf1b91b40e2eec573c4305c5991ecd">More...</a><br /></td></tr>
<tr class="separator:gadeaf1b91b40e2eec573c4305c5991ecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a80bde253ccb3cf1269efbf35c877c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga9a80bde253ccb3cf1269efbf35c877c3">doca_rdma_cap_task_write_imm_is_supported</a> (const struct doca_devinfo *devinfo)</td></tr>
<tr class="separator:ga9a80bde253ccb3cf1269efbf35c877c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fe338e727493a8bbd9ec5ab11255397"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga1fe338e727493a8bbd9ec5ab11255397">doca_rdma_task_write_imm_set_conf</a> (struct doca_rdma *rdma, <a class="el" href="group__DOCA__RDMA.html#gaf46528474ecc323adb02c804fca60edc">doca_rdma_task_write_imm_completion_cb_t</a> successful_task_completion_cb, <a class="el" href="group__DOCA__RDMA.html#gaf46528474ecc323adb02c804fca60edc">doca_rdma_task_write_imm_completion_cb_t</a> error_task_completion_cb, uint32_t num_tasks)</td></tr>
<tr class="memdesc:ga1fe338e727493a8bbd9ec5ab11255397"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method sets the write with immediate tasks configuration.  <a href="group__DOCA__RDMA.html#ga1fe338e727493a8bbd9ec5ab11255397">More...</a><br /></td></tr>
<tr class="separator:ga1fe338e727493a8bbd9ec5ab11255397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga218b303b2e79d682d52e5383b516bd86"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga218b303b2e79d682d52e5383b516bd86">doca_rdma_task_write_imm_allocate_init</a> (struct doca_rdma *rdma, struct doca_rdma_connection *rdma_connection, const struct doca_buf *src_buf, struct doca_buf *dst_buf, <a class="el" href="group__DOCA__TYPES.html#ga37ca3c7aed1aadba64e71712ea0e069f">doca_be32_t</a> immediate_data, union <a class="el" href="uniondoca__data.html">doca_data</a> user_data, struct doca_rdma_task_write_imm **task)</td></tr>
<tr class="memdesc:ga218b303b2e79d682d52e5383b516bd86"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method allocates and initializes a write with immediate task.  <a href="group__DOCA__RDMA.html#ga218b303b2e79d682d52e5383b516bd86">More...</a><br /></td></tr>
<tr class="separator:ga218b303b2e79d682d52e5383b516bd86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b255391c608b943f2e96c06a1ea820d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> struct doca_task *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga3b255391c608b943f2e96c06a1ea820d">doca_rdma_task_write_imm_as_task</a> (struct doca_rdma_task_write_imm *task)</td></tr>
<tr class="memdesc:ga3b255391c608b943f2e96c06a1ea820d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method converts a write with immediate task to a doca_task.  <a href="group__DOCA__RDMA.html#ga3b255391c608b943f2e96c06a1ea820d">More...</a><br /></td></tr>
<tr class="separator:ga3b255391c608b943f2e96c06a1ea820d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad8adb2ba7444d5c1ffe3ecebd78e23f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#gaad8adb2ba7444d5c1ffe3ecebd78e23f">doca_rdma_task_write_imm_set_src_buf</a> (struct doca_rdma_task_write_imm *task, const struct doca_buf *src_buf)</td></tr>
<tr class="memdesc:gaad8adb2ba7444d5c1ffe3ecebd78e23f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method sets the source buffer of a write with immediate task.  <a href="group__DOCA__RDMA.html#gaad8adb2ba7444d5c1ffe3ecebd78e23f">More...</a><br /></td></tr>
<tr class="separator:gaad8adb2ba7444d5c1ffe3ecebd78e23f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78af9693f1514cc330a3a0cef849762a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> const struct doca_buf *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga78af9693f1514cc330a3a0cef849762a">doca_rdma_task_write_imm_get_src_buf</a> (const struct doca_rdma_task_write_imm *task)</td></tr>
<tr class="memdesc:ga78af9693f1514cc330a3a0cef849762a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method gets the source buffer of a write with immediate task.  <a href="group__DOCA__RDMA.html#ga78af9693f1514cc330a3a0cef849762a">More...</a><br /></td></tr>
<tr class="separator:ga78af9693f1514cc330a3a0cef849762a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1271e7025aba75712723504044e160b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga1271e7025aba75712723504044e160b8">doca_rdma_task_write_imm_set_dst_buf</a> (struct doca_rdma_task_write_imm *task, struct doca_buf *dst_buf)</td></tr>
<tr class="memdesc:ga1271e7025aba75712723504044e160b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method sets the destination buffer of a write with immediate task.  <a href="group__DOCA__RDMA.html#ga1271e7025aba75712723504044e160b8">More...</a><br /></td></tr>
<tr class="separator:ga1271e7025aba75712723504044e160b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ebb2a0eaf61176bdc464b4f7093d3f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> struct doca_buf *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga5ebb2a0eaf61176bdc464b4f7093d3f8">doca_rdma_task_write_imm_get_dst_buf</a> (const struct doca_rdma_task_write_imm *task)</td></tr>
<tr class="memdesc:ga5ebb2a0eaf61176bdc464b4f7093d3f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method gets the destination buffer of a write with immediate task.  <a href="group__DOCA__RDMA.html#ga5ebb2a0eaf61176bdc464b4f7093d3f8">More...</a><br /></td></tr>
<tr class="separator:ga5ebb2a0eaf61176bdc464b4f7093d3f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b5d19c55aacc909c97660b5f07c4ce5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga1b5d19c55aacc909c97660b5f07c4ce5">doca_rdma_task_write_imm_set_immediate_data</a> (struct doca_rdma_task_write_imm *task, <a class="el" href="group__DOCA__TYPES.html#ga37ca3c7aed1aadba64e71712ea0e069f">doca_be32_t</a> immediate_data)</td></tr>
<tr class="memdesc:ga1b5d19c55aacc909c97660b5f07c4ce5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method sets the immediate data of a write with immediate task.  <a href="group__DOCA__RDMA.html#ga1b5d19c55aacc909c97660b5f07c4ce5">More...</a><br /></td></tr>
<tr class="separator:ga1b5d19c55aacc909c97660b5f07c4ce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab58c998388a4166b222ff0e573013f85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__TYPES.html#ga37ca3c7aed1aadba64e71712ea0e069f">doca_be32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#gab58c998388a4166b222ff0e573013f85">doca_rdma_task_write_imm_get_immediate_data</a> (const struct doca_rdma_task_write_imm *task)</td></tr>
<tr class="memdesc:gab58c998388a4166b222ff0e573013f85"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method gets the immediate data of a write with immediate task.  <a href="group__DOCA__RDMA.html#gab58c998388a4166b222ff0e573013f85">More...</a><br /></td></tr>
<tr class="separator:gab58c998388a4166b222ff0e573013f85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f6cf6f24974f3d6cf10a25ebee2f2a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga9f6cf6f24974f3d6cf10a25ebee2f2a4">doca_rdma_task_write_imm_set_rdma_connection</a> (struct doca_rdma_task_write_imm *task, struct doca_rdma_connection *rdma_connection)</td></tr>
<tr class="memdesc:ga9f6cf6f24974f3d6cf10a25ebee2f2a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method sets the rdma connection of a write with immediate task.  <a href="group__DOCA__RDMA.html#ga9f6cf6f24974f3d6cf10a25ebee2f2a4">More...</a><br /></td></tr>
<tr class="separator:ga9f6cf6f24974f3d6cf10a25ebee2f2a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe5a4ae4929381592e44751b32480315"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> const struct doca_rdma_connection *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#gafe5a4ae4929381592e44751b32480315">doca_rdma_task_write_imm_get_rdma_connection</a> (const struct doca_rdma_task_write_imm *task)</td></tr>
<tr class="memdesc:gafe5a4ae4929381592e44751b32480315"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method gets the rdma connection of a write with immediate task.  <a href="group__DOCA__RDMA.html#gafe5a4ae4929381592e44751b32480315">More...</a><br /></td></tr>
<tr class="separator:gafe5a4ae4929381592e44751b32480315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09a04fc9de7e34d62515ef2437c4713a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga09a04fc9de7e34d62515ef2437c4713a">doca_rdma_cap_task_atomic_cmp_swp_is_supported</a> (const struct doca_devinfo *devinfo)</td></tr>
<tr class="separator:ga09a04fc9de7e34d62515ef2437c4713a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ef6a98644d8df533abacb24877bc9cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga9ef6a98644d8df533abacb24877bc9cb">doca_rdma_task_atomic_cmp_swp_set_conf</a> (struct doca_rdma *rdma, <a class="el" href="group__DOCA__RDMA.html#ga0e23f2dcdf3c9e342c204a5623865b8e">doca_rdma_task_atomic_cmp_swp_completion_cb_t</a> successful_task_completion_cb, <a class="el" href="group__DOCA__RDMA.html#ga0e23f2dcdf3c9e342c204a5623865b8e">doca_rdma_task_atomic_cmp_swp_completion_cb_t</a> error_task_completion_cb, uint32_t num_tasks)</td></tr>
<tr class="memdesc:ga9ef6a98644d8df533abacb24877bc9cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method sets the atomic compare and swap tasks configuration.  <a href="group__DOCA__RDMA.html#ga9ef6a98644d8df533abacb24877bc9cb">More...</a><br /></td></tr>
<tr class="separator:ga9ef6a98644d8df533abacb24877bc9cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga808ef54de4d6e0504a35c11fc1a34e37"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga808ef54de4d6e0504a35c11fc1a34e37">doca_rdma_task_atomic_cmp_swp_allocate_init</a> (struct doca_rdma *rdma, struct doca_rdma_connection *rdma_connection, struct doca_buf *dst_buf, struct doca_buf *result_buf, uint64_t cmp_data, uint64_t swap_data, union <a class="el" href="uniondoca__data.html">doca_data</a> user_data, struct doca_rdma_task_atomic_cmp_swp **task)</td></tr>
<tr class="memdesc:ga808ef54de4d6e0504a35c11fc1a34e37"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method allocates and initializes an atomic compare and swap task.  <a href="group__DOCA__RDMA.html#ga808ef54de4d6e0504a35c11fc1a34e37">More...</a><br /></td></tr>
<tr class="separator:ga808ef54de4d6e0504a35c11fc1a34e37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4165dbbce29b18e9fdf7f4c40f3870a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> struct doca_task *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga4165dbbce29b18e9fdf7f4c40f3870a2">doca_rdma_task_atomic_cmp_swp_as_task</a> (struct doca_rdma_task_atomic_cmp_swp *task)</td></tr>
<tr class="memdesc:ga4165dbbce29b18e9fdf7f4c40f3870a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method converts an atomic compare and swap task to a doca_task.  <a href="group__DOCA__RDMA.html#ga4165dbbce29b18e9fdf7f4c40f3870a2">More...</a><br /></td></tr>
<tr class="separator:ga4165dbbce29b18e9fdf7f4c40f3870a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd7a3cade606d85db166dadcf0769100"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#gacd7a3cade606d85db166dadcf0769100">doca_rdma_task_atomic_cmp_swp_set_dst_buf</a> (struct doca_rdma_task_atomic_cmp_swp *task, struct doca_buf *dst_buf)</td></tr>
<tr class="memdesc:gacd7a3cade606d85db166dadcf0769100"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method sets the destination buffer of an atomic compare and swap task.  <a href="group__DOCA__RDMA.html#gacd7a3cade606d85db166dadcf0769100">More...</a><br /></td></tr>
<tr class="separator:gacd7a3cade606d85db166dadcf0769100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac029b98fb2b1cd186a31909751237ade"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> struct doca_buf *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#gac029b98fb2b1cd186a31909751237ade">doca_rdma_task_atomic_cmp_swp_get_dst_buf</a> (const struct doca_rdma_task_atomic_cmp_swp *task)</td></tr>
<tr class="memdesc:gac029b98fb2b1cd186a31909751237ade"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method gets the destination buffer of an atomic compare and swap task.  <a href="group__DOCA__RDMA.html#gac029b98fb2b1cd186a31909751237ade">More...</a><br /></td></tr>
<tr class="separator:gac029b98fb2b1cd186a31909751237ade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3a8b114259e301ca76aed04e7c368a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#gab3a8b114259e301ca76aed04e7c368a9">doca_rdma_task_atomic_cmp_swp_set_result_buf</a> (struct doca_rdma_task_atomic_cmp_swp *task, struct doca_buf *result_buf)</td></tr>
<tr class="memdesc:gab3a8b114259e301ca76aed04e7c368a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method sets the result buffer of an atomic compare and swap task.  <a href="group__DOCA__RDMA.html#gab3a8b114259e301ca76aed04e7c368a9">More...</a><br /></td></tr>
<tr class="separator:gab3a8b114259e301ca76aed04e7c368a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18b2ee348c559183568999d04782dfc4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> struct doca_buf *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga18b2ee348c559183568999d04782dfc4">doca_rdma_task_atomic_cmp_swp_get_result_buf</a> (const struct doca_rdma_task_atomic_cmp_swp *task)</td></tr>
<tr class="memdesc:ga18b2ee348c559183568999d04782dfc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method gets the result buffer of an atomic compare and swap task.  <a href="group__DOCA__RDMA.html#ga18b2ee348c559183568999d04782dfc4">More...</a><br /></td></tr>
<tr class="separator:ga18b2ee348c559183568999d04782dfc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga218092ad6eb94309ea9b91a6290ece91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga218092ad6eb94309ea9b91a6290ece91">doca_rdma_task_atomic_cmp_swp_set_cmp_data</a> (struct doca_rdma_task_atomic_cmp_swp *task, uint64_t cmp_data)</td></tr>
<tr class="memdesc:ga218092ad6eb94309ea9b91a6290ece91"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method sets the compare data of an atomic compare and swap task.  <a href="group__DOCA__RDMA.html#ga218092ad6eb94309ea9b91a6290ece91">More...</a><br /></td></tr>
<tr class="separator:ga218092ad6eb94309ea9b91a6290ece91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad63f3a4c0d08f02e9791bb13d06c8c16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#gad63f3a4c0d08f02e9791bb13d06c8c16">doca_rdma_task_atomic_cmp_swp_get_cmp_data</a> (const struct doca_rdma_task_atomic_cmp_swp *task)</td></tr>
<tr class="memdesc:gad63f3a4c0d08f02e9791bb13d06c8c16"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method gets the compare data of an atomic compare and swap task.  <a href="group__DOCA__RDMA.html#gad63f3a4c0d08f02e9791bb13d06c8c16">More...</a><br /></td></tr>
<tr class="separator:gad63f3a4c0d08f02e9791bb13d06c8c16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga126187b59473540d97d12888bac615e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga126187b59473540d97d12888bac615e4">doca_rdma_task_atomic_cmp_swp_set_swap_data</a> (struct doca_rdma_task_atomic_cmp_swp *task, uint64_t swap_data)</td></tr>
<tr class="memdesc:ga126187b59473540d97d12888bac615e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method sets the swap data of an atomic compare and swap task.  <a href="group__DOCA__RDMA.html#ga126187b59473540d97d12888bac615e4">More...</a><br /></td></tr>
<tr class="separator:ga126187b59473540d97d12888bac615e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed5045cc79a0a0035c848ddffcad1f3f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#gaed5045cc79a0a0035c848ddffcad1f3f">doca_rdma_task_atomic_cmp_swp_get_swap_data</a> (const struct doca_rdma_task_atomic_cmp_swp *task)</td></tr>
<tr class="memdesc:gaed5045cc79a0a0035c848ddffcad1f3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method gets the swap data of an atomic compare and swap task.  <a href="group__DOCA__RDMA.html#gaed5045cc79a0a0035c848ddffcad1f3f">More...</a><br /></td></tr>
<tr class="separator:gaed5045cc79a0a0035c848ddffcad1f3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafaa18a46639d145d2a670f1d204dfe58"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#gafaa18a46639d145d2a670f1d204dfe58">doca_rdma_task_atomic_cmp_swp_set_rdma_connection</a> (struct doca_rdma_task_atomic_cmp_swp *task, struct doca_rdma_connection *rdma_connection)</td></tr>
<tr class="memdesc:gafaa18a46639d145d2a670f1d204dfe58"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method sets the rdma_connection of a atomic compare and swap task.  <a href="group__DOCA__RDMA.html#gafaa18a46639d145d2a670f1d204dfe58">More...</a><br /></td></tr>
<tr class="separator:gafaa18a46639d145d2a670f1d204dfe58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7bc63a22cda0488d2ebbd6404ca245c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> const struct doca_rdma_connection *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga7bc63a22cda0488d2ebbd6404ca245c3">doca_rdma_task_atomic_cmp_swp_get_rdma_connection</a> (const struct doca_rdma_task_atomic_cmp_swp *task)</td></tr>
<tr class="memdesc:ga7bc63a22cda0488d2ebbd6404ca245c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method gets the rdma connection of a atomic compare and swap task.  <a href="group__DOCA__RDMA.html#ga7bc63a22cda0488d2ebbd6404ca245c3">More...</a><br /></td></tr>
<tr class="separator:ga7bc63a22cda0488d2ebbd6404ca245c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac771f166c87b578dae6271da1a6e7893"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#gac771f166c87b578dae6271da1a6e7893">doca_rdma_cap_task_atomic_fetch_add_is_supported</a> (const struct doca_devinfo *devinfo)</td></tr>
<tr class="separator:gac771f166c87b578dae6271da1a6e7893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44f6dd8652a26b727d2f66719ff53f4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga44f6dd8652a26b727d2f66719ff53f4d">doca_rdma_task_atomic_fetch_add_set_conf</a> (struct doca_rdma *rdma, <a class="el" href="group__DOCA__RDMA.html#ga16c1f55e5724609d494ae369d81421a0">doca_rdma_task_atomic_fetch_add_completion_cb_t</a> successful_task_completion_cb, <a class="el" href="group__DOCA__RDMA.html#ga16c1f55e5724609d494ae369d81421a0">doca_rdma_task_atomic_fetch_add_completion_cb_t</a> error_task_completion_cb, uint32_t num_tasks)</td></tr>
<tr class="memdesc:ga44f6dd8652a26b727d2f66719ff53f4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method sets the atomic fetch and add tasks configuration.  <a href="group__DOCA__RDMA.html#ga44f6dd8652a26b727d2f66719ff53f4d">More...</a><br /></td></tr>
<tr class="separator:ga44f6dd8652a26b727d2f66719ff53f4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga179b21b111f3d31c414799743b805207"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga179b21b111f3d31c414799743b805207">doca_rdma_task_atomic_fetch_add_allocate_init</a> (struct doca_rdma *rdma, struct doca_rdma_connection *rdma_connection, struct doca_buf *dst_buf, struct doca_buf *result_buf, uint64_t add_data, union <a class="el" href="uniondoca__data.html">doca_data</a> user_data, struct doca_rdma_task_atomic_fetch_add **task)</td></tr>
<tr class="memdesc:ga179b21b111f3d31c414799743b805207"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method allocates and initializes an atomic fetch and add task.  <a href="group__DOCA__RDMA.html#ga179b21b111f3d31c414799743b805207">More...</a><br /></td></tr>
<tr class="separator:ga179b21b111f3d31c414799743b805207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba77207bd9e454780225caeac202be6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> struct doca_task *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#gaba77207bd9e454780225caeac202be6b">doca_rdma_task_atomic_fetch_add_as_task</a> (struct doca_rdma_task_atomic_fetch_add *task)</td></tr>
<tr class="memdesc:gaba77207bd9e454780225caeac202be6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method converts an atomic fetch and add task to a doca_task.  <a href="group__DOCA__RDMA.html#gaba77207bd9e454780225caeac202be6b">More...</a><br /></td></tr>
<tr class="separator:gaba77207bd9e454780225caeac202be6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65c0e349e64789496f4c593a87545896"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga65c0e349e64789496f4c593a87545896">doca_rdma_task_atomic_fetch_add_set_dst_buf</a> (struct doca_rdma_task_atomic_fetch_add *task, struct doca_buf *dst_buf)</td></tr>
<tr class="memdesc:ga65c0e349e64789496f4c593a87545896"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method sets the destination buffer of an atomic fetch and add task.  <a href="group__DOCA__RDMA.html#ga65c0e349e64789496f4c593a87545896">More...</a><br /></td></tr>
<tr class="separator:ga65c0e349e64789496f4c593a87545896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad169447e842efdaebb456ed23d0ab0ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> struct doca_buf *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#gad169447e842efdaebb456ed23d0ab0ee">doca_rdma_task_atomic_fetch_add_get_dst_buf</a> (const struct doca_rdma_task_atomic_fetch_add *task)</td></tr>
<tr class="memdesc:gad169447e842efdaebb456ed23d0ab0ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method gets the destination buffer of an atomic fetch and add task.  <a href="group__DOCA__RDMA.html#gad169447e842efdaebb456ed23d0ab0ee">More...</a><br /></td></tr>
<tr class="separator:gad169447e842efdaebb456ed23d0ab0ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5cc1550bf1f4cfa44fef5cf6bf7aa67a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga5cc1550bf1f4cfa44fef5cf6bf7aa67a">doca_rdma_task_atomic_fetch_add_set_result_buf</a> (struct doca_rdma_task_atomic_fetch_add *task, struct doca_buf *result_buf)</td></tr>
<tr class="memdesc:ga5cc1550bf1f4cfa44fef5cf6bf7aa67a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method sets the result buffer of an atomic fetch and add task.  <a href="group__DOCA__RDMA.html#ga5cc1550bf1f4cfa44fef5cf6bf7aa67a">More...</a><br /></td></tr>
<tr class="separator:ga5cc1550bf1f4cfa44fef5cf6bf7aa67a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaecdb3ba1ba3a5a1d5369aa47139fccfc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> struct doca_buf *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#gaecdb3ba1ba3a5a1d5369aa47139fccfc">doca_rdma_task_atomic_fetch_add_get_result_buf</a> (const struct doca_rdma_task_atomic_fetch_add *task)</td></tr>
<tr class="memdesc:gaecdb3ba1ba3a5a1d5369aa47139fccfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method gets the result buffer of an atomic fetch and add task.  <a href="group__DOCA__RDMA.html#gaecdb3ba1ba3a5a1d5369aa47139fccfc">More...</a><br /></td></tr>
<tr class="separator:gaecdb3ba1ba3a5a1d5369aa47139fccfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5bb77a842024a537bf74264a8a349be9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga5bb77a842024a537bf74264a8a349be9">doca_rdma_task_atomic_fetch_add_set_add_data</a> (struct doca_rdma_task_atomic_fetch_add *task, uint64_t add_data)</td></tr>
<tr class="memdesc:ga5bb77a842024a537bf74264a8a349be9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method sets the add data of an atomic fetch and add task.  <a href="group__DOCA__RDMA.html#ga5bb77a842024a537bf74264a8a349be9">More...</a><br /></td></tr>
<tr class="separator:ga5bb77a842024a537bf74264a8a349be9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f7b060d4e6fe46e3acd22a2eced696b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga1f7b060d4e6fe46e3acd22a2eced696b">doca_rdma_task_atomic_fetch_add_get_add_data</a> (const struct doca_rdma_task_atomic_fetch_add *task)</td></tr>
<tr class="memdesc:ga1f7b060d4e6fe46e3acd22a2eced696b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method gets the add data of an atomic fetch and add task.  <a href="group__DOCA__RDMA.html#ga1f7b060d4e6fe46e3acd22a2eced696b">More...</a><br /></td></tr>
<tr class="separator:ga1f7b060d4e6fe46e3acd22a2eced696b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52abeff9265415ca84ea85ce27e3b657"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga52abeff9265415ca84ea85ce27e3b657">doca_rdma_task_atomic_fetch_add_set_rdma_connection</a> (struct doca_rdma_task_atomic_fetch_add *task, struct doca_rdma_connection *rdma_connection)</td></tr>
<tr class="memdesc:ga52abeff9265415ca84ea85ce27e3b657"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method sets the rdma_connection of a atomic fetch and add task.  <a href="group__DOCA__RDMA.html#ga52abeff9265415ca84ea85ce27e3b657">More...</a><br /></td></tr>
<tr class="separator:ga52abeff9265415ca84ea85ce27e3b657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad66f0af1c168b2ade59541e4022ab0a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> const struct doca_rdma_connection *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#gad66f0af1c168b2ade59541e4022ab0a2">doca_rdma_task_atomic_fetch_add_get_rdma_connection</a> (const struct doca_rdma_task_atomic_fetch_add *task)</td></tr>
<tr class="memdesc:gad66f0af1c168b2ade59541e4022ab0a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method gets the rdma connection of a atomic fetch and add task.  <a href="group__DOCA__RDMA.html#gad66f0af1c168b2ade59541e4022ab0a2">More...</a><br /></td></tr>
<tr class="separator:gad66f0af1c168b2ade59541e4022ab0a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4f885f228545c77680035689d275d30"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#gaa4f885f228545c77680035689d275d30">doca_rdma_cap_task_remote_net_sync_event_get_is_supported</a> (const struct doca_devinfo *devinfo)</td></tr>
<tr class="separator:gaa4f885f228545c77680035689d275d30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07a4d220b23b6ca9f9cb5eaf22bde68a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga07a4d220b23b6ca9f9cb5eaf22bde68a">doca_rdma_task_remote_net_sync_event_get_set_conf</a> (struct doca_rdma *rdma, <a class="el" href="group__DOCA__RDMA.html#ga9dcb777cfd90aaa306faba7c4f7aad14">doca_rdma_task_remote_net_sync_event_get_completion_cb_t</a> successful_task_completion_cb, <a class="el" href="group__DOCA__RDMA.html#ga9dcb777cfd90aaa306faba7c4f7aad14">doca_rdma_task_remote_net_sync_event_get_completion_cb_t</a> error_task_completion_cb, uint32_t num_tasks)</td></tr>
<tr class="memdesc:ga07a4d220b23b6ca9f9cb5eaf22bde68a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method sets the remote_net_sync_event_get tasks configuration.  <a href="group__DOCA__RDMA.html#ga07a4d220b23b6ca9f9cb5eaf22bde68a">More...</a><br /></td></tr>
<tr class="separator:ga07a4d220b23b6ca9f9cb5eaf22bde68a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd0801cde5179de5ad7088cc58719794"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#gafd0801cde5179de5ad7088cc58719794">doca_rdma_task_remote_net_sync_event_get_allocate_init</a> (struct doca_rdma *rdma, struct doca_rdma_connection *rdma_connection, const struct doca_sync_event_remote_net *event, struct doca_buf *dst_buf, union <a class="el" href="uniondoca__data.html">doca_data</a> user_data, struct doca_rdma_task_remote_net_sync_event_get **task)</td></tr>
<tr class="memdesc:gafd0801cde5179de5ad7088cc58719794"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method allocates and initializes a remote_net_sync_event_get task.  <a href="group__DOCA__RDMA.html#gafd0801cde5179de5ad7088cc58719794">More...</a><br /></td></tr>
<tr class="separator:gafd0801cde5179de5ad7088cc58719794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e1d6a66ce0da45550b6dbfc8c8e35aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> struct doca_task *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga6e1d6a66ce0da45550b6dbfc8c8e35aa">doca_rdma_task_remote_net_sync_event_get_as_task</a> (struct doca_rdma_task_remote_net_sync_event_get *task)</td></tr>
<tr class="memdesc:ga6e1d6a66ce0da45550b6dbfc8c8e35aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method converts a remote_net_sync_event_get task to a doca_task.  <a href="group__DOCA__RDMA.html#ga6e1d6a66ce0da45550b6dbfc8c8e35aa">More...</a><br /></td></tr>
<tr class="separator:ga6e1d6a66ce0da45550b6dbfc8c8e35aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9617f02b4815f98d7aed44b9bf33d8fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga9617f02b4815f98d7aed44b9bf33d8fc">doca_rdma_task_remote_net_sync_event_get_set_sync_event</a> (struct doca_rdma_task_remote_net_sync_event_get *task, const struct doca_sync_event_remote_net *event)</td></tr>
<tr class="memdesc:ga9617f02b4815f98d7aed44b9bf33d8fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method sets the remote net sync event of a remote_net_sync_event_get task.  <a href="group__DOCA__RDMA.html#ga9617f02b4815f98d7aed44b9bf33d8fc">More...</a><br /></td></tr>
<tr class="separator:ga9617f02b4815f98d7aed44b9bf33d8fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29f9c4752fc0f27d1ba8f1794a9189cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> const struct doca_sync_event_remote_net *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga29f9c4752fc0f27d1ba8f1794a9189cb">doca_rdma_task_remote_net_sync_event_get_get_sync_event</a> (const struct doca_rdma_task_remote_net_sync_event_get *task)</td></tr>
<tr class="memdesc:ga29f9c4752fc0f27d1ba8f1794a9189cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method gets the remote net sync event of a remote_net_sync_event_get task.  <a href="group__DOCA__RDMA.html#ga29f9c4752fc0f27d1ba8f1794a9189cb">More...</a><br /></td></tr>
<tr class="separator:ga29f9c4752fc0f27d1ba8f1794a9189cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39e1d5e8e841e0aa6cfe81db8bd56342"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga39e1d5e8e841e0aa6cfe81db8bd56342">doca_rdma_task_remote_net_sync_event_get_set_dst_buf</a> (struct doca_rdma_task_remote_net_sync_event_get *task, struct doca_buf *dst_buf)</td></tr>
<tr class="memdesc:ga39e1d5e8e841e0aa6cfe81db8bd56342"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method sets the destination buffer of a remote_net_sync_event_get task.  <a href="group__DOCA__RDMA.html#ga39e1d5e8e841e0aa6cfe81db8bd56342">More...</a><br /></td></tr>
<tr class="separator:ga39e1d5e8e841e0aa6cfe81db8bd56342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6ead9a285a2311b29f8ef2a17aeff2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> struct doca_buf *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#gae6ead9a285a2311b29f8ef2a17aeff2f">doca_rdma_task_remote_net_sync_event_get_get_dst_buf</a> (const struct doca_rdma_task_remote_net_sync_event_get *task)</td></tr>
<tr class="memdesc:gae6ead9a285a2311b29f8ef2a17aeff2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method gets the destination buffer of a remote_net_sync_event_get task.  <a href="group__DOCA__RDMA.html#gae6ead9a285a2311b29f8ef2a17aeff2f">More...</a><br /></td></tr>
<tr class="separator:gae6ead9a285a2311b29f8ef2a17aeff2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32719aa9b8b5573ab6b16315fc2d0873"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga32719aa9b8b5573ab6b16315fc2d0873">doca_rdma_task_remote_net_sync_event_get_get_result_len</a> (const struct doca_rdma_task_remote_net_sync_event_get *task)</td></tr>
<tr class="memdesc:ga32719aa9b8b5573ab6b16315fc2d0873"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method gets the length of data read by the task.  <a href="group__DOCA__RDMA.html#ga32719aa9b8b5573ab6b16315fc2d0873">More...</a><br /></td></tr>
<tr class="separator:ga32719aa9b8b5573ab6b16315fc2d0873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42582adc7cb143fac5bff397f8a1d3e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga42582adc7cb143fac5bff397f8a1d3e9">doca_rdma_task_remote_net_sync_event_get_set_rdma_connection</a> (struct doca_rdma_task_remote_net_sync_event_get *task, struct doca_rdma_connection *rdma_connection)</td></tr>
<tr class="memdesc:ga42582adc7cb143fac5bff397f8a1d3e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method sets the rdma_connection of a remote_net_sync_event_get task.  <a href="group__DOCA__RDMA.html#ga42582adc7cb143fac5bff397f8a1d3e9">More...</a><br /></td></tr>
<tr class="separator:ga42582adc7cb143fac5bff397f8a1d3e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a64e9f09886f20d9ff62172ab08b880"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> const struct doca_rdma_connection *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga9a64e9f09886f20d9ff62172ab08b880">doca_rdma_task_remote_net_sync_event_get_get_rdma_connection</a> (const struct doca_rdma_task_remote_net_sync_event_get *task)</td></tr>
<tr class="memdesc:ga9a64e9f09886f20d9ff62172ab08b880"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method gets the rdma connection of a remote_net_sync_event_get task.  <a href="group__DOCA__RDMA.html#ga9a64e9f09886f20d9ff62172ab08b880">More...</a><br /></td></tr>
<tr class="separator:ga9a64e9f09886f20d9ff62172ab08b880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ce3b2d3d90038ba0174f4df36342ec8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga3ce3b2d3d90038ba0174f4df36342ec8">doca_rdma_cap_task_remote_net_sync_event_notify_set_is_supported</a> (const struct doca_devinfo *devinfo)</td></tr>
<tr class="separator:ga3ce3b2d3d90038ba0174f4df36342ec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98ea421f84b7c744bb72ef7fbc5f5129"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga98ea421f84b7c744bb72ef7fbc5f5129">doca_rdma_task_remote_net_sync_event_notify_set_set_conf</a> (struct doca_rdma *rdma, <a class="el" href="group__DOCA__RDMA.html#ga856a75fbd80e9fda88005b6012fd3d52">doca_rdma_task_remote_net_sync_event_notify_set_completion_cb_t</a> successful_task_completion_cb, <a class="el" href="group__DOCA__RDMA.html#ga856a75fbd80e9fda88005b6012fd3d52">doca_rdma_task_remote_net_sync_event_notify_set_completion_cb_t</a> error_task_completion_cb, uint32_t num_tasks)</td></tr>
<tr class="memdesc:ga98ea421f84b7c744bb72ef7fbc5f5129"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method sets the remote_net_sync_event_notify_set tasks configuration.  <a href="group__DOCA__RDMA.html#ga98ea421f84b7c744bb72ef7fbc5f5129">More...</a><br /></td></tr>
<tr class="separator:ga98ea421f84b7c744bb72ef7fbc5f5129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3fb0b4fbd57f752d6d6fda6b32563b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#gab3fb0b4fbd57f752d6d6fda6b32563b2">doca_rdma_task_remote_net_sync_event_notify_set_allocate_init</a> (struct doca_rdma *rdma, struct doca_rdma_connection *rdma_connection, struct doca_sync_event_remote_net *event, const struct doca_buf *src_buf, union <a class="el" href="uniondoca__data.html">doca_data</a> user_data, struct doca_rdma_task_remote_net_sync_event_notify_set **task)</td></tr>
<tr class="memdesc:gab3fb0b4fbd57f752d6d6fda6b32563b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method allocates and initializes a remote_net_sync_event_notify_set task.  <a href="group__DOCA__RDMA.html#gab3fb0b4fbd57f752d6d6fda6b32563b2">More...</a><br /></td></tr>
<tr class="separator:gab3fb0b4fbd57f752d6d6fda6b32563b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05c1965b0138773884f0d75df1c99124"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> struct doca_task *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga05c1965b0138773884f0d75df1c99124">doca_rdma_task_remote_net_sync_event_notify_set_as_task</a> (struct doca_rdma_task_remote_net_sync_event_notify_set *task)</td></tr>
<tr class="memdesc:ga05c1965b0138773884f0d75df1c99124"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method converts a remote_net_sync_event_notify_set task to a doca_task.  <a href="group__DOCA__RDMA.html#ga05c1965b0138773884f0d75df1c99124">More...</a><br /></td></tr>
<tr class="separator:ga05c1965b0138773884f0d75df1c99124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92e1d705ece2917bf3561e6329648ed7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga92e1d705ece2917bf3561e6329648ed7">doca_rdma_task_remote_net_sync_event_notify_set_set_sync_event</a> (struct doca_rdma_task_remote_net_sync_event_notify_set *task, struct doca_sync_event_remote_net *event)</td></tr>
<tr class="memdesc:ga92e1d705ece2917bf3561e6329648ed7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method sets the remote net sync event of a remote_net_sync_event_notify_set task.  <a href="group__DOCA__RDMA.html#ga92e1d705ece2917bf3561e6329648ed7">More...</a><br /></td></tr>
<tr class="separator:ga92e1d705ece2917bf3561e6329648ed7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14ca6986df0b342d65ced56d5f4afc91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> struct doca_sync_event_remote_net *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga14ca6986df0b342d65ced56d5f4afc91">doca_rdma_task_remote_net_sync_event_notify_set_get_sync_event</a> (const struct doca_rdma_task_remote_net_sync_event_notify_set *task)</td></tr>
<tr class="memdesc:ga14ca6986df0b342d65ced56d5f4afc91"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method gets the remote net sync event of a remote_net_sync_event_notify_set task.  <a href="group__DOCA__RDMA.html#ga14ca6986df0b342d65ced56d5f4afc91">More...</a><br /></td></tr>
<tr class="separator:ga14ca6986df0b342d65ced56d5f4afc91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf6a4d5bc43cba86657998053e635008"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#gacf6a4d5bc43cba86657998053e635008">doca_rdma_task_remote_net_sync_event_notify_set_set_rdma_connection</a> (struct doca_rdma_task_remote_net_sync_event_notify_set *task, struct doca_rdma_connection *rdma_connection)</td></tr>
<tr class="memdesc:gacf6a4d5bc43cba86657998053e635008"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method sets the rdma_connection of a remote_net_sync_event_notify_set task.  <a href="group__DOCA__RDMA.html#gacf6a4d5bc43cba86657998053e635008">More...</a><br /></td></tr>
<tr class="separator:gacf6a4d5bc43cba86657998053e635008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e724c8da80470d2c0bc5ef5f209e7e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> const struct doca_rdma_connection *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga9e724c8da80470d2c0bc5ef5f209e7e3">doca_rdma_task_remote_net_sync_event_notify_set_get_rdma_connection</a> (const struct doca_rdma_task_remote_net_sync_event_notify_set *task)</td></tr>
<tr class="memdesc:ga9e724c8da80470d2c0bc5ef5f209e7e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method gets the rdma connection of a remote_net_sync_event_notify_set task.  <a href="group__DOCA__RDMA.html#ga9e724c8da80470d2c0bc5ef5f209e7e3">More...</a><br /></td></tr>
<tr class="separator:ga9e724c8da80470d2c0bc5ef5f209e7e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7306242c3b607e00566d4c393bfad02"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#gab7306242c3b607e00566d4c393bfad02">doca_rdma_task_remote_net_sync_event_notify_set_set_src_buf</a> (struct doca_rdma_task_remote_net_sync_event_notify_set *task, const struct doca_buf *src_buf)</td></tr>
<tr class="memdesc:gab7306242c3b607e00566d4c393bfad02"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method sets the source buffer of a remote_net_sync_event_notify_set task.  <a href="group__DOCA__RDMA.html#gab7306242c3b607e00566d4c393bfad02">More...</a><br /></td></tr>
<tr class="separator:gab7306242c3b607e00566d4c393bfad02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3edf5dbb66f3762a3c7bb70def13dc5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> const struct doca_buf *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga3edf5dbb66f3762a3c7bb70def13dc5d">doca_rdma_task_remote_net_sync_event_notify_set_get_src_buf</a> (const struct doca_rdma_task_remote_net_sync_event_notify_set *task)</td></tr>
<tr class="memdesc:ga3edf5dbb66f3762a3c7bb70def13dc5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method gets the source buffer of a remote_net_sync_event_notify_set task.  <a href="group__DOCA__RDMA.html#ga3edf5dbb66f3762a3c7bb70def13dc5d">More...</a><br /></td></tr>
<tr class="separator:ga3edf5dbb66f3762a3c7bb70def13dc5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf268181319c323f622ae4d86e91d9b33"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#gaf268181319c323f622ae4d86e91d9b33">doca_rdma_cap_task_remote_net_sync_event_notify_add_is_supported</a> (const struct doca_devinfo *devinfo)</td></tr>
<tr class="separator:gaf268181319c323f622ae4d86e91d9b33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b986b64cdf675eb0d02481b4a60f63f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga8b986b64cdf675eb0d02481b4a60f63f">doca_rdma_task_remote_net_sync_event_notify_add_set_conf</a> (struct doca_rdma *rdma, <a class="el" href="group__DOCA__RDMA.html#ga17916c135eaba7a8bc303a5cc072e9dd">doca_rdma_task_remote_net_sync_event_notify_add_completion_cb_t</a> successful_task_completion_cb, <a class="el" href="group__DOCA__RDMA.html#ga17916c135eaba7a8bc303a5cc072e9dd">doca_rdma_task_remote_net_sync_event_notify_add_completion_cb_t</a> error_task_completion_cb, uint32_t num_tasks)</td></tr>
<tr class="memdesc:ga8b986b64cdf675eb0d02481b4a60f63f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method sets the remote_net_sync_event_notify_add tasks configuration.  <a href="group__DOCA__RDMA.html#ga8b986b64cdf675eb0d02481b4a60f63f">More...</a><br /></td></tr>
<tr class="separator:ga8b986b64cdf675eb0d02481b4a60f63f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34aedd8045a97261a2a00421d571bebd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga34aedd8045a97261a2a00421d571bebd">doca_rdma_task_remote_net_sync_event_notify_add_allocate_init</a> (struct doca_rdma *rdma, struct doca_rdma_connection *rdma_connection, struct doca_sync_event_remote_net *event, struct doca_buf *result_buf, uint64_t add_data, union <a class="el" href="uniondoca__data.html">doca_data</a> user_data, struct doca_rdma_task_remote_net_sync_event_notify_add **task)</td></tr>
<tr class="memdesc:ga34aedd8045a97261a2a00421d571bebd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method allocates and initializes a remote_net_sync_event_notify_add task.  <a href="group__DOCA__RDMA.html#ga34aedd8045a97261a2a00421d571bebd">More...</a><br /></td></tr>
<tr class="separator:ga34aedd8045a97261a2a00421d571bebd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11e698096d21f027d9f1a50797626022"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> struct doca_task *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga11e698096d21f027d9f1a50797626022">doca_rdma_task_remote_net_sync_event_notify_add_as_task</a> (struct doca_rdma_task_remote_net_sync_event_notify_add *task)</td></tr>
<tr class="memdesc:ga11e698096d21f027d9f1a50797626022"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method converts a remote_net_sync_event_notify_add task to a doca_task.  <a href="group__DOCA__RDMA.html#ga11e698096d21f027d9f1a50797626022">More...</a><br /></td></tr>
<tr class="separator:ga11e698096d21f027d9f1a50797626022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeebf3b6e82949e34ad64a639520f51bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#gaeebf3b6e82949e34ad64a639520f51bf">doca_rdma_task_remote_net_sync_event_notify_add_set_sync_event</a> (struct doca_rdma_task_remote_net_sync_event_notify_add *task, struct doca_sync_event_remote_net *event)</td></tr>
<tr class="memdesc:gaeebf3b6e82949e34ad64a639520f51bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method sets the remote sync event of a remote_net_sync_event_notify_add task.  <a href="group__DOCA__RDMA.html#gaeebf3b6e82949e34ad64a639520f51bf">More...</a><br /></td></tr>
<tr class="separator:gaeebf3b6e82949e34ad64a639520f51bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c9194a38d57cf27eaf5108ff4af8af5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> struct doca_sync_event_remote_net *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga2c9194a38d57cf27eaf5108ff4af8af5">doca_rdma_task_remote_net_sync_event_notify_add_get_sync_event</a> (const struct doca_rdma_task_remote_net_sync_event_notify_add *task)</td></tr>
<tr class="memdesc:ga2c9194a38d57cf27eaf5108ff4af8af5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method gets the remote sync event of a remote_net_sync_event_notify_add task.  <a href="group__DOCA__RDMA.html#ga2c9194a38d57cf27eaf5108ff4af8af5">More...</a><br /></td></tr>
<tr class="separator:ga2c9194a38d57cf27eaf5108ff4af8af5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3690d671a911fd781a04db8ec1c2dcb8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga3690d671a911fd781a04db8ec1c2dcb8">doca_rdma_task_remote_net_sync_event_notify_add_set_result_buf</a> (struct doca_rdma_task_remote_net_sync_event_notify_add *task, struct doca_buf *result_buf)</td></tr>
<tr class="memdesc:ga3690d671a911fd781a04db8ec1c2dcb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method sets the result buffer of a remote_net_sync_event_notify_add task.  <a href="group__DOCA__RDMA.html#ga3690d671a911fd781a04db8ec1c2dcb8">More...</a><br /></td></tr>
<tr class="separator:ga3690d671a911fd781a04db8ec1c2dcb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3215f32c3153263dc9eb495e03372d0d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> struct doca_buf *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga3215f32c3153263dc9eb495e03372d0d">doca_rdma_task_remote_net_sync_event_notify_add_get_result_buf</a> (const struct doca_rdma_task_remote_net_sync_event_notify_add *task)</td></tr>
<tr class="memdesc:ga3215f32c3153263dc9eb495e03372d0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method gets the result buffer of a remote_net_sync_event_notify_add task.  <a href="group__DOCA__RDMA.html#ga3215f32c3153263dc9eb495e03372d0d">More...</a><br /></td></tr>
<tr class="separator:ga3215f32c3153263dc9eb495e03372d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc75fd226a5a5ddf94fb7f4afee129a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#gadc75fd226a5a5ddf94fb7f4afee129a5">doca_rdma_task_remote_net_sync_event_notify_add_set_add_data</a> (struct doca_rdma_task_remote_net_sync_event_notify_add *task, uint64_t add_data)</td></tr>
<tr class="memdesc:gadc75fd226a5a5ddf94fb7f4afee129a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method sets the add data of a remote_net_sync_event_notify_add task.  <a href="group__DOCA__RDMA.html#gadc75fd226a5a5ddf94fb7f4afee129a5">More...</a><br /></td></tr>
<tr class="separator:gadc75fd226a5a5ddf94fb7f4afee129a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3c9e7f58c02708c647109a9d395d99c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#gac3c9e7f58c02708c647109a9d395d99c">doca_rdma_task_remote_net_sync_event_notify_add_get_add_data</a> (const struct doca_rdma_task_remote_net_sync_event_notify_add *task)</td></tr>
<tr class="memdesc:gac3c9e7f58c02708c647109a9d395d99c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method gets the add data of a remote_net_sync_event_notify_add task.  <a href="group__DOCA__RDMA.html#gac3c9e7f58c02708c647109a9d395d99c">More...</a><br /></td></tr>
<tr class="separator:gac3c9e7f58c02708c647109a9d395d99c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc5e82533e3a0c7f0eb20561600a4bf3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#gacc5e82533e3a0c7f0eb20561600a4bf3">doca_rdma_task_remote_net_sync_event_notify_add_set_rdma_connection</a> (struct doca_rdma_task_remote_net_sync_event_notify_add *task, struct doca_rdma_connection *rdma_connection)</td></tr>
<tr class="memdesc:gacc5e82533e3a0c7f0eb20561600a4bf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method sets the rdma_connection of a remote_net_sync_event_notify_add task.  <a href="group__DOCA__RDMA.html#gacc5e82533e3a0c7f0eb20561600a4bf3">More...</a><br /></td></tr>
<tr class="separator:gacc5e82533e3a0c7f0eb20561600a4bf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b2f1f1b90f44088a0e8f894c8874247"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> const struct doca_rdma_connection *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga2b2f1f1b90f44088a0e8f894c8874247">doca_rdma_task_remote_net_sync_event_notify_add_get_rdma_connection</a> (const struct doca_rdma_task_remote_net_sync_event_notify_add *task)</td></tr>
<tr class="memdesc:ga2b2f1f1b90f44088a0e8f894c8874247"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method gets the rdma connection of a remote_net_sync_event_notify_add task.  <a href="group__DOCA__RDMA.html#ga2b2f1f1b90f44088a0e8f894c8874247">More...</a><br /></td></tr>
<tr class="separator:ga2b2f1f1b90f44088a0e8f894c8874247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b77d1227d304b3a4af75a450a0503d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__RDMA.html#ga2b77d1227d304b3a4af75a450a0503d5">doca_rdma_dpa_completion_attach</a> (struct doca_rdma *rdma, struct doca_dpa_completion *dpa_comp)</td></tr>
<tr class="memdesc:ga2b77d1227d304b3a4af75a450a0503d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attach DOCA RDMA to DPA completion context.  <a href="group__DOCA__RDMA.html#ga2b77d1227d304b3a4af75a450a0503d5">More...</a><br /></td></tr>
<tr class="separator:ga2b77d1227d304b3a4af75a450a0503d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>DOCA RDMA library. For more details please refer to the user guide on DOCA devzone. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gadb533b1f5e0b511e7eec6d74e738193b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb533b1f5e0b511e7eec6d74e738193b">&#9670;&nbsp;</a></span>doca_dpa_dev_rdma_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint64_t <a class="el" href="group__DOCA__RDMA.html#gadb533b1f5e0b511e7eec6d74e738193b">doca_dpa_dev_rdma_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Typedef representing a DOCA RDMA DPA handle instance. </p>

<p class="definition">Definition at line <a class="el" href="doca__rdma_8h_source.html#l00084">84</a> of file <a class="el" href="doca__rdma_8h_source.html">doca_rdma.h</a>.</p>

</div>
</div>
<a id="ga5c9391e450ddc64b3d26700a26dedba7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c9391e450ddc64b3d26700a26dedba7">&#9670;&nbsp;</a></span>doca_rdma_connection_disconnection_cb_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* doca_rdma_connection_disconnection_cb_t) (struct doca_rdma_connection *rdma_connection, union <a class="el" href="uniondoca__data.html">doca_data</a> connection_user_data, union <a class="el" href="uniondoca__data.html">doca_data</a> ctx_user_data)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to execute on connection disconnection event. </p>
<p>This function is called by <a class="el" href="group__DOCA__PE.html#ga9a0e5d8d7a584dcc3db5c612875887cb" title="Run the progress engine.">doca_pe_progress()</a> when a connection is disconnected either by server or client. When this function is called the user (acting as a client) will receive notification of disconnection from an established connection. Inside this callback the user may decide to account for the issue to decide whether to re-try or re-evaluate. Inside this callback the user shouldn't call <a class="el" href="group__DOCA__PE.html#ga9a0e5d8d7a584dcc3db5c612875887cb" title="Run the progress engine.">doca_pe_progress()</a>. Please see <a class="el" href="group__DOCA__PE.html#ga9a0e5d8d7a584dcc3db5c612875887cb" title="Run the progress engine.">doca_pe_progress()</a> for details.</p>
<p>Any failure/error inside this function should be handled internally or deferred; Since this function is nested in the execution of <a class="el" href="group__DOCA__PE.html#ga9a0e5d8d7a584dcc3db5c612875887cb" title="Run the progress engine.">doca_pe_progress()</a>, this callback doesn't return an error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rdma_connection</td><td>Connection related data required for doca_rdma to connect. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The implementation can assume this value is not NULL. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">connection_user_data</td><td>The <a class="el" href="uniondoca__data.html" title="Convenience type for representing opaque data.">doca_data</a> supplied to the connection by the application (during connection or by a setter). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx_user_data</td><td>The <a class="el" href="uniondoca__data.html" title="Convenience type for representing opaque data.">doca_data</a> supplied to the doca_ctx by the application (using a setter). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="doca__rdma_8h_source.html#l01272">1272</a> of file <a class="el" href="doca__rdma_8h_source.html">doca_rdma.h</a>.</p>

</div>
</div>
<a id="gac64a10cc83ec29159975883df89b9507"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac64a10cc83ec29159975883df89b9507">&#9670;&nbsp;</a></span>doca_rdma_connection_established_cb_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* doca_rdma_connection_established_cb_t) (struct doca_rdma_connection *rdma_connection, union <a class="el" href="uniondoca__data.html">doca_data</a> connection_user_data, union <a class="el" href="uniondoca__data.html">doca_data</a> ctx_user_data)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to execute on connection established event. </p>
<p>This function is called by <a class="el" href="group__DOCA__PE.html#ga9a0e5d8d7a584dcc3db5c612875887cb" title="Run the progress engine.">doca_pe_progress()</a> when a connection successfully established with a server. When this function is called the user (acting as a client) will receive notification of a connection established. Inside this callback the user may decide to account for the established. Inside this callback the user shouldn't call <a class="el" href="group__DOCA__PE.html#ga9a0e5d8d7a584dcc3db5c612875887cb" title="Run the progress engine.">doca_pe_progress()</a>. Please see <a class="el" href="group__DOCA__PE.html#ga9a0e5d8d7a584dcc3db5c612875887cb" title="Run the progress engine.">doca_pe_progress()</a> for details.</p>
<p>Any failure/error inside this function should be handled internally or deferred; Since this function is nested in the execution of <a class="el" href="group__DOCA__PE.html#ga9a0e5d8d7a584dcc3db5c612875887cb" title="Run the progress engine.">doca_pe_progress()</a>, this callback doesn't return an error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rdma_connection</td><td>Connection related data required for doca_rdma to connect. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The implementation can assume this value is not NULL. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">connection_user_data</td><td>The <a class="el" href="uniondoca__data.html" title="Convenience type for representing opaque data.">doca_data</a> supplied to the connection by the application (during connection or by a setter). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx_user_data</td><td>The <a class="el" href="uniondoca__data.html" title="Convenience type for representing opaque data.">doca_data</a> supplied to the doca_ctx by the application (using a setter). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="doca__rdma_8h_source.html#l01224">1224</a> of file <a class="el" href="doca__rdma_8h_source.html">doca_rdma.h</a>.</p>

</div>
</div>
<a id="ga759d54b2fef283bc8f92c2ae29187fce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga759d54b2fef283bc8f92c2ae29187fce">&#9670;&nbsp;</a></span>doca_rdma_connection_failure_cb_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* doca_rdma_connection_failure_cb_t) (struct doca_rdma_connection *rdma_connection, union <a class="el" href="uniondoca__data.html">doca_data</a> connection_user_data, union <a class="el" href="uniondoca__data.html">doca_data</a> ctx_user_data)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to execute on connection failure event. </p>
<p>This function is called by <a class="el" href="group__DOCA__PE.html#ga9a0e5d8d7a584dcc3db5c612875887cb" title="Run the progress engine.">doca_pe_progress()</a> when a connection fails to be established. When this function is called the user (acting as a client) will receive notification of a connection failure. Inside this callback the user may decide to account for the issue to decide whether to re-try or re-evaluate. Inside this callback the user shouldn't call <a class="el" href="group__DOCA__PE.html#ga9a0e5d8d7a584dcc3db5c612875887cb" title="Run the progress engine.">doca_pe_progress()</a>. Please see <a class="el" href="group__DOCA__PE.html#ga9a0e5d8d7a584dcc3db5c612875887cb" title="Run the progress engine.">doca_pe_progress()</a> for details.</p>
<p>Any failure/error inside this function should be handled internally or deferred; Since this function is nested in the execution of <a class="el" href="group__DOCA__PE.html#ga9a0e5d8d7a584dcc3db5c612875887cb" title="Run the progress engine.">doca_pe_progress()</a>, this callback doesn't return an error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rdma_connection</td><td>Connection related data required for doca_rdma to connect. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The implementation can assume this value is not NULL. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">connection_user_data</td><td>The <a class="el" href="uniondoca__data.html" title="Convenience type for representing opaque data.">doca_data</a> supplied to the connection by the application (during connection or by a setter). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx_user_data</td><td>The <a class="el" href="uniondoca__data.html" title="Convenience type for representing opaque data.">doca_data</a> supplied to the doca_ctx by the application (using a setter). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="doca__rdma_8h_source.html#l01248">1248</a> of file <a class="el" href="doca__rdma_8h_source.html">doca_rdma.h</a>.</p>

</div>
</div>
<a id="ga32d1ed957b273e7c459a8d0f71dded3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga32d1ed957b273e7c459a8d0f71dded3f">&#9670;&nbsp;</a></span>doca_rdma_connection_request_cb_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* doca_rdma_connection_request_cb_t) (struct doca_rdma_connection *rdma_connection, union <a class="el" href="uniondoca__data.html">doca_data</a> ctx_user_data)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to execute on connection request event. </p>
<p>This function is called by <a class="el" href="group__DOCA__PE.html#ga9a0e5d8d7a584dcc3db5c612875887cb" title="Run the progress engine.">doca_pe_progress()</a> when a connection request is received by a server. When this function is called the user (acting as a server) will receive notification of a connection request. Inside this callback the user may decide whether to accept or reject this connection. Inside this callback the user shouldn't call <a class="el" href="group__DOCA__PE.html#ga9a0e5d8d7a584dcc3db5c612875887cb" title="Run the progress engine.">doca_pe_progress()</a>. Please see <a class="el" href="group__DOCA__PE.html#ga9a0e5d8d7a584dcc3db5c612875887cb" title="Run the progress engine.">doca_pe_progress()</a> for details.</p>
<p>Any failure/error inside this function should be handled internally or deferred; Since this function is nested in the execution of <a class="el" href="group__DOCA__PE.html#ga9a0e5d8d7a584dcc3db5c612875887cb" title="Run the progress engine.">doca_pe_progress()</a>, this callback doesn't return an error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rdma_connection</td><td>Connection related data required for doca_rdma to connect. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The implementation can assume this value is not NULL. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx_user_data</td><td>The <a class="el" href="uniondoca__data.html" title="Convenience type for representing opaque data.">doca_data</a> supplied to the doca_ctx by the application (using a setter). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="doca__rdma_8h_source.html#l01201">1201</a> of file <a class="el" href="doca__rdma_8h_source.html">doca_rdma.h</a>.</p>

</div>
</div>
<a id="ga0e23f2dcdf3c9e342c204a5623865b8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e23f2dcdf3c9e342c204a5623865b8e">&#9670;&nbsp;</a></span>doca_rdma_task_atomic_cmp_swp_completion_cb_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* doca_rdma_task_atomic_cmp_swp_completion_cb_t) (struct doca_rdma_task_atomic_cmp_swp *task, union <a class="el" href="uniondoca__data.html">doca_data</a> task_user_data, union <a class="el" href="uniondoca__data.html">doca_data</a> ctx_user_data)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to execute on completion of an atomic compare and swap task. </p>
<p>This function is called by <a class="el" href="group__DOCA__PE.html#ga9a0e5d8d7a584dcc3db5c612875887cb" title="Run the progress engine.">doca_pe_progress()</a> when an atomic compare and swap task is successfully identified as completed. When this function is called the ownership of the task object passes from DOCA back to user. Inside this callback the user may decide on the task object:</p><ul>
<li>re-submit task with <a class="el" href="group__DOCA__PE.html#ga632e751030cb01805462495099773776" title="Submit a task to a progress engine.">doca_task_submit()</a>; task object ownership passed to DOCA</li>
<li>release task with <a class="el" href="group__DOCA__PE.html#gae916a784f1e4119ded756ab1253abbed" title="Free a task back to where it was allocated from.">doca_task_free()</a>; task object ownership passed to DOCA</li>
<li>keep the task object for future re-use; user keeps the ownership on the task object Inside this callback the user shouldn't call <a class="el" href="group__DOCA__PE.html#ga9a0e5d8d7a584dcc3db5c612875887cb" title="Run the progress engine.">doca_pe_progress()</a>. Please see <a class="el" href="group__DOCA__PE.html#ga9a0e5d8d7a584dcc3db5c612875887cb" title="Run the progress engine.">doca_pe_progress()</a> for details.</li>
</ul>
<p>Any failure/error inside this function should be handled internally or deferred; Since this function is nested in the execution of <a class="el" href="group__DOCA__PE.html#ga9a0e5d8d7a584dcc3db5c612875887cb" title="Run the progress engine.">doca_pe_progress()</a>, this callback doesn't return an error.</p>
<dl class="section note"><dt>Note</dt><dd>This callback type is utilized for both successful &amp; failed task completions.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The completed atomic compare and swap task. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The implementation can assume this value is not NULL. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task_user_data</td><td>The <a class="el" href="uniondoca__data.html" title="Convenience type for representing opaque data.">doca_data</a> supplied to the task by the application (during task allocation or by a setter). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx_user_data</td><td>The <a class="el" href="uniondoca__data.html" title="Convenience type for representing opaque data.">doca_data</a> supplied to the doca_ctx by the application (using a setter). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="doca__rdma_8h_source.html#l02647">2647</a> of file <a class="el" href="doca__rdma_8h_source.html">doca_rdma.h</a>.</p>

</div>
</div>
<a id="ga16c1f55e5724609d494ae369d81421a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga16c1f55e5724609d494ae369d81421a0">&#9670;&nbsp;</a></span>doca_rdma_task_atomic_fetch_add_completion_cb_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* doca_rdma_task_atomic_fetch_add_completion_cb_t) (struct doca_rdma_task_atomic_fetch_add *task, union <a class="el" href="uniondoca__data.html">doca_data</a> task_user_data, union <a class="el" href="uniondoca__data.html">doca_data</a> ctx_user_data)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to execute on completion of an atomic fetch and add task. </p>
<p>This function is called by <a class="el" href="group__DOCA__PE.html#ga9a0e5d8d7a584dcc3db5c612875887cb" title="Run the progress engine.">doca_pe_progress()</a> when an atomic fetch and add task is successfully identified as completed. When this function is called the ownership of the task object passes from DOCA back to user. Inside this callback the user may decide on the task object:</p><ul>
<li>re-submit task with <a class="el" href="group__DOCA__PE.html#ga632e751030cb01805462495099773776" title="Submit a task to a progress engine.">doca_task_submit()</a>; task object ownership passed to DOCA</li>
<li>release task with <a class="el" href="group__DOCA__PE.html#gae916a784f1e4119ded756ab1253abbed" title="Free a task back to where it was allocated from.">doca_task_free()</a>; task object ownership passed to DOCA</li>
<li>keep the task object for future re-use; user keeps the ownership on the task object Inside this callback the user shouldn't call <a class="el" href="group__DOCA__PE.html#ga9a0e5d8d7a584dcc3db5c612875887cb" title="Run the progress engine.">doca_pe_progress()</a>. Please see <a class="el" href="group__DOCA__PE.html#ga9a0e5d8d7a584dcc3db5c612875887cb" title="Run the progress engine.">doca_pe_progress()</a> for details.</li>
</ul>
<p>Any failure/error inside this function should be handled internally or deferred; Since this function is nested in the execution of <a class="el" href="group__DOCA__PE.html#ga9a0e5d8d7a584dcc3db5c612875887cb" title="Run the progress engine.">doca_pe_progress()</a>, this callback doesn't return an error.</p>
<dl class="section note"><dt>Note</dt><dd>This callback type is utilized for both successful &amp; failed task completions.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The completed atomic fetch and add task. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The implementation can assume this value is not NULL. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task_user_data</td><td>The <a class="el" href="uniondoca__data.html" title="Convenience type for representing opaque data.">doca_data</a> supplied to the task by the application (during task allocation or by a setter). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx_user_data</td><td>The <a class="el" href="uniondoca__data.html" title="Convenience type for representing opaque data.">doca_data</a> supplied to the doca_ctx by the application (using a setter). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="doca__rdma_8h_source.html#l02908">2908</a> of file <a class="el" href="doca__rdma_8h_source.html">doca_rdma.h</a>.</p>

</div>
</div>
<a id="gabc2c0386e7673546d9808fe3fda055f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc2c0386e7673546d9808fe3fda055f5">&#9670;&nbsp;</a></span>doca_rdma_task_read_completion_cb_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* doca_rdma_task_read_completion_cb_t) (struct doca_rdma_task_read *task, union <a class="el" href="uniondoca__data.html">doca_data</a> task_user_data, union <a class="el" href="uniondoca__data.html">doca_data</a> ctx_user_data)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to execute on completion of a read task. </p>
<p>This function is called by <a class="el" href="group__DOCA__PE.html#ga9a0e5d8d7a584dcc3db5c612875887cb" title="Run the progress engine.">doca_pe_progress()</a> when a read task is successfully identified as completed. When this function is called the ownership of the task object passes from DOCA back to user. Inside this callback the user may decide on the task object:</p><ul>
<li>re-submit task with <a class="el" href="group__DOCA__PE.html#ga632e751030cb01805462495099773776" title="Submit a task to a progress engine.">doca_task_submit()</a>; task object ownership passed to DOCA</li>
<li>release task with <a class="el" href="group__DOCA__PE.html#gae916a784f1e4119ded756ab1253abbed" title="Free a task back to where it was allocated from.">doca_task_free()</a>; task object ownership passed to DOCA</li>
<li>keep the task object for future re-use; user keeps the ownership on the task object Inside this callback the user shouldn't call <a class="el" href="group__DOCA__PE.html#ga9a0e5d8d7a584dcc3db5c612875887cb" title="Run the progress engine.">doca_pe_progress()</a>. Please see <a class="el" href="group__DOCA__PE.html#ga9a0e5d8d7a584dcc3db5c612875887cb" title="Run the progress engine.">doca_pe_progress()</a> for details.</li>
</ul>
<p>Any failure/error inside this function should be handled internally or deferred; Since this function is nested in the execution of <a class="el" href="group__DOCA__PE.html#ga9a0e5d8d7a584dcc3db5c612875887cb" title="Run the progress engine.">doca_pe_progress()</a>, this callback doesn't return an error.</p>
<dl class="section note"><dt>Note</dt><dd>This callback type is utilized for both successful &amp; failed task completions.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The completed read task. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The implementation can assume this value is not NULL. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task_user_data</td><td>The <a class="el" href="uniondoca__data.html" title="Convenience type for representing opaque data.">doca_data</a> supplied to the task by the application (during task allocation or by a setter). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx_user_data</td><td>The <a class="el" href="uniondoca__data.html" title="Convenience type for representing opaque data.">doca_data</a> supplied to the doca_ctx by the application (using a setter). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="doca__rdma_8h_source.html#l01987">1987</a> of file <a class="el" href="doca__rdma_8h_source.html">doca_rdma.h</a>.</p>

</div>
</div>
<a id="ga0408ed0a480a862797dcede45efee761"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0408ed0a480a862797dcede45efee761">&#9670;&nbsp;</a></span>doca_rdma_task_receive_completion_cb_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* doca_rdma_task_receive_completion_cb_t) (struct doca_rdma_task_receive *task, union <a class="el" href="uniondoca__data.html">doca_data</a> task_user_data, union <a class="el" href="uniondoca__data.html">doca_data</a> ctx_user_data)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to execute on completion of a receive task. </p>
<p>This function is called by <a class="el" href="group__DOCA__PE.html#ga9a0e5d8d7a584dcc3db5c612875887cb" title="Run the progress engine.">doca_pe_progress()</a> when a receive task is successfully identified as completed. When this function is called the ownership of the task object passes from DOCA back to user. Inside this callback the user may decide on the task object:</p><ul>
<li>re-submit task with <a class="el" href="group__DOCA__PE.html#ga632e751030cb01805462495099773776" title="Submit a task to a progress engine.">doca_task_submit()</a>; task object ownership passed to DOCA</li>
<li>release task with <a class="el" href="group__DOCA__PE.html#gae916a784f1e4119ded756ab1253abbed" title="Free a task back to where it was allocated from.">doca_task_free()</a>; task object ownership passed to DOCA</li>
<li>keep the task object for future re-use; user keeps the ownership on the task object Inside this callback the user shouldn't call <a class="el" href="group__DOCA__PE.html#ga9a0e5d8d7a584dcc3db5c612875887cb" title="Run the progress engine.">doca_pe_progress()</a>. Please see <a class="el" href="group__DOCA__PE.html#ga9a0e5d8d7a584dcc3db5c612875887cb" title="Run the progress engine.">doca_pe_progress()</a> for details.</li>
</ul>
<p>Any failure/error inside this function should be handled internally or deferred; Since this function is nested in the execution of <a class="el" href="group__DOCA__PE.html#ga9a0e5d8d7a584dcc3db5c612875887cb" title="Run the progress engine.">doca_pe_progress()</a>, this callback doesn't return an error.</p>
<dl class="section note"><dt>Note</dt><dd>This callback type is utilized for both successful &amp; failed task completions.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The completed receive task. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The implementation can assume this value is not NULL. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task_user_data</td><td>The <a class="el" href="uniondoca__data.html" title="Convenience type for representing opaque data.">doca_data</a> supplied to the task by the application (during task allocation or by a setter). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx_user_data</td><td>The <a class="el" href="uniondoca__data.html" title="Convenience type for representing opaque data.">doca_data</a> supplied to the doca_ctx by the application (using a setter). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="doca__rdma_8h_source.html#l01349">1349</a> of file <a class="el" href="doca__rdma_8h_source.html">doca_rdma.h</a>.</p>

</div>
</div>
<a id="ga9dcb777cfd90aaa306faba7c4f7aad14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9dcb777cfd90aaa306faba7c4f7aad14">&#9670;&nbsp;</a></span>doca_rdma_task_remote_net_sync_event_get_completion_cb_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* doca_rdma_task_remote_net_sync_event_get_completion_cb_t) (struct doca_rdma_task_remote_net_sync_event_get *task, union <a class="el" href="uniondoca__data.html">doca_data</a> task_user_data, union <a class="el" href="uniondoca__data.html">doca_data</a> ctx_user_data)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to execute on completion of a remote_net_sync_event_get task. </p>
<p>This function is called by <a class="el" href="group__DOCA__PE.html#ga9a0e5d8d7a584dcc3db5c612875887cb" title="Run the progress engine.">doca_pe_progress()</a> when a remote_net_sync_event_get task is successfully identified as completed. When this function is called the ownership of the task object passes from DOCA back to user. Inside this callback the user may decide on the task object:</p><ul>
<li>re-submit task with <a class="el" href="group__DOCA__PE.html#ga632e751030cb01805462495099773776" title="Submit a task to a progress engine.">doca_task_submit()</a>; task object ownership passed to DOCA</li>
<li>release task with <a class="el" href="group__DOCA__PE.html#gae916a784f1e4119ded756ab1253abbed" title="Free a task back to where it was allocated from.">doca_task_free()</a>; task object ownership passed to DOCA</li>
<li>keep the task object for future re-use; user keeps the ownership on the task object Inside this callback the user shouldn't call <a class="el" href="group__DOCA__PE.html#ga9a0e5d8d7a584dcc3db5c612875887cb" title="Run the progress engine.">doca_pe_progress()</a>. Please see <a class="el" href="group__DOCA__PE.html#ga9a0e5d8d7a584dcc3db5c612875887cb" title="Run the progress engine.">doca_pe_progress()</a> for details.</li>
</ul>
<p>Any failure/error inside this function should be handled internally or deferred; Since this function is nested in the execution of <a class="el" href="group__DOCA__PE.html#ga9a0e5d8d7a584dcc3db5c612875887cb" title="Run the progress engine.">doca_pe_progress()</a>, this callback doesn't return an error.</p>
<dl class="section note"><dt>Note</dt><dd>This callback type is utilized for both successful &amp; failed task completions.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The completed remote_net_sync_event_get task. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The implementation can assume this value is not NULL. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task_user_data</td><td>The <a class="el" href="uniondoca__data.html" title="Convenience type for representing opaque data.">doca_data</a> supplied to the task by the application (during task allocation or by a setter). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx_user_data</td><td>The <a class="el" href="uniondoca__data.html" title="Convenience type for representing opaque data.">doca_data</a> supplied to the doca_ctx by the application (using a setter). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="doca__rdma_8h_source.html#l03138">3138</a> of file <a class="el" href="doca__rdma_8h_source.html">doca_rdma.h</a>.</p>

</div>
</div>
<a id="ga17916c135eaba7a8bc303a5cc072e9dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga17916c135eaba7a8bc303a5cc072e9dd">&#9670;&nbsp;</a></span>doca_rdma_task_remote_net_sync_event_notify_add_completion_cb_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* doca_rdma_task_remote_net_sync_event_notify_add_completion_cb_t) (struct doca_rdma_task_remote_net_sync_event_notify_add *task, union <a class="el" href="uniondoca__data.html">doca_data</a> task_user_data, union <a class="el" href="uniondoca__data.html">doca_data</a> ctx_user_data)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to execute on completion of a remote_net_sync_event_notify_add task. </p>
<p>This function is called by <a class="el" href="group__DOCA__PE.html#ga9a0e5d8d7a584dcc3db5c612875887cb" title="Run the progress engine.">doca_pe_progress()</a> when a remote_net_sync_event_notify_add task is successfully identified as completed. When this function is called the ownership of the task object passes from DOCA back to user. Inside this callback the user may decide on the task object:</p><ul>
<li>re-submit task with <a class="el" href="group__DOCA__PE.html#ga632e751030cb01805462495099773776" title="Submit a task to a progress engine.">doca_task_submit()</a>; task object ownership passed to DOCA</li>
<li>release task with <a class="el" href="group__DOCA__PE.html#gae916a784f1e4119ded756ab1253abbed" title="Free a task back to where it was allocated from.">doca_task_free()</a>; task object ownership passed to DOCA</li>
<li>keep the task object for future re-use; user keeps the ownership on the task object Inside this callback the user shouldn't call <a class="el" href="group__DOCA__PE.html#ga9a0e5d8d7a584dcc3db5c612875887cb" title="Run the progress engine.">doca_pe_progress()</a>. Please see <a class="el" href="group__DOCA__PE.html#ga9a0e5d8d7a584dcc3db5c612875887cb" title="Run the progress engine.">doca_pe_progress()</a> for details.</li>
</ul>
<p>Any failure/error inside this function should be handled internally or deferred; Since this function is nested in the execution of <a class="el" href="group__DOCA__PE.html#ga9a0e5d8d7a584dcc3db5c612875887cb" title="Run the progress engine.">doca_pe_progress()</a>, this callback doesn't return an error.</p>
<dl class="section note"><dt>Note</dt><dd>This callback type is utilized for both successful &amp; failed task completions.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The completed remote_net_sync_event_notify_add task. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The implementation can assume this value is not NULL. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task_user_data</td><td>The <a class="el" href="uniondoca__data.html" title="Convenience type for representing opaque data.">doca_data</a> supplied to the task by the application (during task allocation or by a setter). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx_user_data</td><td>The <a class="el" href="uniondoca__data.html" title="Convenience type for representing opaque data.">doca_data</a> supplied to the doca_ctx by the application (using a setter). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="doca__rdma_8h_source.html#l03564">3564</a> of file <a class="el" href="doca__rdma_8h_source.html">doca_rdma.h</a>.</p>

</div>
</div>
<a id="ga856a75fbd80e9fda88005b6012fd3d52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga856a75fbd80e9fda88005b6012fd3d52">&#9670;&nbsp;</a></span>doca_rdma_task_remote_net_sync_event_notify_set_completion_cb_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* doca_rdma_task_remote_net_sync_event_notify_set_completion_cb_t) (struct doca_rdma_task_remote_net_sync_event_notify_set *task, union <a class="el" href="uniondoca__data.html">doca_data</a> task_user_data, union <a class="el" href="uniondoca__data.html">doca_data</a> ctx_user_data)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to execute on completion of a remote_net_sync_event_notify_set task. </p>
<p>This function is called by <a class="el" href="group__DOCA__PE.html#ga9a0e5d8d7a584dcc3db5c612875887cb" title="Run the progress engine.">doca_pe_progress()</a> when a remote_net_sync_event_notify_set task is successfully identified as completed. When this function is called the ownership of the task object passes from DOCA back to user. Inside this callback the user may decide on the task object:</p><ul>
<li>re-submit task with <a class="el" href="group__DOCA__PE.html#ga632e751030cb01805462495099773776" title="Submit a task to a progress engine.">doca_task_submit()</a>; task object ownership passed to DOCA</li>
<li>release task with <a class="el" href="group__DOCA__PE.html#gae916a784f1e4119ded756ab1253abbed" title="Free a task back to where it was allocated from.">doca_task_free()</a>; task object ownership passed to DOCA</li>
<li>keep the task object for future re-use; user keeps the ownership on the task object Inside this callback the user shouldn't call <a class="el" href="group__DOCA__PE.html#ga9a0e5d8d7a584dcc3db5c612875887cb" title="Run the progress engine.">doca_pe_progress()</a>. Please see <a class="el" href="group__DOCA__PE.html#ga9a0e5d8d7a584dcc3db5c612875887cb" title="Run the progress engine.">doca_pe_progress()</a> for details.</li>
</ul>
<p>Any failure/error inside this function should be handled internally or deferred; Since this function is nested in the execution of <a class="el" href="group__DOCA__PE.html#ga9a0e5d8d7a584dcc3db5c612875887cb" title="Run the progress engine.">doca_pe_progress()</a>, this callback doesn't return an error.</p>
<dl class="section note"><dt>Note</dt><dd>This callback type is utilized for both successful &amp; failed task completions.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The completed remote_net_sync_event_notify_set task. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The implementation can assume this value is not NULL. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task_user_data</td><td>The <a class="el" href="uniondoca__data.html" title="Convenience type for representing opaque data.">doca_data</a> supplied to the task by the application (during task allocation or by a setter). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx_user_data</td><td>The <a class="el" href="uniondoca__data.html" title="Convenience type for representing opaque data.">doca_data</a> supplied to the doca_ctx by the application (using a setter). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="doca__rdma_8h_source.html#l03357">3357</a> of file <a class="el" href="doca__rdma_8h_source.html">doca_rdma.h</a>.</p>

</div>
</div>
<a id="ga8e87e2039e435abe52200598623f0cac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8e87e2039e435abe52200598623f0cac">&#9670;&nbsp;</a></span>doca_rdma_task_send_completion_cb_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* doca_rdma_task_send_completion_cb_t) (struct doca_rdma_task_send *task, union <a class="el" href="uniondoca__data.html">doca_data</a> task_user_data, union <a class="el" href="uniondoca__data.html">doca_data</a> ctx_user_data)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to execute on completion of a send task. </p>
<p>This function is called by <a class="el" href="group__DOCA__PE.html#ga9a0e5d8d7a584dcc3db5c612875887cb" title="Run the progress engine.">doca_pe_progress()</a> when a send task is successfully identified as completed. When this function is called the ownership of the task object passes from DOCA back to user. Inside this callback the user may decide on the task object:</p><ul>
<li>re-submit task with <a class="el" href="group__DOCA__PE.html#ga632e751030cb01805462495099773776" title="Submit a task to a progress engine.">doca_task_submit()</a>; task object ownership passed to DOCA</li>
<li>release task with <a class="el" href="group__DOCA__PE.html#gae916a784f1e4119ded756ab1253abbed" title="Free a task back to where it was allocated from.">doca_task_free()</a>; task object ownership passed to DOCA</li>
<li>keep the task object for future re-use; user keeps the ownership on the task object Inside this callback the user shouldn't call <a class="el" href="group__DOCA__PE.html#ga9a0e5d8d7a584dcc3db5c612875887cb" title="Run the progress engine.">doca_pe_progress()</a>. Please see <a class="el" href="group__DOCA__PE.html#ga9a0e5d8d7a584dcc3db5c612875887cb" title="Run the progress engine.">doca_pe_progress()</a> for details.</li>
</ul>
<p>Any failure/error inside this function should be handled internally or deferred; Since this function is nested in the execution of <a class="el" href="group__DOCA__PE.html#ga9a0e5d8d7a584dcc3db5c612875887cb" title="Run the progress engine.">doca_pe_progress()</a>, this callback doesn't return an error.</p>
<dl class="section note"><dt>Note</dt><dd>This callback type is utilized for both successful &amp; failed task completions.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The completed send task. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The implementation can assume this value is not NULL. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task_user_data</td><td>The <a class="el" href="uniondoca__data.html" title="Convenience type for representing opaque data.">doca_data</a> supplied to the task by the application (during task allocation or by a setter). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx_user_data</td><td>The <a class="el" href="uniondoca__data.html" title="Convenience type for representing opaque data.">doca_data</a> supplied to the doca_ctx by the application (using a setter). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="doca__rdma_8h_source.html#l01614">1614</a> of file <a class="el" href="doca__rdma_8h_source.html">doca_rdma.h</a>.</p>

</div>
</div>
<a id="ga86fa09af84fd6b25a24ba2e64e8d0360"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga86fa09af84fd6b25a24ba2e64e8d0360">&#9670;&nbsp;</a></span>doca_rdma_task_send_imm_completion_cb_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* doca_rdma_task_send_imm_completion_cb_t) (struct doca_rdma_task_send_imm *task, union <a class="el" href="uniondoca__data.html">doca_data</a> task_user_data, union <a class="el" href="uniondoca__data.html">doca_data</a> ctx_user_data)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to execute on completion of a send with immediate task. </p>
<p>This function is called by <a class="el" href="group__DOCA__PE.html#ga9a0e5d8d7a584dcc3db5c612875887cb" title="Run the progress engine.">doca_pe_progress()</a> when a send with immediate task is successfully identified as completed. When this function is called the ownership of the task object passes from DOCA back to user. Inside this callback the user may decide on the task object:</p><ul>
<li>re-submit task with <a class="el" href="group__DOCA__PE.html#ga632e751030cb01805462495099773776" title="Submit a task to a progress engine.">doca_task_submit()</a>; task object ownership passed to DOCA</li>
<li>release task with <a class="el" href="group__DOCA__PE.html#gae916a784f1e4119ded756ab1253abbed" title="Free a task back to where it was allocated from.">doca_task_free()</a>; task object ownership passed to DOCA</li>
<li>keep the task object for future re-use; user keeps the ownership on the task object Inside this callback the user shouldn't call <a class="el" href="group__DOCA__PE.html#ga9a0e5d8d7a584dcc3db5c612875887cb" title="Run the progress engine.">doca_pe_progress()</a>. Please see <a class="el" href="group__DOCA__PE.html#ga9a0e5d8d7a584dcc3db5c612875887cb" title="Run the progress engine.">doca_pe_progress()</a> for details.</li>
</ul>
<p>Any failure/error inside this function should be handled internally or deferred; Since this function is nested in the execution of <a class="el" href="group__DOCA__PE.html#ga9a0e5d8d7a584dcc3db5c612875887cb" title="Run the progress engine.">doca_pe_progress()</a>, this callback doesn't return an error.</p>
<dl class="section note"><dt>Note</dt><dd>This callback type is utilized for both successful &amp; failed task completions.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The completed send with immediate task. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The implementation can assume this value is not NULL. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task_user_data</td><td>The <a class="el" href="uniondoca__data.html" title="Convenience type for representing opaque data.">doca_data</a> supplied to the task by the application (during task allocation or by a setter). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx_user_data</td><td>The <a class="el" href="uniondoca__data.html" title="Convenience type for representing opaque data.">doca_data</a> supplied to the doca_ctx by the application (using a setter). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="doca__rdma_8h_source.html#l01787">1787</a> of file <a class="el" href="doca__rdma_8h_source.html">doca_rdma.h</a>.</p>

</div>
</div>
<a id="gaf81a8b85901e3017b44eba70873cc322"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf81a8b85901e3017b44eba70873cc322">&#9670;&nbsp;</a></span>doca_rdma_task_write_completion_cb_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* doca_rdma_task_write_completion_cb_t) (struct doca_rdma_task_write *task, union <a class="el" href="uniondoca__data.html">doca_data</a> task_user_data, union <a class="el" href="uniondoca__data.html">doca_data</a> ctx_user_data)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to execute on completion of a write task. </p>
<p>This function is called by <a class="el" href="group__DOCA__PE.html#ga9a0e5d8d7a584dcc3db5c612875887cb" title="Run the progress engine.">doca_pe_progress()</a> when a write task is successfully identified as completed. When this function is called the ownership of the task object passes from DOCA back to user. Inside this callback the user may decide on the task object:</p><ul>
<li>re-submit task with <a class="el" href="group__DOCA__PE.html#ga632e751030cb01805462495099773776" title="Submit a task to a progress engine.">doca_task_submit()</a>; task object ownership passed to DOCA</li>
<li>release task with <a class="el" href="group__DOCA__PE.html#gae916a784f1e4119ded756ab1253abbed" title="Free a task back to where it was allocated from.">doca_task_free()</a>; task object ownership passed to DOCA</li>
<li>keep the task object for future re-use; user keeps the ownership on the task object Inside this callback the user shouldn't call <a class="el" href="group__DOCA__PE.html#ga9a0e5d8d7a584dcc3db5c612875887cb" title="Run the progress engine.">doca_pe_progress()</a>. Please see <a class="el" href="group__DOCA__PE.html#ga9a0e5d8d7a584dcc3db5c612875887cb" title="Run the progress engine.">doca_pe_progress()</a> for details.</li>
</ul>
<p>Any failure/error inside this function should be handled internally or deferred; Since this function is nested in the execution of <a class="el" href="group__DOCA__PE.html#ga9a0e5d8d7a584dcc3db5c612875887cb" title="Run the progress engine.">doca_pe_progress()</a>, this callback doesn't return an error.</p>
<dl class="section note"><dt>Note</dt><dd>This callback type is utilized for both successful &amp; failed task completions.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The completed write task. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The implementation can assume this value is not NULL. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task_user_data</td><td>The <a class="el" href="uniondoca__data.html" title="Convenience type for representing opaque data.">doca_data</a> supplied to the task by the application (during task allocation or by a setter). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx_user_data</td><td>The <a class="el" href="uniondoca__data.html" title="Convenience type for representing opaque data.">doca_data</a> supplied to the doca_ctx by the application (using a setter). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="doca__rdma_8h_source.html#l02203">2203</a> of file <a class="el" href="doca__rdma_8h_source.html">doca_rdma.h</a>.</p>

</div>
</div>
<a id="gaf46528474ecc323adb02c804fca60edc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf46528474ecc323adb02c804fca60edc">&#9670;&nbsp;</a></span>doca_rdma_task_write_imm_completion_cb_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* doca_rdma_task_write_imm_completion_cb_t) (struct doca_rdma_task_write_imm *task, union <a class="el" href="uniondoca__data.html">doca_data</a> task_user_data, union <a class="el" href="uniondoca__data.html">doca_data</a> ctx_user_data)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to execute on completion of a write with immediate task. </p>
<p>This function is called by <a class="el" href="group__DOCA__PE.html#ga9a0e5d8d7a584dcc3db5c612875887cb" title="Run the progress engine.">doca_pe_progress()</a> when a write with immediate task is successfully identified as completed. When this function is called the ownership of the task object passes from DOCA back to user. Inside this callback the user may decide on the task object:</p><ul>
<li>re-submit task with <a class="el" href="group__DOCA__PE.html#ga632e751030cb01805462495099773776" title="Submit a task to a progress engine.">doca_task_submit()</a>; task object ownership passed to DOCA</li>
<li>release task with <a class="el" href="group__DOCA__PE.html#gae916a784f1e4119ded756ab1253abbed" title="Free a task back to where it was allocated from.">doca_task_free()</a>; task object ownership passed to DOCA</li>
<li>keep the task object for future re-use; user keeps the ownership on the task object Inside this callback the user shouldn't call <a class="el" href="group__DOCA__PE.html#ga9a0e5d8d7a584dcc3db5c612875887cb" title="Run the progress engine.">doca_pe_progress()</a>. Please see <a class="el" href="group__DOCA__PE.html#ga9a0e5d8d7a584dcc3db5c612875887cb" title="Run the progress engine.">doca_pe_progress()</a> for details.</li>
</ul>
<p>Any failure/error inside this function should be handled internally or deferred; Since this function is nested in the execution of <a class="el" href="group__DOCA__PE.html#ga9a0e5d8d7a584dcc3db5c612875887cb" title="Run the progress engine.">doca_pe_progress()</a>, this callback doesn't return an error.</p>
<dl class="section note"><dt>Note</dt><dd>This callback type is utilized for both successful &amp; failed task completions.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The completed write with immediate task. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The implementation can assume this value is not NULL. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task_user_data</td><td>The <a class="el" href="uniondoca__data.html" title="Convenience type for representing opaque data.">doca_data</a> supplied to the task by the application (during task allocation or by a setter). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx_user_data</td><td>The <a class="el" href="uniondoca__data.html" title="Convenience type for representing opaque data.">doca_data</a> supplied to the doca_ctx by the application (using a setter). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="doca__rdma_8h_source.html#l02409">2409</a> of file <a class="el" href="doca__rdma_8h_source.html">doca_rdma.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga9b86300b1a5ece749397138a3aeba419"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9b86300b1a5ece749397138a3aeba419">&#9670;&nbsp;</a></span>doca_rdma_addr_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__DOCA__RDMA.html#ga9b86300b1a5ece749397138a3aeba419">doca_rdma_addr_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>DOCA RDMA addr type </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga9b86300b1a5ece749397138a3aeba419a6e010baf02bb36a44eee8258af188946"></a>DOCA_RDMA_ADDR_TYPE_IPv4&#160;</td><td class="fielddoc"><p>IPv4 type </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9b86300b1a5ece749397138a3aeba419a1614698a02125c8240c71c2fc6ba0725"></a>DOCA_RDMA_ADDR_TYPE_IPv6&#160;</td><td class="fielddoc"><p>IPv6 type </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9b86300b1a5ece749397138a3aeba419aec5dccb65f1a17d4342357ab51508f17"></a>DOCA_RDMA_ADDR_TYPE_GID&#160;</td><td class="fielddoc"><p>GID type </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="doca__rdma_8h_source.html#l00056">56</a> of file <a class="el" href="doca__rdma_8h_source.html">doca_rdma.h</a>.</p>

</div>
</div>
<a id="ga3cbcdbcd5adcbc7aa0b4eae4376ec9c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3cbcdbcd5adcbc7aa0b4eae4376ec9c8">&#9670;&nbsp;</a></span>doca_rdma_opcode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__DOCA__RDMA.html#ga3cbcdbcd5adcbc7aa0b4eae4376ec9c8">doca_rdma_opcode</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Task receive result opcodes </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga3cbcdbcd5adcbc7aa0b4eae4376ec9c8ab50cced97b070060f324b3cfc28331dd"></a>DOCA_RDMA_OPCODE_RECV_SEND&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga3cbcdbcd5adcbc7aa0b4eae4376ec9c8aded1221acba0fa765e4b03c6036b6319"></a>DOCA_RDMA_OPCODE_RECV_SEND_WITH_IMM&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga3cbcdbcd5adcbc7aa0b4eae4376ec9c8a026515412e9e5a760c8fa686e571db76"></a>DOCA_RDMA_OPCODE_RECV_WRITE_WITH_IMM&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="doca__rdma_8h_source.html#l01318">1318</a> of file <a class="el" href="doca__rdma_8h_source.html">doca_rdma.h</a>.</p>

</div>
</div>
<a id="gaa5f02468536d7f851c155978d0867e3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa5f02468536d7f851c155978d0867e3a">&#9670;&nbsp;</a></span>doca_rdma_transport_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__DOCA__RDMA.html#gaa5f02468536d7f851c155978d0867e3a">doca_rdma_transport_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Available transport types for RDMA </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaa5f02468536d7f851c155978d0867e3aa86dbd3ef7516ae39bd929edccc3125d6"></a>DOCA_RDMA_TRANSPORT_TYPE_RC&#160;</td><td class="fielddoc"><p>RC transport type </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa5f02468536d7f851c155978d0867e3aac1943626da460015b184ebbb408d99a2"></a>DOCA_RDMA_TRANSPORT_TYPE_DC&#160;</td><td class="fielddoc"><p>DC transport type, supported only in export/connect flow and CPU datapath </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="doca__rdma_8h_source.html#l00045">45</a> of file <a class="el" href="doca__rdma_8h_source.html">doca_rdma.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaa05128ab8a15bb3260f29167b7ffc7d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa05128ab8a15bb3260f29167b7ffc7d0">&#9670;&nbsp;</a></span>doca_rdma_addr_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_rdma_addr_create </td>
          <td>(</td>
          <td class="paramtype">enum <a class="el" href="group__DOCA__RDMA.html#ga9b86300b1a5ece749397138a3aeba419">doca_rdma_addr_type</a>&#160;</td>
          <td class="paramname"><em>addr_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct doca_rdma_addr **&#160;</td>
          <td class="paramname"><em>addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set connection address object for doca_rdma. The object can be queried using <a class="el" href="group__DOCA__RDMA.html#ga3be468cbf62683acfe30eac98f334aca" title="Get connection address object from a doca_rdma_connection.">doca_rdma_connection_get_addr()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr_type</td><td>According to doca_rdma_addr_type enum. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>Address to set the connection rdma_connection to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">port</td><td>Port to set the connection rdma_connection to. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">addr</td><td>Address object to use in context for connection.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - if an invalid parameter was given.</li>
<li>DOCA_ERROR_NO_MEMORY - failed to allocate resources. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga3b189a1c772fdc94490d874ba81fc731"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b189a1c772fdc94490d874ba81fc731">&#9670;&nbsp;</a></span>doca_rdma_addr_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_rdma_addr_destroy </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma_addr *&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy connection address object for doca_rdma. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>Address object to be destroyed use in context for connection.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - if an invalid parameter was given.</li>
<li>DOCA_ERROR_BAD_STATE - if address is actively being used </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga2cbac1236b1221787ea483168da8ca55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2cbac1236b1221787ea483168da8ca55">&#9670;&nbsp;</a></span>doca_rdma_addr_get_params()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_rdma_addr_get_params </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma_addr *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__DOCA__RDMA.html#ga9b86300b1a5ece749397138a3aeba419">doca_rdma_addr_type</a> *&#160;</td>
          <td class="paramname"><em>addr_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get address object parameters from an address object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>A pointer to the address object to retrieve the parameters from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">addr_type</td><td>Address type to retrieve from address object. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">address</td><td>Address to retrieve from address object. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">port</td><td>Port to retrieve from address object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - if an invalid parameter was given. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gadab302408c4c1cfe749328aa70c6502d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadab302408c4c1cfe749328aa70c6502d">&#9670;&nbsp;</a></span>doca_rdma_as_ctx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> struct doca_ctx* doca_rdma_as_ctx </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma *&#160;</td>
          <td class="paramname"><em>rdma</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert doca_rdma instance into a generalized context for use with doca core objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rdma</td><td>RDMA instance. This must remain valid until after the context is no longer required.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non NULL upon success, NULL otherwise. </dd></dl>

</div>
</div>
<a id="ga444674736f797c9089ab45686bf4027b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga444674736f797c9089ab45686bf4027b">&#9670;&nbsp;</a></span>doca_rdma_bridge_accept()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_rdma_bridge_accept </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma *&#160;</td>
          <td class="paramname"><em>rdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>private_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>private_data_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct doca_rdma_connection *&#160;</td>
          <td class="paramname"><em>rdma_connection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accept the connection from client side acting as a bridge. This method acts as a bridge to accept a connection request from an application that performs the listen process by itself. Can be called when the ctx is in DOCA_CTX_STATE_RUNNING state. Only after a connection is established can send tasks be allocated and submitted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rdma</td><td>Pointer to doca_rdma to connect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">private_data</td><td>The RDMA connection private data to be sent in RDMA CM ACCEPT. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If private data is not needed then this argument should be NULL </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">private_data_len</td><td>The RDMA connection size of the private data that is sent in RDMA CM ACCEPT. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If private data is not needed then this argument should be 0 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rdma_connection</td><td>Connection related data required for doca_rdma to connect.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - if an invalid parameter was given.</li>
<li>DOCA_ERROR_BAD_STATE - if context is in an invalid or error state.</li>
<li>DOCA_ERROR_NOT_SUPPORTED - if the current datapath is not supported.</li>
<li>DOCA_ERROR_CONNECTION_ABORTED - if connection failed. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga25b5a30ec836f0c467efe4cebc2f8fa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga25b5a30ec836f0c467efe4cebc2f8fa2">&#9670;&nbsp;</a></span>doca_rdma_bridge_established()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_rdma_bridge_established </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma *&#160;</td>
          <td class="paramname"><em>rdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct doca_rdma_connection *&#160;</td>
          <td class="paramname"><em>rdma_connection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Notify the server side of the successful established connection with client Can be called when the ctx is in DOCA_CTX_STATE_RUNNING state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rdma</td><td>Pointer to doca_rdma to connect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rdma_connection</td><td>Connection related data required for doca_rdma to connect.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - if an invalid parameter was given.</li>
<li>DOCA_ERROR_NOT_SUPPORTED - if the current datapath is not supported. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga161593c0bcd2ea98b7b5c2c7844965b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga161593c0bcd2ea98b7b5c2c7844965b1">&#9670;&nbsp;</a></span>doca_rdma_bridge_prepare_connection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_rdma_bridge_prepare_connection </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma *&#160;</td>
          <td class="paramname"><em>rdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct rdma_cm_id *&#160;</td>
          <td class="paramname"><em>cm_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct doca_rdma_connection **&#160;</td>
          <td class="paramname"><em>rdma_connection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prepare the connection and perform the doca connection to client side acting as a bridge. This method acts as a bridge to prepare and perform the doca connection to a connection request from an application that performs the listen process by itself. This function only prepare the DOCA connection, it is necessary to call <a class="el" href="group__DOCA__RDMA.html#ga444674736f797c9089ab45686bf4027b" title="Accept the connection from client side acting as a bridge. This method acts as a bridge to accept a c...">doca_rdma_bridge_accept()</a>, to continue the connection process. Can be called when the ctx is in DOCA_CTX_STATE_RUNNING state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rdma</td><td>Pointer to doca_rdma to connect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cm_id</td><td>RDMA CM ID object that carries the connection details. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>DOCA RDMA assumes ownership over the cm_id. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">rdma_connection</td><td>Connection related data required for doca_rdma to connect.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_FULL - if all connections are being used.</li>
<li>DOCA_ERROR_BAD_STATE - if context is in an invalid or error state.</li>
<li>DOCA_ERROR_NO_MEMORY - failed to allocate resources.</li>
<li>DOCA_ERROR_INVALID_VALUE - if an invalid parameter was given.</li>
<li>DOCA_ERROR_NOT_SUPPORTED - if the current datapath is not supported.</li>
<li>DOCA_ERROR_CONNECTION_ABORTED - if connection failed. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga3d1690963d3d4e892c557cb9eeb51371"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d1690963d3d4e892c557cb9eeb51371">&#9670;&nbsp;</a></span>doca_rdma_cap_get_gid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_rdma_cap_get_gid </td>
          <td>(</td>
          <td class="paramtype">const struct doca_devinfo *&#160;</td>
          <td class="paramname"><em>devinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>start_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num_entries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structdoca__rdma__gid.html">doca_rdma_gid</a> *&#160;</td>
          <td class="paramname"><em>gid_array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get gids for a specific device by index and number of entries.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">devinfo</td><td>The DOCA device information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">start_index</td><td>The first gid index of interest </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_entries</td><td>The number of desired gid indices </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">gid_array</td><td>A 'struct <a class="el" href="structdoca__rdma__gid.html">doca_rdma_gid</a>' array of size 'num_entries', that on success will hold the desired gids. Note that it is the user's responsibility to provide an array with enough entries to prevent data corruption</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input.</li>
<li>DOCA_ERROR_DRIVER - failed to query device capabilities. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gadeb98de0aebe0c410ec2dcb21d5da4d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadeb98de0aebe0c410ec2dcb21d5da4d8">&#9670;&nbsp;</a></span>doca_rdma_cap_get_gid_table_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_rdma_cap_get_gid_table_size </td>
          <td>(</td>
          <td class="paramtype">const struct doca_devinfo *&#160;</td>
          <td class="paramname"><em>devinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>gid_table_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the gid table size for a specific device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">devinfo</td><td>The DOCA device information </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">gid_table_size</td><td>The gid table size for the given devinfo.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input.</li>
<li>DOCA_ERROR_DRIVER - failed to query device capabilities. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaf99113245debd46df6ee835b400bb98e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf99113245debd46df6ee835b400bb98e">&#9670;&nbsp;</a></span>doca_rdma_cap_get_max_message_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_rdma_cap_get_max_message_size </td>
          <td>(</td>
          <td class="paramtype">const struct doca_devinfo *&#160;</td>
          <td class="paramname"><em>devinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>max_message_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the maximal message size for a specific device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">devinfo</td><td>The DOCA device information </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">max_message_size</td><td>The maximal message size for the given devinfo.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input.</li>
<li>DOCA_ERROR_DRIVER - failed to query device capabilities. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaa7d69e4a4ecebebd0b26c40a9603702a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa7d69e4a4ecebebd0b26c40a9603702a">&#9670;&nbsp;</a></span>doca_rdma_cap_get_max_recv_queue_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_rdma_cap_get_max_recv_queue_size </td>
          <td>(</td>
          <td class="paramtype">const struct doca_devinfo *&#160;</td>
          <td class="paramname"><em>devinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>max_recv_queue_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the maximal recv queue size for a specific device. </p>
<dl class="section note"><dt>Note</dt><dd>This capability is not relevant when using RDMA SRQ.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">devinfo</td><td>The DOCA device information </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">max_recv_queue_size</td><td>The maximal recv queue size for the given devinfo.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input.</li>
<li>DOCA_ERROR_DRIVER - failed to query device capabilities. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaad89662e98acbc23dd434ac05f2f5de4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad89662e98acbc23dd434ac05f2f5de4">&#9670;&nbsp;</a></span>doca_rdma_cap_get_max_send_buf_list_len()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_rdma_cap_get_max_send_buf_list_len </td>
          <td>(</td>
          <td class="paramtype">const struct doca_devinfo *&#160;</td>
          <td class="paramname"><em>devinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>max_send_buf_list_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the maximal buffer list length property for buffers of tasks that are sent to the remote and in which linked list are supported (i.e. send, send_imm, read, write, write_imm). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">devinfo</td><td>The DOCA device information </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">max_send_buf_list_len</td><td>Maximal buffer list length to used for buffers that support linked list in relevant tasks, for the given devinfo.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input.</li>
<li>DOCA_ERROR_DRIVER - failed to query device capabilities. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaa749da3cff3fa57824a83eb994931dbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa749da3cff3fa57824a83eb994931dbc">&#9670;&nbsp;</a></span>doca_rdma_cap_get_max_send_queue_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_rdma_cap_get_max_send_queue_size </td>
          <td>(</td>
          <td class="paramtype">const struct doca_devinfo *&#160;</td>
          <td class="paramname"><em>devinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>max_send_queue_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the maximal send queue size for a specific device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">devinfo</td><td>The DOCA device information </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">max_send_queue_size</td><td>The of the maximal send queue size for the given devinfo.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input.</li>
<li>DOCA_ERROR_DRIVER - failed to query device capabilities. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga09a04fc9de7e34d62515ef2437c4713a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga09a04fc9de7e34d62515ef2437c4713a">&#9670;&nbsp;</a></span>doca_rdma_cap_task_atomic_cmp_swp_is_supported()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_rdma_cap_task_atomic_cmp_swp_is_supported </td>
          <td>(</td>
          <td class="paramtype">const struct doca_devinfo *&#160;</td>
          <td class="paramname"><em>devinfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if a given device supports executing an atomic compare and swap task.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">devinfo</td><td>The DOCA device information that should be queried.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case device supports the task. Error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input.</li>
<li>DOCA_ERROR_NOT_SUPPORTED - provided devinfo does not support the task. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gac771f166c87b578dae6271da1a6e7893"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac771f166c87b578dae6271da1a6e7893">&#9670;&nbsp;</a></span>doca_rdma_cap_task_atomic_fetch_add_is_supported()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_rdma_cap_task_atomic_fetch_add_is_supported </td>
          <td>(</td>
          <td class="paramtype">const struct doca_devinfo *&#160;</td>
          <td class="paramname"><em>devinfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if a given device supports executing an atomic fetch and add task.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">devinfo</td><td>The DOCA device information that should be queried.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case device supports the task. Error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input.</li>
<li>DOCA_ERROR_NOT_SUPPORTED - provided devinfo does not support the task. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gae439f1dd47116a7b844b45a57bb4462e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae439f1dd47116a7b844b45a57bb4462e">&#9670;&nbsp;</a></span>doca_rdma_cap_task_read_is_supported()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_rdma_cap_task_read_is_supported </td>
          <td>(</td>
          <td class="paramtype">const struct doca_devinfo *&#160;</td>
          <td class="paramname"><em>devinfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if a given device supports executing a read task.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">devinfo</td><td>The DOCA device information that should be queried.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case device supports the task. Error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input.</li>
<li>DOCA_ERROR_NOT_SUPPORTED - provided devinfo does not support the task. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga3d6858ec036a6a5ffc5f24236cfa3d21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d6858ec036a6a5ffc5f24236cfa3d21">&#9670;&nbsp;</a></span>doca_rdma_cap_task_receive_get_max_dst_buf_list_len()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_rdma_cap_task_receive_get_max_dst_buf_list_len </td>
          <td>(</td>
          <td class="paramtype">const struct doca_devinfo *&#160;</td>
          <td class="paramname"><em>devinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__DOCA__RDMA.html#gaa5f02468536d7f851c155978d0867e3a">doca_rdma_transport_type</a>&#160;</td>
          <td class="paramname"><em>transport_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>max_buf_list_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the maximal buffer list length for a destination buffer of a receive task, for the given devinfo and transport type. </p><dl class="section note"><dt>Note</dt><dd>The actual limit depends on the property set for the task - either the default value or the value set using <a class="el" href="group__DOCA__RDMA.html#gaa747f37e09930ed68a42a3a2f0aec94a" title="Set the maximal destination buffer list length property for receive tasks. After starting the DOCA RD...">doca_rdma_task_receive_set_dst_buf_list_len()</a> prior to <a class="el" href="group__DOCA__CTX.html#ga712a2c32ab9113f568d08c379ec506f7" title="Finalizes all configurations, and starts the DOCA CTX.">doca_ctx_start()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">devinfo</td><td>The DOCA device information. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">transport_type</td><td>The relevant transport type. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">max_buf_list_len</td><td>The maximal number of local buffers that can be chained with a destination buffer of a receive task, for the given devinfo and transport type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input.</li>
<li>DOCA_ERROR_DRIVER - failed to query device capabilities. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gab2decae4b7b4b05eb41a76f87bc8e127"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab2decae4b7b4b05eb41a76f87bc8e127">&#9670;&nbsp;</a></span>doca_rdma_cap_task_receive_is_supported()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_rdma_cap_task_receive_is_supported </td>
          <td>(</td>
          <td class="paramtype">const struct doca_devinfo *&#160;</td>
          <td class="paramname"><em>devinfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if a given device supports executing a receive task.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">devinfo</td><td>The DOCA device information that should be queried.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case device supports the task. Error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input.</li>
<li>DOCA_ERROR_NOT_SUPPORTED - provided devinfo does not support the task. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaa4f885f228545c77680035689d275d30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa4f885f228545c77680035689d275d30">&#9670;&nbsp;</a></span>doca_rdma_cap_task_remote_net_sync_event_get_is_supported()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_rdma_cap_task_remote_net_sync_event_get_is_supported </td>
          <td>(</td>
          <td class="paramtype">const struct doca_devinfo *&#160;</td>
          <td class="paramname"><em>devinfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if a given device supports executing a remote_net_sync_event_get task.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">devinfo</td><td>The DOCA device information that should be queried.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case device supports the task. Error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input.</li>
<li>DOCA_ERROR_NOT_SUPPORTED - provided devinfo does not support the task. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaf268181319c323f622ae4d86e91d9b33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf268181319c323f622ae4d86e91d9b33">&#9670;&nbsp;</a></span>doca_rdma_cap_task_remote_net_sync_event_notify_add_is_supported()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_rdma_cap_task_remote_net_sync_event_notify_add_is_supported </td>
          <td>(</td>
          <td class="paramtype">const struct doca_devinfo *&#160;</td>
          <td class="paramname"><em>devinfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if a given device supports executing a remote_net_sync_event_notify_add task.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">devinfo</td><td>The DOCA device information that should be queried.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case device supports the task. Error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input.</li>
<li>DOCA_ERROR_NOT_SUPPORTED - provided devinfo does not support the task. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga3ce3b2d3d90038ba0174f4df36342ec8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ce3b2d3d90038ba0174f4df36342ec8">&#9670;&nbsp;</a></span>doca_rdma_cap_task_remote_net_sync_event_notify_set_is_supported()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_rdma_cap_task_remote_net_sync_event_notify_set_is_supported </td>
          <td>(</td>
          <td class="paramtype">const struct doca_devinfo *&#160;</td>
          <td class="paramname"><em>devinfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if a given device supports executing a remote_net_sync_event_notify_set task.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">devinfo</td><td>The DOCA device information that should be queried.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case device supports the task. Error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input.</li>
<li>DOCA_ERROR_NOT_SUPPORTED - provided devinfo does not support the task. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga91863c5ad3e9ed8ac9f37861bba6bc70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga91863c5ad3e9ed8ac9f37861bba6bc70">&#9670;&nbsp;</a></span>doca_rdma_cap_task_send_imm_is_supported()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_rdma_cap_task_send_imm_is_supported </td>
          <td>(</td>
          <td class="paramtype">const struct doca_devinfo *&#160;</td>
          <td class="paramname"><em>devinfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if a given device supports executing a send with immediate task.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">devinfo</td><td>The DOCA device information that should be queried.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case device supports the task. Error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input.</li>
<li>DOCA_ERROR_NOT_SUPPORTED - provided devinfo does not support the task. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaedee61ea26e87780c9e5121f40d68295"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaedee61ea26e87780c9e5121f40d68295">&#9670;&nbsp;</a></span>doca_rdma_cap_task_send_is_supported()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_rdma_cap_task_send_is_supported </td>
          <td>(</td>
          <td class="paramtype">const struct doca_devinfo *&#160;</td>
          <td class="paramname"><em>devinfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if a given device supports executing a send task.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">devinfo</td><td>The DOCA device information that should be queried.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case device supports the task. Error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input.</li>
<li>DOCA_ERROR_NOT_SUPPORTED - provided devinfo does not support the task. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga9a80bde253ccb3cf1269efbf35c877c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a80bde253ccb3cf1269efbf35c877c3">&#9670;&nbsp;</a></span>doca_rdma_cap_task_write_imm_is_supported()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_rdma_cap_task_write_imm_is_supported </td>
          <td>(</td>
          <td class="paramtype">const struct doca_devinfo *&#160;</td>
          <td class="paramname"><em>devinfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if a given device supports executing a write with immediate task.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">devinfo</td><td>The DOCA device information that should be queried.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case device supports the task. Error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input.</li>
<li>DOCA_ERROR_NOT_SUPPORTED - provided devinfo does not support the task. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gae20388328da0d158fd090161a474b683"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae20388328da0d158fd090161a474b683">&#9670;&nbsp;</a></span>doca_rdma_cap_task_write_is_supported()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_rdma_cap_task_write_is_supported </td>
          <td>(</td>
          <td class="paramtype">const struct doca_devinfo *&#160;</td>
          <td class="paramname"><em>devinfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if a given device supports executing a write task.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">devinfo</td><td>The DOCA device information that should be queried.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case device supports the task. Error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input.</li>
<li>DOCA_ERROR_NOT_SUPPORTED - provided devinfo does not support the task. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga27dd6f343702a7ec4e1c0d236d50d690"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga27dd6f343702a7ec4e1c0d236d50d690">&#9670;&nbsp;</a></span>doca_rdma_cap_transport_type_is_supported()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_rdma_cap_transport_type_is_supported </td>
          <td>(</td>
          <td class="paramtype">const struct doca_devinfo *&#160;</td>
          <td class="paramname"><em>devinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__DOCA__RDMA.html#gaa5f02468536d7f851c155978d0867e3a">doca_rdma_transport_type</a>&#160;</td>
          <td class="paramname"><em>transport_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if DOCA RDMA supports given transport type for a specific device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">devinfo</td><td>The DOCA device information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">transport_type</td><td>Transport type to query support for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case the transport type is supported. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input.</li>
<li>DOCA_ERROR_DRIVER - failed to query device capabilities</li>
<li>DOCA_ERROR_NOT_SUPPORTED - provided devinfo does not support the given transport type. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gae3b3eeb7682db1bbb5f8021c2302d60f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3b3eeb7682db1bbb5f8021c2302d60f">&#9670;&nbsp;</a></span>doca_rdma_connect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_rdma_connect </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma *&#160;</td>
          <td class="paramname"><em>rdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>remote_rdma_conn_details</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="____stddef__size__t_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a>&#160;</td>
          <td class="paramname"><em>remote_rdma_conn_details_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct doca_rdma_connection *&#160;</td>
          <td class="paramname"><em>rdma_connection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connect to remote doca_rdma peer. Can only be called when the ctx is in DOCA_CTX_STATE_STARTING state (after calling <a class="el" href="group__DOCA__CTX.html#ga712a2c32ab9113f568d08c379ec506f7" title="Finalizes all configurations, and starts the DOCA CTX.">doca_ctx_start()</a>). Once called, <a class="el" href="group__DOCA__PE.html#ga9a0e5d8d7a584dcc3db5c612875887cb" title="Run the progress engine.">doca_pe_progress()</a> should be called, in order to transition the ctx to DOCA_CTX_STATE_RUNNING state. Only after that can tasks be allocated and submitted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rdma</td><td>Pointer to doca_rdma to connect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remote_rdma_conn_details</td><td>Exported doca_rdma_conn_details object from remote peer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remote_rdma_conn_details_size</td><td>Size of remote doca_rdma_conn_details object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rdma_connection</td><td>Connection related data required for doca_rdma to connect.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - if any of the parameters is NULL.</li>
<li>DOCA_ERROR_BAD_STATE - if context was not started or rdma instance is already connected.</li>
<li>DOCA_ERROR_CONNECTION_ABORTED - if connection failed or connection details object was corrupted. </li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>stopping and restarting an RDMA context require calling <a class="el" href="group__DOCA__RDMA.html#gaa96c93d0552c0cc44891db06bc3c2080" title="Export doca_rdma connection details object The doca_rdma_conn_details are used in doca_rdma_connect()...">doca_rdma_export()</a> &amp; <a class="el" href="group__DOCA__RDMA.html#gae3b3eeb7682db1bbb5f8021c2302d60f" title="Connect to remote doca_rdma peer. Can only be called when the ctx is in DOCA_CTX_STATE_STARTING state...">doca_rdma_connect()</a> again. </dd></dl>

</div>
</div>
<a id="ga2581e0afb02e52a39424e01aa8690ab3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2581e0afb02e52a39424e01aa8690ab3">&#9670;&nbsp;</a></span>doca_rdma_connect_to_addr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_rdma_connect_to_addr </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma *&#160;</td>
          <td class="paramname"><em>rdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct doca_rdma_addr *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">union <a class="el" href="uniondoca__data.html">doca_data</a>&#160;</td>
          <td class="paramname"><em>connection_user_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connect to a remote doca_rdma peer listening for a connection. Can be called when the ctx is in DOCA_CTX_STATE_RUNNING state. Once called, <a class="el" href="group__DOCA__PE.html#ga9a0e5d8d7a584dcc3db5c612875887cb" title="Run the progress engine.">doca_pe_progress()</a> should be called, in order to evaluate connection response. Only after a connection is established can send tasks be allocated and submitted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rdma</td><td>Pointer to doca_rdma to connect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>Address to connect to listening for connection requests. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">connection_user_data</td><td>The <a class="el" href="uniondoca__data.html" title="Convenience type for representing opaque data.">doca_data</a> supplied to the connection by the application (during connection or by a setter).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_BAD_STATE - if context is in an invalid or error state.</li>
<li>DOCA_ERROR_INVALID_VALUE - if an invalid parameter was given.</li>
<li>DOCA_ERROR_NOT_SUPPORTED - if the current datapath is not supported.</li>
<li>DOCA_ERROR_CONNECTION_ABORTED - if connection failed or connection details object was corrupted. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gad0cc463915d3e20f38e29d3a14384e4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad0cc463915d3e20f38e29d3a14384e4e">&#9670;&nbsp;</a></span>doca_rdma_connection_accept()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_rdma_connection_accept </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma_connection *&#160;</td>
          <td class="paramname"><em>rdma_connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>private_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>private_data_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accept an incoming connection request from remote doca_rdma peer. Can be called when the ctx is in DOCA_CTX_STATE_RUNNING state. Only after a connection is established can send tasks be allocated and submitted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rdma_connection</td><td>Connection related data required for doca_rdma to connect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">private_data</td><td>The RDMA connection private data to be sent in RDMA CM ACCEPT. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If private data is not needed then this argument should be NULL </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">private_data_len</td><td>The RDMA connection size of the private data that is sent in RDMA CM ACCEPT. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If private data is not needed then this argument should be 0</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - if an invalid parameter was given.</li>
<li>DOCA_ERROR_CONNECTION_ABORTED - if connection failed or connection details object was corrupted.</li>
<li>DOCA_ERROR_NO_MEMORY - failed to allocate resources. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gab10ceeeb6ede67a759bba4b49dbeca98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab10ceeeb6ede67a759bba4b49dbeca98">&#9670;&nbsp;</a></span>doca_rdma_connection_disconnect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_rdma_connection_disconnect </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma_connection *&#160;</td>
          <td class="paramname"><em>rdma_connection</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalize a connection with a remote doca_rdma peer. Can be called when the ctx is in DOCA_CTX_STATE_RUNNING state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rdma_connection</td><td>Connection related data required for doca_rdma to connect.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - if an invalid parameter was given.</li>
<li>DOCA_ERROR_CONNECTION_ABORTED - if connection failed or connection details object was corrupted. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga3be468cbf62683acfe30eac98f334aca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3be468cbf62683acfe30eac98f334aca">&#9670;&nbsp;</a></span>doca_rdma_connection_get_addr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_rdma_connection_get_addr </td>
          <td>(</td>
          <td class="paramtype">const struct doca_rdma_connection *&#160;</td>
          <td class="paramname"><em>rdma_connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct doca_rdma_addr **&#160;</td>
          <td class="paramname"><em>addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get connection address object from a doca_rdma_connection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rdma_connection</td><td>Connection related data required for doca_rdma to connect. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">addr</td><td>A pointer to the address object used for this connection.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - if an invalid parameter was given. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga74f2ef227b9ed3db6defec06452d6e04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga74f2ef227b9ed3db6defec06452d6e04">&#9670;&nbsp;</a></span>doca_rdma_connection_get_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_rdma_connection_get_id </td>
          <td>(</td>
          <td class="paramtype">const struct doca_rdma_connection *&#160;</td>
          <td class="paramname"><em>rdma_connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>connection_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get connection ID from an rdma connection. </p>
<p>This method retrieves connection ID from an rdma connection object</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rdma_connection</td><td>The connection to get the property from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">connection_id</td><td>The connection ID</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - if an invalid parameter was given. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga32aa8a402e52a2e01af8e82393ab6c63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga32aa8a402e52a2e01af8e82393ab6c63">&#9670;&nbsp;</a></span>doca_rdma_connection_get_user_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_rdma_connection_get_user_data </td>
          <td>(</td>
          <td class="paramtype">const struct doca_rdma_connection *&#160;</td>
          <td class="paramname"><em>rdma_connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">union <a class="el" href="uniondoca__data.html">doca_data</a> *&#160;</td>
          <td class="paramname"><em>connection_user_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get user data included in a connection. </p>
<p>This method retrieves connection user data from a rdma connection (previously set using doca_rdma_connection_set_user_data).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rdma_connection</td><td>Connection related data required for doca_rdma to connect. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">connection_user_data</td><td>Connection user data to get</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - if an invalid parameter was given. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gac3bf9df47bd832b381a44cfe2a83bc46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac3bf9df47bd832b381a44cfe2a83bc46">&#9670;&nbsp;</a></span>doca_rdma_connection_reject()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_rdma_connection_reject </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma_connection *&#160;</td>
          <td class="paramname"><em>rdma_connection</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reject an incoming connection request from remote doca_rdma peer. Can be called when the ctx is in DOCA_CTX_STATE_RUNNING state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rdma_connection</td><td>Connection related data required for doca_rdma to connect.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - if an invalid parameter was given.</li>
<li>DOCA_ERROR_CONNECTION_ABORTED - if connection failed or connection details object was corrupted. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaf5aac5afb092f77ee296b9ddf25ca8d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf5aac5afb092f77ee296b9ddf25ca8d2">&#9670;&nbsp;</a></span>doca_rdma_connection_set_user_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_rdma_connection_set_user_data </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma_connection *&#160;</td>
          <td class="paramname"><em>rdma_connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">union <a class="el" href="uniondoca__data.html">doca_data</a>&#160;</td>
          <td class="paramname"><em>connection_user_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set user data to include in each connection. </p>
<p>This method sets a connection user data to a context. The connection user data will be returned as a parameter to connection state callbacks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rdma_connection</td><td>Connection related data required for doca_rdma to connect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">connection_user_data</td><td><a class="el" href="uniondoca__data.html" title="Convenience type for representing opaque data.">doca_data</a> to attach to the connection.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - if property set successfully. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - if an invalid parameter was given. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gae83132a3cc3fdd30a76dabf11c975eef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae83132a3cc3fdd30a76dabf11c975eef">&#9670;&nbsp;</a></span>doca_rdma_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_rdma_create </td>
          <td>(</td>
          <td class="paramtype">struct doca_dev *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct doca_rdma **&#160;</td>
          <td class="paramname"><em>rdma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a DOCA RDMA instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>The device to attach to the RDMA instance. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rdma</td><td>Pointer to pointer to be set to point to the created doca_rdma instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - rdma argument is a NULL pointer.</li>
<li>DOCA_ERROR_NO_MEMORY - failed to allocate resources.</li>
<li>DOCA_ERROR_INITIALIZATION - failed to initialize rdma. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga240e41c4dff9525db19b8db498489e38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga240e41c4dff9525db19b8db498489e38">&#9670;&nbsp;</a></span>doca_rdma_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_rdma_destroy </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma *&#160;</td>
          <td class="paramname"><em>rdma</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a DOCA RDMA instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rdma</td><td>Pointer to instance to be destroyed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - rdma argument is a NULL pointer.</li>
<li>DOCA_ERROR_BAD_STATE - the associated ctx was not stopped before calling <a class="el" href="group__DOCA__RDMA.html#ga240e41c4dff9525db19b8db498489e38" title="Destroy a DOCA RDMA instance.">doca_rdma_destroy()</a>. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga2b77d1227d304b3a4af75a450a0503d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b77d1227d304b3a4af75a450a0503d5">&#9670;&nbsp;</a></span>doca_rdma_dpa_completion_attach()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_rdma_dpa_completion_attach </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma *&#160;</td>
          <td class="paramname"><em>rdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct doca_dpa_completion *&#160;</td>
          <td class="paramname"><em>dpa_comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attach DOCA RDMA to DPA completion context. </p>
<p>This function must be called before DOCA RDMA context is started</p>
<dl class="section note"><dt>Note</dt><dd>This API is relevant only for contexts that are set on DPA datapath, using <a class="el" href="group__DOCA__CTX.html#ga97ab788bd67b8bf008eb6d67d9600923" title="This function binds the DOCA context to a dpa device.">doca_ctx_set_datapath_on_dpa()</a> before calling <a class="el" href="group__DOCA__CTX.html#ga712a2c32ab9113f568d08c379ec506f7" title="Finalizes all configurations, and starts the DOCA CTX.">doca_ctx_start()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rdma</td><td>doca_rdma context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dpa_comp</td><td>DPA completion context</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input.</li>
<li>DOCA_ERROR_BAD_STATE - if context is already started. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaa96c93d0552c0cc44891db06bc3c2080"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa96c93d0552c0cc44891db06bc3c2080">&#9670;&nbsp;</a></span>doca_rdma_export()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_rdma_export </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma *&#160;</td>
          <td class="paramname"><em>rdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void **&#160;</td>
          <td class="paramname"><em>local_rdma_conn_details</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="____stddef__size__t_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a> *&#160;</td>
          <td class="paramname"><em>local_rdma_conn_details_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct doca_rdma_connection **&#160;</td>
          <td class="paramname"><em>rdma_connection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Export doca_rdma connection details object The doca_rdma_conn_details are used in <a class="el" href="group__DOCA__RDMA.html#gae3b3eeb7682db1bbb5f8021c2302d60f" title="Connect to remote doca_rdma peer. Can only be called when the ctx is in DOCA_CTX_STATE_STARTING state...">doca_rdma_connect()</a>. Can only be called after calling <a class="el" href="group__DOCA__CTX.html#ga712a2c32ab9113f568d08c379ec506f7" title="Finalizes all configurations, and starts the DOCA CTX.">doca_ctx_start()</a>. </p>
<dl class="section note"><dt>Note</dt><dd>The exported data contains sensitive information - please make sure to pass this data through a secure channel</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rdma</td><td>Pointer doca_rdma to export connection details for. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">local_rdma_conn_details</td><td>Exported doca_rdma_conn_details object. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">local_rdma_conn_details_size</td><td>Size of exported doca_rdma_conn_details object. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rdma_connection</td><td>Connection related data required for doca_rdma to connect.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - if any of the parameters is NULL.</li>
<li>DOCA_ERROR_BAD_STATE - if called before calling ctx_start().</li>
<li>DOCA_ERROR_CONNECTION_ABORTED - if connection failed or connection details object was corrupted.</li>
<li>DOCA_ERROR_FULL - if all connections are being used. </li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>stopping and restarting an RDMA context require calling <a class="el" href="group__DOCA__RDMA.html#gaa96c93d0552c0cc44891db06bc3c2080" title="Export doca_rdma connection details object The doca_rdma_conn_details are used in doca_rdma_connect()...">doca_rdma_export()</a> &amp; <a class="el" href="group__DOCA__RDMA.html#gae3b3eeb7682db1bbb5f8021c2302d60f" title="Connect to remote doca_rdma peer. Can only be called when the ctx is in DOCA_CTX_STATE_STARTING state...">doca_rdma_connect()</a> again. </dd></dl>

</div>
</div>
<a id="ga8415240f5ee1d07c37c0f646b2c01a57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8415240f5ee1d07c37c0f646b2c01a57">&#9670;&nbsp;</a></span>doca_rdma_get_connection_request_timeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_rdma_get_connection_request_timeout </td>
          <td>(</td>
          <td class="paramtype">const struct doca_rdma *&#160;</td>
          <td class="paramname"><em>rdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get timeout property for doca_rdma. Returns the current timeout set for the connection resolve related functions. The size returned is the actual size being used and might differ from the size set by the user, as the size may be increased. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rdma</td><td>doca_rdma context to set the property for. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">timeout</td><td>Timeout value (in milliseconds) to use in context for connection.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - if an invalid parameter was given. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga702e1059ea42fa21f5e85cc23fd0a898"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga702e1059ea42fa21f5e85cc23fd0a898">&#9670;&nbsp;</a></span>doca_rdma_get_dpa_handle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_rdma_get_dpa_handle </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma *&#160;</td>
          <td class="paramname"><em>rdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DOCA__RDMA.html#gadb533b1f5e0b511e7eec6d74e738193b">doca_dpa_dev_rdma_t</a> *&#160;</td>
          <td class="paramname"><em>dpa_rdma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the handle in the dpa memory space of a doca_rdma. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rdma</td><td>doca_rdma context to get the dpa handle from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dpa_rdma</td><td>A pointer to the handle in the dpa memory space.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - if an invalid parameter was given.</li>
<li>DOCA_ERROR_BAD_STATE - if called before calling ctx_start(), or if not assigned to dpa datapath. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga838585b7adf5dc400909b5f698546428"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga838585b7adf5dc400909b5f698546428">&#9670;&nbsp;</a></span>doca_rdma_get_gid_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_rdma_get_gid_index </td>
          <td>(</td>
          <td class="paramtype">const struct doca_rdma *&#160;</td>
          <td class="paramname"><em>rdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>gid_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get GID index from doca_rdma. Get the current GID index set for doca_rdma. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rdma</td><td>doca_rdma context to get the property from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">gid_index</td><td>GID index used in doca_rdma.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - if property retrieved successfully. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - if an invalid parameter was given. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga07ff3c69e9c92bcbc828c241681c53d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga07ff3c69e9c92bcbc828c241681c53d4">&#9670;&nbsp;</a></span>doca_rdma_get_gpu_handle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_rdma_get_gpu_handle </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma *&#160;</td>
          <td class="paramname"><em>rdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct doca_gpu_dev_rdma **&#160;</td>
          <td class="paramname"><em>gpu_rdma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the handle in the gpu memory space of a doca_rdma. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rdma</td><td>doca_rdma context to get the gpu handle from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">gpu_rdma</td><td>A pointer to the handle in the gpu memory space.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - if an invalid parameter was given.</li>
<li>DOCA_ERROR_BAD_STATE - if called before calling ctx_start(), or if not assigned to gpu datapath. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga98e4c3bb034bb42de53144ed14fe8f34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga98e4c3bb034bb42de53144ed14fe8f34">&#9670;&nbsp;</a></span>doca_rdma_get_grh_enabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_rdma_get_grh_enabled </td>
          <td>(</td>
          <td class="paramtype">const struct doca_rdma *&#160;</td>
          <td class="paramname"><em>rdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>grh_enabled</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get GRH setting from doca_rdma. Get the current GRH setting for doca_rdma. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rdma</td><td>doca_rdma context to get the property from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">grh_enabled</td><td>1 if GRH setting was used in doca_rdma, 0 otherwise.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - if property retrieved successfully. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - if an invalid parameter was given. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga75340a49b88e149c75e0cdbc0cfc60df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga75340a49b88e149c75e0cdbc0cfc60df">&#9670;&nbsp;</a></span>doca_rdma_get_max_num_connections()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_rdma_get_max_num_connections </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma *&#160;</td>
          <td class="paramname"><em>rdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>max_num_connections</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get maximum number of connections property for doca_rdma. Returns the current maximum number of connections set for a context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rdma</td><td>doca_rdma context to get the property from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">max_num_connections</td><td>The maximum amount of connections allowed in this context.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - if an invalid parameter was given. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gad7948de5b8a3439c14324cf74be37543"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad7948de5b8a3439c14324cf74be37543">&#9670;&nbsp;</a></span>doca_rdma_get_max_send_buf_list_len()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_rdma_get_max_send_buf_list_len </td>
          <td>(</td>
          <td class="paramtype">const struct doca_rdma *&#160;</td>
          <td class="paramname"><em>rdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>max_send_buf_list_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the maximum buffer list length property for local buffers of tasks that are sent to the remote and in which linked list are supported (i.e. send, send_imm, read, write, write_imm). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rdma</td><td>The RDMA instance to get the property from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">max_send_buf_list_len</td><td>Maximum buffer list length to used for local buffer in relevant tasks.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - if property retrieved successfully. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - if an invalid parameter was given. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gafa926095c2fb3d94a86e6739ae8648d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa926095c2fb3d94a86e6739ae8648d1">&#9670;&nbsp;</a></span>doca_rdma_get_mtu()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_rdma_get_mtu </td>
          <td>(</td>
          <td class="paramtype">const struct doca_rdma *&#160;</td>
          <td class="paramname"><em>rdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__DOCA__TYPES.html#ga7925ef067096a2bb0fe8d1c997574ce7">doca_mtu_size</a> *&#160;</td>
          <td class="paramname"><em>mtu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the MTU property from doca_rdma. Returns the current MTU set for the doca_rdma context. </p>
<dl class="section note"><dt>Note</dt><dd>If MTU wasn't set by the user explicitly (and a default value was used), it may changed upon connection.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rdma</td><td>doca_rdma context to get the property from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mtu</td><td>MTU set in context.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - if property retrieved successfully. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - if an invalid parameter was given. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gac5c4dec7e158362dc20a7e0e04f67508"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5c4dec7e158362dc20a7e0e04f67508">&#9670;&nbsp;</a></span>doca_rdma_get_permissions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_rdma_get_permissions </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma *&#160;</td>
          <td class="paramname"><em>rdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>permissions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get permissions property from doca_rdma. Returns the current permissions set for the doca_rdma_context. Can only be called after calling doca_ctx_dev_add(). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rdma</td><td>doca_rdma context to get the property from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">permissions</td><td>Bitwise combination of RDMA access flags set in context - see enum doca_access_flag</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - if property retrieved successfully. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - if an invalid parameter was given. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gabff1b72c434f7faabfe8dcb1a6dc4950"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabff1b72c434f7faabfe8dcb1a6dc4950">&#9670;&nbsp;</a></span>doca_rdma_get_recv_queue_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_rdma_get_recv_queue_size </td>
          <td>(</td>
          <td class="paramtype">const struct doca_rdma *&#160;</td>
          <td class="paramname"><em>rdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>recv_queue_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get recv queue size property from doca_rdma. Returns the current recv_queue_size set for the doca_rdma_context. The size returned is the actual size being used and might differ from the size set by the user, as the size may be increased. </p>
<dl class="section note"><dt>Note</dt><dd>This property affects only GPU data-path and DPA data-path when SRQ is used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rdma</td><td>doca_rdma context to get the property from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">recv_queue_size</td><td>Recv queue size set in context.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - if property retrieved successfully. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - if an invalid parameter was given.</li>
<li>DOCA_ERROR_NOT_SUPPORTED - if the given RDMA was created with SRQ or on CPU data-path.</li>
<li>DOCA_ERROR_BAD_STATE - if context is already started. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaa6ced2e55dd626d11adb045b21edefe6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa6ced2e55dd626d11adb045b21edefe6">&#9670;&nbsp;</a></span>doca_rdma_get_rnr_retry_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_rdma_get_rnr_retry_count </td>
          <td>(</td>
          <td class="paramtype">const struct doca_rdma *&#160;</td>
          <td class="paramname"><em>rdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>rnr_retry_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get rnr retry count property for doca_rdma. Returns the current rnr retry count set for a context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rdma</td><td>doca_rdma context to get the property from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rnr_retry_count</td><td>rnr retry count used in doca_rdma.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - if an invalid parameter was given. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaaa4f70d8e186af9ea2d5d77eccd50489"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa4f70d8e186af9ea2d5d77eccd50489">&#9670;&nbsp;</a></span>doca_rdma_get_send_queue_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_rdma_get_send_queue_size </td>
          <td>(</td>
          <td class="paramtype">const struct doca_rdma *&#160;</td>
          <td class="paramname"><em>rdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>send_queue_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get send queue size property from doca_rdma. Returns the current send_queue_size set for the doca_rdma_context. The size returned is the actual size being used and might differ from the size set by the user, as the size may be increased. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rdma</td><td>doca_rdma context to get the property from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">send_queue_size</td><td>Send queue size set in context.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - if property retrieved successfully. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - if an invalid parameter was given. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga68a6dc4d7352c6e4aa15ce5f26739643"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga68a6dc4d7352c6e4aa15ce5f26739643">&#9670;&nbsp;</a></span>doca_rdma_get_sl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_rdma_get_sl </td>
          <td>(</td>
          <td class="paramtype">const struct doca_rdma *&#160;</td>
          <td class="paramname"><em>rdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>sl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get SL (service level) from doca_rdma. Get the current SL set for doca_rdma. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rdma</td><td>doca_rdma context to get the property from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sl</td><td>SL used in doca_rdma.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - if property retrieved successfully. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - if an invalid parameter was given. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga646f0f2f92433782190715b8d58e83b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga646f0f2f92433782190715b8d58e83b9">&#9670;&nbsp;</a></span>doca_rdma_get_transport_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_rdma_get_transport_type </td>
          <td>(</td>
          <td class="paramtype">const struct doca_rdma *&#160;</td>
          <td class="paramname"><em>rdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__DOCA__RDMA.html#gaa5f02468536d7f851c155978d0867e3a">doca_rdma_transport_type</a> *&#160;</td>
          <td class="paramname"><em>transport_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get transport_type property from doca_rdma. Returns the current transport_type set for the doca_rdma_context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rdma</td><td>doca_rdma context to get the property from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">transport_type</td><td>Transport_type set in context.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - if property retrieved successfully. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - if an invalid parameter was given. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga5b399e2fe0befea3621fed7296b5cc26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b399e2fe0befea3621fed7296b5cc26">&#9670;&nbsp;</a></span>doca_rdma_set_connection_request_timeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_rdma_set_connection_request_timeout </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma *&#160;</td>
          <td class="paramname"><em>rdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set timeout property for doca_rdma. The value can be queried using <a class="el" href="group__DOCA__RDMA.html#ga8415240f5ee1d07c37c0f646b2c01a57" title="Get timeout property for doca_rdma. Returns the current timeout set for the connection resolve relate...">doca_rdma_get_connection_request_timeout()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rdma</td><td>doca_rdma context to set the property for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>The timeout (in milliseconds) to be used for connection resolve related functions.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - if property set successfully. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - if an invalid parameter was given.</li>
<li>DOCA_ERROR_BAD_STATE - if context is already started. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga42e9eeda69f029219b0f1644e0a778a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga42e9eeda69f029219b0f1644e0a778a0">&#9670;&nbsp;</a></span>doca_rdma_set_connection_state_callbacks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_rdma_set_connection_state_callbacks </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma *&#160;</td>
          <td class="paramname"><em>rdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DOCA__RDMA.html#ga32d1ed957b273e7c459a8d0f71dded3f">doca_rdma_connection_request_cb_t</a>&#160;</td>
          <td class="paramname"><em>doca_rdma_connect_request_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DOCA__RDMA.html#gac64a10cc83ec29159975883df89b9507">doca_rdma_connection_established_cb_t</a>&#160;</td>
          <td class="paramname"><em>doca_rdma_connect_established_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DOCA__RDMA.html#ga759d54b2fef283bc8f92c2ae29187fce">doca_rdma_connection_failure_cb_t</a>&#160;</td>
          <td class="paramname"><em>doca_rdma_connect_failure_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DOCA__RDMA.html#ga5c9391e450ddc64b3d26700a26dedba7">doca_rdma_connection_disconnection_cb_t</a>&#160;</td>
          <td class="paramname"><em>doca_rdma_disconnect_cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method set the function executed on RDMA connection events. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rdma</td><td>The RDMA instance to config. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">doca_rdma_connect_request_cb</td><td>A callback function for connection request event. This parameter can be NULL in case application is only a client </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">doca_rdma_connect_established_cb</td><td>A callback function for connection established event. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">doca_rdma_connect_failure_cb</td><td>A callback function for connection failure event. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">doca_rdma_disconnect_cb</td><td>A callback function for connection disconnection event.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gab9eb5eec4881e86a12fe3fadf6016999"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab9eb5eec4881e86a12fe3fadf6016999">&#9670;&nbsp;</a></span>doca_rdma_set_gid_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_rdma_set_gid_index </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma *&#160;</td>
          <td class="paramname"><em>rdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>gid_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set GID index for doca_rdma. The value can be queried using <a class="el" href="group__DOCA__RDMA.html#ga838585b7adf5dc400909b5f698546428" title="Get GID index from doca_rdma. Get the current GID index set for doca_rdma.">doca_rdma_get_gid_index()</a>. Can only be called before calling <a class="el" href="group__DOCA__CTX.html#ga712a2c32ab9113f568d08c379ec506f7" title="Finalizes all configurations, and starts the DOCA CTX.">doca_ctx_start()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rdma</td><td>doca_rdma context to set the property for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gid_index</td><td>GID index to use in doca_rdma.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - if property set successfully. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - if an invalid parameter was given.</li>
<li>DOCA_ERROR_BAD_STATE - if context is already started. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga39d089dd17b4eb892f3941bd95f27790"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga39d089dd17b4eb892f3941bd95f27790">&#9670;&nbsp;</a></span>doca_rdma_set_grh_enabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_rdma_set_grh_enabled </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma *&#160;</td>
          <td class="paramname"><em>rdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>grh_enabled</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set whether to use GRH in connection. The value can be queried using <a class="el" href="group__DOCA__RDMA.html#ga98e4c3bb034bb42de53144ed14fe8f34" title="Get GRH setting from doca_rdma. Get the current GRH setting for doca_rdma.">doca_rdma_get_grh_enabled()</a>. Can only be called before calling <a class="el" href="group__DOCA__CTX.html#ga712a2c32ab9113f568d08c379ec506f7" title="Finalizes all configurations, and starts the DOCA CTX.">doca_ctx_start()</a>. </p>
<p>If using IB device: If GRH is disabled, the address will rely on LID only. If GRH is enabled, the other side must also use GRH.</p>
<p>If using ETH device, GRH must be enabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rdma</td><td>doca_rdma context to set the property for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">grh_enabled</td><td>1 if GRH is used in doca_rdma, 0 otherwise.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - if property set successfully. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - if an invalid parameter was given.</li>
<li>DOCA_ERROR_BAD_STATE - if context is already started.</li>
<li>DOCA_ERROR_NOT_SUPPORTED - if GRH setting is not supported for the device. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaa16a128957eeff1f9947cc294171d0a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa16a128957eeff1f9947cc294171d0a2">&#9670;&nbsp;</a></span>doca_rdma_set_max_num_connections()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_rdma_set_max_num_connections </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma *&#160;</td>
          <td class="paramname"><em>rdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>max_num_connections</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the maximum number of connections property for a context. The value can be queried using <a class="el" href="group__DOCA__RDMA.html#ga75340a49b88e149c75e0cdbc0cfc60df" title="Get maximum number of connections property for doca_rdma. Returns the current maximum number of conne...">doca_rdma_get_max_num_connections()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rdma</td><td>doca_rdma context to set the property for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_num_connections</td><td>The maximum amount of connections allowed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - if property set successfully. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - if an invalid parameter was given.</li>
<li>DOCA_ERROR_NOT_SUPPORTED - provided max_num_connections is smaller than minimum value supported.</li>
<li>DOCA_ERROR_BAD_STATE - if context is already started. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gafdc92935ee7fad23891df4213341fc04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafdc92935ee7fad23891df4213341fc04">&#9670;&nbsp;</a></span>doca_rdma_set_max_send_buf_list_len()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_rdma_set_max_send_buf_list_len </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma *&#160;</td>
          <td class="paramname"><em>rdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_send_buf_list_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the maximum buffer list length property for local buffers of tasks that are sent to the remote and in which linked list are supported (i.e. send, send_imm, read, write, write_imm). The value in use can be queried using <a class="el" href="group__DOCA__RDMA.html#gad7948de5b8a3439c14324cf74be37543" title="Get the maximum buffer list length property for local buffers of tasks that are sent to the remote an...">doca_rdma_get_max_send_buf_list_len()</a>. </p>
<dl class="section note"><dt>Note</dt><dd>Can only be called before calling <a class="el" href="group__DOCA__CTX.html#ga712a2c32ab9113f568d08c379ec506f7" title="Finalizes all configurations, and starts the DOCA CTX.">doca_ctx_start()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rdma</td><td>The RDMA instance to set the property for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_send_buf_list_len</td><td>Maximum buffer list length to use for local buffer in relevant tasks.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - if property set successfully. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - if an invalid parameter was given.</li>
<li>DOCA_ERROR_BAD_STATE - if context is already started. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga8210867a75ae9e2c13064a6d8ee6c919"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8210867a75ae9e2c13064a6d8ee6c919">&#9670;&nbsp;</a></span>doca_rdma_set_mtu()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_rdma_set_mtu </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma *&#160;</td>
          <td class="paramname"><em>rdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__DOCA__TYPES.html#ga7925ef067096a2bb0fe8d1c997574ce7">doca_mtu_size</a>&#160;</td>
          <td class="paramname"><em>mtu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set MTU for doca_rdma. The value can be queried using <a class="el" href="group__DOCA__RDMA.html#gafa926095c2fb3d94a86e6739ae8648d1" title="Get the MTU property from doca_rdma. Returns the current MTU set for the doca_rdma context.">doca_rdma_get_mtu()</a>. Can only be called before calling <a class="el" href="group__DOCA__CTX.html#ga712a2c32ab9113f568d08c379ec506f7" title="Finalizes all configurations, and starts the DOCA CTX.">doca_ctx_start()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rdma</td><td>doca_rdma context to set the property for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mtu</td><td>MTU to use in context.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - if property set successfully. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - if an invalid parameter was given.</li>
<li>DOCA_ERROR_NOT_SUPPORTED - if the given MTU is not supported.</li>
<li>DOCA_ERROR_BAD_STATE - if context is already started.</li>
<li>DOCA_ERROR_UNEXPECTED - if an unexpected error has occurred. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga477ad6d95232d3805cb561ae1fe42ae7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga477ad6d95232d3805cb561ae1fe42ae7">&#9670;&nbsp;</a></span>doca_rdma_set_permissions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_rdma_set_permissions </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma *&#160;</td>
          <td class="paramname"><em>rdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>permissions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set rdma permissions for doca_rdma. The value can be queried using <a class="el" href="group__DOCA__RDMA.html#gac5c4dec7e158362dc20a7e0e04f67508" title="Get permissions property from doca_rdma. Returns the current permissions set for the doca_rdma_contex...">doca_rdma_get_permissions()</a>. Can only be called after calling doca_ctx_dev_add() and before calling <a class="el" href="group__DOCA__CTX.html#ga712a2c32ab9113f568d08c379ec506f7" title="Finalizes all configurations, and starts the DOCA CTX.">doca_ctx_start()</a>. The supported permissions are the RDMA access flags. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rdma</td><td>doca_rdma context to set the property for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">permissions</td><td>Bitwise combination of RDMA access flags - see enum doca_access_flag</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - if property set successfully. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - if an invalid parameter was given or non-RDMA access flags were given.</li>
<li>DOCA_ERROR_BAD_STATE - if context is already started. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga7acffe08c179eb43c5bd65c7dbaeeafb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7acffe08c179eb43c5bd65c7dbaeeafb">&#9670;&nbsp;</a></span>doca_rdma_set_recv_queue_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_rdma_set_recv_queue_size </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma *&#160;</td>
          <td class="paramname"><em>rdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>recv_queue_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set recv queue size property for doca_rdma. The value can be queried using <a class="el" href="group__DOCA__RDMA.html#gabff1b72c434f7faabfe8dcb1a6dc4950" title="Get recv queue size property from doca_rdma. Returns the current recv_queue_size set for the doca_rdm...">doca_rdma_get_recv_queue_size()</a>. Queue size will be rounded to the next power of 2. </p>
<dl class="section note"><dt>Note</dt><dd>Can only be called before calling <a class="el" href="group__DOCA__CTX.html#ga712a2c32ab9113f568d08c379ec506f7" title="Finalizes all configurations, and starts the DOCA CTX.">doca_ctx_start()</a>. </dd>
<dd>
This property affects only GPU data-path and DPA data-path when SRQ used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rdma</td><td>doca_rdma context to set the property for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">recv_queue_size</td><td>Recv queue size to use in context.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - if property set successfully. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - if an invalid parameter was given.</li>
<li>DOCA_ERROR_NOT_SUPPORTED - if the given size is not supported or the given RDMA was created with SRQ or on CPU data-path.</li>
<li>DOCA_ERROR_BAD_STATE - if context is already started. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga997557391be9a742645d277a9e199129"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga997557391be9a742645d277a9e199129">&#9670;&nbsp;</a></span>doca_rdma_set_rnr_retry_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_rdma_set_rnr_retry_count </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma *&#160;</td>
          <td class="paramname"><em>rdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>rnr_retry_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the rnr retry count property for a context. The value can be queried using <a class="el" href="group__DOCA__RDMA.html#gaa6ced2e55dd626d11adb045b21edefe6" title="Get rnr retry count property for doca_rdma. Returns the current rnr retry count set for a context.">doca_rdma_get_rnr_retry_count()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rdma</td><td>doca_rdma context to set the property for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rnr_retry_count</td><td>rnr retry count index to use in doca_rdma.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - if property set successfully. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - if an invalid parameter was given.</li>
<li>DOCA_ERROR_NOT_SUPPORTED - provided max_num_connections is smaller than minimum value supported.</li>
<li>DOCA_ERROR_BAD_STATE - if context is already started. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga6b575af5ebdf6da3b0677530325cf635"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b575af5ebdf6da3b0677530325cf635">&#9670;&nbsp;</a></span>doca_rdma_set_send_queue_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_rdma_set_send_queue_size </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma *&#160;</td>
          <td class="paramname"><em>rdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>send_queue_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set send queue size property for doca_rdma. The value can be queried using <a class="el" href="group__DOCA__RDMA.html#gaaa4f70d8e186af9ea2d5d77eccd50489" title="Get send queue size property from doca_rdma. Returns the current send_queue_size set for the doca_rdm...">doca_rdma_get_send_queue_size()</a>. Queue size will be rounded to the next power of 2. can only be called before calling <a class="el" href="group__DOCA__CTX.html#ga712a2c32ab9113f568d08c379ec506f7" title="Finalizes all configurations, and starts the DOCA CTX.">doca_ctx_start()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rdma</td><td>doca_rdma context to set the property for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">send_queue_size</td><td>Send queue size to use in context.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - if property set successfully. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - if an invalid parameter was given.</li>
<li>DOCA_ERROR_NOT_SUPPORTED - if the given size is not supported.</li>
<li>DOCA_ERROR_BAD_STATE - if context is already started. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga82689512c344c7e2cc2c6a38f6ea124d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga82689512c344c7e2cc2c6a38f6ea124d">&#9670;&nbsp;</a></span>doca_rdma_set_sl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_rdma_set_sl </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma *&#160;</td>
          <td class="paramname"><em>rdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>sl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set SL (service level) for doca_rdma. The value can be queried using <a class="el" href="group__DOCA__RDMA.html#ga68a6dc4d7352c6e4aa15ce5f26739643" title="Get SL (service level) from doca_rdma. Get the current SL set for doca_rdma.">doca_rdma_get_sl()</a>. Can only be called before calling <a class="el" href="group__DOCA__CTX.html#ga712a2c32ab9113f568d08c379ec506f7" title="Finalizes all configurations, and starts the DOCA CTX.">doca_ctx_start()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rdma</td><td>doca_rdma context to set the property for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sl</td><td>SL to use in doca_rdma.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - if property set successfully. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - if an invalid parameter was given.</li>
<li>DOCA_ERROR_BAD_STATE - if context is already started. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga0665af3556845088dcc39452d9aebd9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0665af3556845088dcc39452d9aebd9f">&#9670;&nbsp;</a></span>doca_rdma_set_transport_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_rdma_set_transport_type </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma *&#160;</td>
          <td class="paramname"><em>rdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__DOCA__RDMA.html#gaa5f02468536d7f851c155978d0867e3a">doca_rdma_transport_type</a>&#160;</td>
          <td class="paramname"><em>transport_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set transport type for doca_rdma. The value can be queried using <a class="el" href="group__DOCA__RDMA.html#ga646f0f2f92433782190715b8d58e83b9" title="Get transport_type property from doca_rdma. Returns the current transport_type set for the doca_rdma_...">doca_rdma_get_transport_type()</a>. Can only be called before calling <a class="el" href="group__DOCA__CTX.html#ga712a2c32ab9113f568d08c379ec506f7" title="Finalizes all configurations, and starts the DOCA CTX.">doca_ctx_start()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rdma</td><td>doca_rdma context to set the property for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">transport_type</td><td>Transport type to use in context.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - if property set successfully. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - if an invalid parameter was given.</li>
<li>DOCA_ERROR_NOT_SUPPORTED - if the given transport type is not supported.</li>
<li>DOCA_ERROR_BAD_STATE - if context is already started. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaaa98248c59713a75b205ac90ac2ad2a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa98248c59713a75b205ac90ac2ad2a8">&#9670;&nbsp;</a></span>doca_rdma_start_listen_to_port()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_rdma_start_listen_to_port </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma *&#160;</td>
          <td class="paramname"><em>rdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start listening for a connection from a remote doca_rdma peer. Can be called when the ctx is in DOCA_CTX_STATE_RUNNING state. Once called, <a class="el" href="group__DOCA__PE.html#ga9a0e5d8d7a584dcc3db5c612875887cb" title="Run the progress engine.">doca_pe_progress()</a> should be called, in order to evaluate possible connections requests. Only after a connection is established can send tasks be allocated and submitted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rdma</td><td>Pointer to doca_rdma to connect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">port</td><td>Port to listen to for connection requests.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - if an invalid parameter was given.</li>
<li>DOCA_ERROR_BAD_STATE - if context is in an invalid or error state.</li>
<li>DOCA_ERROR_NOT_SUPPORTED - if the current datapath is not supported.</li>
<li>DOCA_ERROR_CONNECTION_ABORTED - if connection failed or connection details object was corrupted. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga3ad6e5b3a4c448373441edc6946685dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ad6e5b3a4c448373441edc6946685dd">&#9670;&nbsp;</a></span>doca_rdma_stop_listen_to_port()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_rdma_stop_listen_to_port </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma *&#160;</td>
          <td class="paramname"><em>rdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>End the listen process for a connection from remote doca_rdma peers. Can be called when the ctx is in DOCA_CTX_STATE_RUNNING state. Once called, Server just stop listening for incoming connection requests and do not disconnect any remote doca_rdma peer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rdma</td><td>Pointer to doca_rdma to connect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">port</td><td>Port to stop listening to for connection requests.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - if an invalid parameter was given.</li>
<li>DOCA_ERROR_NOT_SUPPORTED - if the current datapath is not supported.</li>
<li>DOCA_ERROR_CONNECTION_ABORTED - if connection failed or connection details object was corrupted. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga808ef54de4d6e0504a35c11fc1a34e37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga808ef54de4d6e0504a35c11fc1a34e37">&#9670;&nbsp;</a></span>doca_rdma_task_atomic_cmp_swp_allocate_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_rdma_task_atomic_cmp_swp_allocate_init </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma *&#160;</td>
          <td class="paramname"><em>rdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct doca_rdma_connection *&#160;</td>
          <td class="paramname"><em>rdma_connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct doca_buf *&#160;</td>
          <td class="paramname"><em>dst_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct doca_buf *&#160;</td>
          <td class="paramname"><em>result_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>cmp_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>swap_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">union <a class="el" href="uniondoca__data.html">doca_data</a>&#160;</td>
          <td class="paramname"><em>user_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct doca_rdma_task_atomic_cmp_swp **&#160;</td>
          <td class="paramname"><em>task</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method allocates and initializes an atomic compare and swap task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rdma</td><td>The RDMA instance to allocate the task for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rdma_connection</td><td>Connection related data required for doca_rdma to connect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dst_buf</td><td>Remote destination buffer, on which the atomic 8-byte operation will be executed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>buffer lists are not supported for dst_buf, only the first 8-bytes of data in the head buffer will be considered for this task. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">result_buf</td><td>Local buffer, to which the original remote 8-byte value (before the swap, if occurred) will be written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>buffer lists are not supported for result_buf, only the head will be considered for this task. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cmp_data</td><td>An 8-byte value that will be compared to the remote 8-byte value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swap_data</td><td>An 8-byte value that will be written to dst_buf, overwriting it's previous data, in case cmp_data is equal to the original remote 8-byte value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user_data</td><td><a class="el" href="uniondoca__data.html" title="Convenience type for representing opaque data.">doca_data</a> to attach to the task. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">task</td><td>On success, an allocated and initialized an atomic compare and swap task.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input.</li>
<li>DOCA_ERROR_NO_MEMORY - no more tasks to allocate. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga4165dbbce29b18e9fdf7f4c40f3870a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4165dbbce29b18e9fdf7f4c40f3870a2">&#9670;&nbsp;</a></span>doca_rdma_task_atomic_cmp_swp_as_task()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> struct doca_task* doca_rdma_task_atomic_cmp_swp_as_task </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma_task_atomic_cmp_swp *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method converts an atomic compare and swap task to a doca_task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task that should be converted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The atomic compare and swap task converted to doca_task. </dd></dl>

</div>
</div>
<a id="gad63f3a4c0d08f02e9791bb13d06c8c16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad63f3a4c0d08f02e9791bb13d06c8c16">&#9670;&nbsp;</a></span>doca_rdma_task_atomic_cmp_swp_get_cmp_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> uint64_t doca_rdma_task_atomic_cmp_swp_get_cmp_data </td>
          <td>(</td>
          <td class="paramtype">const struct doca_rdma_task_atomic_cmp_swp *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method gets the compare data of an atomic compare and swap task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task that should be queried.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The task's cmp_data. </dd></dl>

</div>
</div>
<a id="gac029b98fb2b1cd186a31909751237ade"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac029b98fb2b1cd186a31909751237ade">&#9670;&nbsp;</a></span>doca_rdma_task_atomic_cmp_swp_get_dst_buf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> struct doca_buf* doca_rdma_task_atomic_cmp_swp_get_dst_buf </td>
          <td>(</td>
          <td class="paramtype">const struct doca_rdma_task_atomic_cmp_swp *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method gets the destination buffer of an atomic compare and swap task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task that should be queried.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The task's dst_buf. </dd></dl>

</div>
</div>
<a id="ga7bc63a22cda0488d2ebbd6404ca245c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7bc63a22cda0488d2ebbd6404ca245c3">&#9670;&nbsp;</a></span>doca_rdma_task_atomic_cmp_swp_get_rdma_connection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> const struct doca_rdma_connection* doca_rdma_task_atomic_cmp_swp_get_rdma_connection </td>
          <td>(</td>
          <td class="paramtype">const struct doca_rdma_task_atomic_cmp_swp *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method gets the rdma connection of a atomic compare and swap task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task that should be queried.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The task's rdma connection. </dd></dl>

</div>
</div>
<a id="ga18b2ee348c559183568999d04782dfc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga18b2ee348c559183568999d04782dfc4">&#9670;&nbsp;</a></span>doca_rdma_task_atomic_cmp_swp_get_result_buf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> struct doca_buf* doca_rdma_task_atomic_cmp_swp_get_result_buf </td>
          <td>(</td>
          <td class="paramtype">const struct doca_rdma_task_atomic_cmp_swp *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method gets the result buffer of an atomic compare and swap task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task that should be queried.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The task's result_buf. </dd></dl>

</div>
</div>
<a id="gaed5045cc79a0a0035c848ddffcad1f3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed5045cc79a0a0035c848ddffcad1f3f">&#9670;&nbsp;</a></span>doca_rdma_task_atomic_cmp_swp_get_swap_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> uint64_t doca_rdma_task_atomic_cmp_swp_get_swap_data </td>
          <td>(</td>
          <td class="paramtype">const struct doca_rdma_task_atomic_cmp_swp *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method gets the swap data of an atomic compare and swap task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task that should be queried.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The task's swap_data. </dd></dl>

</div>
</div>
<a id="ga218092ad6eb94309ea9b91a6290ece91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga218092ad6eb94309ea9b91a6290ece91">&#9670;&nbsp;</a></span>doca_rdma_task_atomic_cmp_swp_set_cmp_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> void doca_rdma_task_atomic_cmp_swp_set_cmp_data </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma_task_atomic_cmp_swp *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>cmp_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method sets the compare data of an atomic compare and swap task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task to set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmp_data</td><td>An 8-byte value that will be compared to the remote 8-byte value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9ef6a98644d8df533abacb24877bc9cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ef6a98644d8df533abacb24877bc9cb">&#9670;&nbsp;</a></span>doca_rdma_task_atomic_cmp_swp_set_conf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_rdma_task_atomic_cmp_swp_set_conf </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma *&#160;</td>
          <td class="paramname"><em>rdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DOCA__RDMA.html#ga0e23f2dcdf3c9e342c204a5623865b8e">doca_rdma_task_atomic_cmp_swp_completion_cb_t</a>&#160;</td>
          <td class="paramname"><em>successful_task_completion_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DOCA__RDMA.html#ga0e23f2dcdf3c9e342c204a5623865b8e">doca_rdma_task_atomic_cmp_swp_completion_cb_t</a>&#160;</td>
          <td class="paramname"><em>error_task_completion_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num_tasks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method sets the atomic compare and swap tasks configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rdma</td><td>The RDMA instance to config. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">successful_task_completion_cb</td><td>A callback function for atomic compare and swap tasks that were completed successfully. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">error_task_completion_cb</td><td>A callback function for atomic compare and swap tasks that were completed with an error. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_tasks</td><td>Number of atomic compare and swap tasks.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input.</li>
<li>DOCA_ERROR_BAD_STATE - the RDMA instance is not idle. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gacd7a3cade606d85db166dadcf0769100"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd7a3cade606d85db166dadcf0769100">&#9670;&nbsp;</a></span>doca_rdma_task_atomic_cmp_swp_set_dst_buf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> void doca_rdma_task_atomic_cmp_swp_set_dst_buf </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma_task_atomic_cmp_swp *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct doca_buf *&#160;</td>
          <td class="paramname"><em>dst_buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method sets the destination buffer of an atomic compare and swap task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task to set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dst_buf</td><td>Remote destination buffer, on which the atomic 8-byte operation will be executed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>buffer lists are not supported for dst_buf, only the first 8-bytes of data in the head buffer will be considered for this task. </dd></dl>

</div>
</div>
<a id="gafaa18a46639d145d2a670f1d204dfe58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafaa18a46639d145d2a670f1d204dfe58">&#9670;&nbsp;</a></span>doca_rdma_task_atomic_cmp_swp_set_rdma_connection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> void doca_rdma_task_atomic_cmp_swp_set_rdma_connection </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma_task_atomic_cmp_swp *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct doca_rdma_connection *&#160;</td>
          <td class="paramname"><em>rdma_connection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method sets the rdma_connection of a atomic compare and swap task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task to set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rdma_connection</td><td>RDMA Connection to use on this task </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab3a8b114259e301ca76aed04e7c368a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3a8b114259e301ca76aed04e7c368a9">&#9670;&nbsp;</a></span>doca_rdma_task_atomic_cmp_swp_set_result_buf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> void doca_rdma_task_atomic_cmp_swp_set_result_buf </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma_task_atomic_cmp_swp *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct doca_buf *&#160;</td>
          <td class="paramname"><em>result_buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method sets the result buffer of an atomic compare and swap task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task to set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">result_buf</td><td>Local buffer, to which the original remote 8-byte value (before the swap, if occurred) will be written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>buffer lists are not supported for result_buf, only the head will be considered for this task. </dd></dl>

</div>
</div>
<a id="ga126187b59473540d97d12888bac615e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga126187b59473540d97d12888bac615e4">&#9670;&nbsp;</a></span>doca_rdma_task_atomic_cmp_swp_set_swap_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> void doca_rdma_task_atomic_cmp_swp_set_swap_data </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma_task_atomic_cmp_swp *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>swap_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method sets the swap data of an atomic compare and swap task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task to set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swap_data</td><td>An 8-byte value that will be written to dst_buf, overwriting it's previous data, in case cmp_data is equal to the original remote 8-byte value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga179b21b111f3d31c414799743b805207"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga179b21b111f3d31c414799743b805207">&#9670;&nbsp;</a></span>doca_rdma_task_atomic_fetch_add_allocate_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_rdma_task_atomic_fetch_add_allocate_init </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma *&#160;</td>
          <td class="paramname"><em>rdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct doca_rdma_connection *&#160;</td>
          <td class="paramname"><em>rdma_connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct doca_buf *&#160;</td>
          <td class="paramname"><em>dst_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct doca_buf *&#160;</td>
          <td class="paramname"><em>result_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>add_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">union <a class="el" href="uniondoca__data.html">doca_data</a>&#160;</td>
          <td class="paramname"><em>user_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct doca_rdma_task_atomic_fetch_add **&#160;</td>
          <td class="paramname"><em>task</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method allocates and initializes an atomic fetch and add task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rdma</td><td>The RDMA instance to allocate the task for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rdma_connection</td><td>Connection related data required for doca_rdma to connect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dst_buf</td><td>Remote destination buffer, on which the atomic 8-byte operation will be executed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>buffer lists are not supported for dst_buf, only the first 8-bytes of data in the head buffer will be considered for this task. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">result_buf</td><td>Local buffer, to which the original remote 8-byte value (before the addition) will be written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>buffer lists are not supported for result_buf, only the head will be considered for this task. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">add_data</td><td>An 8-byte value that will be added to the remote 8-byte value in dst_buf. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user_data</td><td><a class="el" href="uniondoca__data.html" title="Convenience type for representing opaque data.">doca_data</a> to attach to the task. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">task</td><td>On success, an allocated and initialized an atomic fetch and add task.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input.</li>
<li>DOCA_ERROR_NO_MEMORY - no more tasks to allocate. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaba77207bd9e454780225caeac202be6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba77207bd9e454780225caeac202be6b">&#9670;&nbsp;</a></span>doca_rdma_task_atomic_fetch_add_as_task()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> struct doca_task* doca_rdma_task_atomic_fetch_add_as_task </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma_task_atomic_fetch_add *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method converts an atomic fetch and add task to a doca_task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task that should be converted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The atomic fetch and add task converted to doca_task. </dd></dl>

</div>
</div>
<a id="ga1f7b060d4e6fe46e3acd22a2eced696b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f7b060d4e6fe46e3acd22a2eced696b">&#9670;&nbsp;</a></span>doca_rdma_task_atomic_fetch_add_get_add_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> uint64_t doca_rdma_task_atomic_fetch_add_get_add_data </td>
          <td>(</td>
          <td class="paramtype">const struct doca_rdma_task_atomic_fetch_add *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method gets the add data of an atomic fetch and add task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task that should be queried.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The task's add_data. </dd></dl>

</div>
</div>
<a id="gad169447e842efdaebb456ed23d0ab0ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad169447e842efdaebb456ed23d0ab0ee">&#9670;&nbsp;</a></span>doca_rdma_task_atomic_fetch_add_get_dst_buf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> struct doca_buf* doca_rdma_task_atomic_fetch_add_get_dst_buf </td>
          <td>(</td>
          <td class="paramtype">const struct doca_rdma_task_atomic_fetch_add *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method gets the destination buffer of an atomic fetch and add task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task that should be queried.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The task's dst_buf. </dd></dl>

</div>
</div>
<a id="gad66f0af1c168b2ade59541e4022ab0a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad66f0af1c168b2ade59541e4022ab0a2">&#9670;&nbsp;</a></span>doca_rdma_task_atomic_fetch_add_get_rdma_connection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> const struct doca_rdma_connection* doca_rdma_task_atomic_fetch_add_get_rdma_connection </td>
          <td>(</td>
          <td class="paramtype">const struct doca_rdma_task_atomic_fetch_add *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method gets the rdma connection of a atomic fetch and add task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task that should be queried.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The task's rdma connection. </dd></dl>

</div>
</div>
<a id="gaecdb3ba1ba3a5a1d5369aa47139fccfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaecdb3ba1ba3a5a1d5369aa47139fccfc">&#9670;&nbsp;</a></span>doca_rdma_task_atomic_fetch_add_get_result_buf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> struct doca_buf* doca_rdma_task_atomic_fetch_add_get_result_buf </td>
          <td>(</td>
          <td class="paramtype">const struct doca_rdma_task_atomic_fetch_add *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method gets the result buffer of an atomic fetch and add task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task that should be queried.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The task's result_buf. </dd></dl>

</div>
</div>
<a id="ga5bb77a842024a537bf74264a8a349be9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5bb77a842024a537bf74264a8a349be9">&#9670;&nbsp;</a></span>doca_rdma_task_atomic_fetch_add_set_add_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> void doca_rdma_task_atomic_fetch_add_set_add_data </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma_task_atomic_fetch_add *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>add_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method sets the add data of an atomic fetch and add task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task to set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">add_data</td><td>An 8-byte value that will be added to the remote 8-byte value in dst_buf. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga44f6dd8652a26b727d2f66719ff53f4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga44f6dd8652a26b727d2f66719ff53f4d">&#9670;&nbsp;</a></span>doca_rdma_task_atomic_fetch_add_set_conf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_rdma_task_atomic_fetch_add_set_conf </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma *&#160;</td>
          <td class="paramname"><em>rdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DOCA__RDMA.html#ga16c1f55e5724609d494ae369d81421a0">doca_rdma_task_atomic_fetch_add_completion_cb_t</a>&#160;</td>
          <td class="paramname"><em>successful_task_completion_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DOCA__RDMA.html#ga16c1f55e5724609d494ae369d81421a0">doca_rdma_task_atomic_fetch_add_completion_cb_t</a>&#160;</td>
          <td class="paramname"><em>error_task_completion_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num_tasks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method sets the atomic fetch and add tasks configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rdma</td><td>The RDMA instance to config. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">successful_task_completion_cb</td><td>A callback function for atomic fetch and add tasks that were completed successfully. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">error_task_completion_cb</td><td>A callback function for atomic fetch and add tasks that were completed with an error. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_tasks</td><td>Number of atomic fetch and add tasks.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input.</li>
<li>DOCA_ERROR_BAD_STATE - the RDMA instance is not idle. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga65c0e349e64789496f4c593a87545896"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga65c0e349e64789496f4c593a87545896">&#9670;&nbsp;</a></span>doca_rdma_task_atomic_fetch_add_set_dst_buf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> void doca_rdma_task_atomic_fetch_add_set_dst_buf </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma_task_atomic_fetch_add *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct doca_buf *&#160;</td>
          <td class="paramname"><em>dst_buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method sets the destination buffer of an atomic fetch and add task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task to set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dst_buf</td><td>Remote destination buffer, on which the atomic 8-byte operation will be executed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>buffer lists are not supported for dst_buf, only the first 8-bytes of data in the head buffer will be considered for this task. </dd></dl>

</div>
</div>
<a id="ga52abeff9265415ca84ea85ce27e3b657"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga52abeff9265415ca84ea85ce27e3b657">&#9670;&nbsp;</a></span>doca_rdma_task_atomic_fetch_add_set_rdma_connection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> void doca_rdma_task_atomic_fetch_add_set_rdma_connection </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma_task_atomic_fetch_add *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct doca_rdma_connection *&#160;</td>
          <td class="paramname"><em>rdma_connection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method sets the rdma_connection of a atomic fetch and add task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task to set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rdma_connection</td><td>RDMA Connection to use on this task </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5cc1550bf1f4cfa44fef5cf6bf7aa67a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5cc1550bf1f4cfa44fef5cf6bf7aa67a">&#9670;&nbsp;</a></span>doca_rdma_task_atomic_fetch_add_set_result_buf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> void doca_rdma_task_atomic_fetch_add_set_result_buf </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma_task_atomic_fetch_add *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct doca_buf *&#160;</td>
          <td class="paramname"><em>result_buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method sets the result buffer of an atomic fetch and add task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task to set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">result_buf</td><td>Local buffer, to which the original remote 8-byte value (before the addition) will be written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>buffer lists are not supported for result_buf, only the head will be considered for this task. </dd></dl>

</div>
</div>
<a id="ga4fba29df9779dec32ac4682083d599f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4fba29df9779dec32ac4682083d599f0">&#9670;&nbsp;</a></span>doca_rdma_task_read_allocate_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_rdma_task_read_allocate_init </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma *&#160;</td>
          <td class="paramname"><em>rdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct doca_rdma_connection *&#160;</td>
          <td class="paramname"><em>rdma_connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct doca_buf *&#160;</td>
          <td class="paramname"><em>src_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct doca_buf *&#160;</td>
          <td class="paramname"><em>dst_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">union <a class="el" href="uniondoca__data.html">doca_data</a>&#160;</td>
          <td class="paramname"><em>user_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct doca_rdma_task_read **&#160;</td>
          <td class="paramname"><em>task</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method allocates and initializes a read task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rdma</td><td>The RDMA instance to allocate the task for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rdma_connection</td><td>Connection related data required for doca_rdma to connect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src_buf</td><td>Remote source buffer, holding the data that should be read. May be NULL when wishing to read no data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>buffer lists are not supported for src_buf, only the head will be considered for this task. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dst_buf</td><td>Local destination buffer, to which the read data will be written. May be NULL when src_buf is NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>dst_buf may be linked to other buffers, with a limit according to the max_send_buf_list_len property that can be set or queried using <a class="el" href="group__DOCA__RDMA.html#gafdc92935ee7fad23891df4213341fc04" title="Set the maximum buffer list length property for local buffers of tasks that are sent to the remote an...">doca_rdma_set_max_send_buf_list_len()</a> \ <a class="el" href="group__DOCA__RDMA.html#gad7948de5b8a3439c14324cf74be37543" title="Get the maximum buffer list length property for local buffers of tasks that are sent to the remote an...">doca_rdma_get_max_send_buf_list_len()</a> respectfully. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">user_data</td><td><a class="el" href="uniondoca__data.html" title="Convenience type for representing opaque data.">doca_data</a> to attach to the task. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">task</td><td>On success, an allocated and initialized a read task.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input.</li>
<li>DOCA_ERROR_NO_MEMORY - no more tasks to allocate. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaaed3f9c9b3b0195789877979ebde63b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaed3f9c9b3b0195789877979ebde63b3">&#9670;&nbsp;</a></span>doca_rdma_task_read_as_task()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> struct doca_task* doca_rdma_task_read_as_task </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma_task_read *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method converts a read task to a doca_task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task that should be converted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The read task converted to doca_task. </dd></dl>

</div>
</div>
<a id="gafaf7fc6ba81673aae5b0f86ca385192f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafaf7fc6ba81673aae5b0f86ca385192f">&#9670;&nbsp;</a></span>doca_rdma_task_read_get_dst_buf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> struct doca_buf* doca_rdma_task_read_get_dst_buf </td>
          <td>(</td>
          <td class="paramtype">const struct doca_rdma_task_read *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method gets the destination buffer of a read task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task that should be queried.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The task's dst_buf. </dd></dl>

</div>
</div>
<a id="ga39dd2efab5304062f816ec1c6ea608f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga39dd2efab5304062f816ec1c6ea608f1">&#9670;&nbsp;</a></span>doca_rdma_task_read_get_rdma_connection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> const struct doca_rdma_connection* doca_rdma_task_read_get_rdma_connection </td>
          <td>(</td>
          <td class="paramtype">const struct doca_rdma_task_read *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method gets the rdma connection of a read task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task that should be queried.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The task's rdma connection. </dd></dl>

</div>
</div>
<a id="gafaf1b666dff5e9f0c04a5bfde332a70f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafaf1b666dff5e9f0c04a5bfde332a70f">&#9670;&nbsp;</a></span>doca_rdma_task_read_get_result_len()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> uint32_t doca_rdma_task_read_get_result_len </td>
          <td>(</td>
          <td class="paramtype">const struct doca_rdma_task_read *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method gets the length of data read by the task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task that should be queried.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Total length of read data in case of completion. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Valid only on successful completion of the task. Otherwise, undefined behavior. </dd></dl>

</div>
</div>
<a id="gab2de872c4af8336beb235d67f824b572"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab2de872c4af8336beb235d67f824b572">&#9670;&nbsp;</a></span>doca_rdma_task_read_get_src_buf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> const struct doca_buf* doca_rdma_task_read_get_src_buf </td>
          <td>(</td>
          <td class="paramtype">const struct doca_rdma_task_read *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method gets the source buffer of a read task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task that should be queried.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The task's src_buf. </dd></dl>

</div>
</div>
<a id="ga952a6e977e9475cd1e9a12e782aa3186"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga952a6e977e9475cd1e9a12e782aa3186">&#9670;&nbsp;</a></span>doca_rdma_task_read_set_conf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_rdma_task_read_set_conf </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma *&#160;</td>
          <td class="paramname"><em>rdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DOCA__RDMA.html#gabc2c0386e7673546d9808fe3fda055f5">doca_rdma_task_read_completion_cb_t</a>&#160;</td>
          <td class="paramname"><em>successful_task_completion_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DOCA__RDMA.html#gabc2c0386e7673546d9808fe3fda055f5">doca_rdma_task_read_completion_cb_t</a>&#160;</td>
          <td class="paramname"><em>error_task_completion_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num_tasks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method sets the read tasks configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rdma</td><td>The RDMA instance to config. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">successful_task_completion_cb</td><td>A callback function for read tasks that were completed successfully. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">error_task_completion_cb</td><td>A callback function for read tasks that were completed with an error. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_tasks</td><td>Number of read tasks.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input.</li>
<li>DOCA_ERROR_BAD_STATE - the RDMA instance is not idle. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga8abff611cfb5756c78018d3cd72a957d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8abff611cfb5756c78018d3cd72a957d">&#9670;&nbsp;</a></span>doca_rdma_task_read_set_dst_buf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> void doca_rdma_task_read_set_dst_buf </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma_task_read *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct doca_buf *&#160;</td>
          <td class="paramname"><em>dst_buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method sets the destination buffer of a read task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task to set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dst_buf</td><td>Local destination buffer, to which the read data will be written. May be NULL when src_buf is NULL. If the destination buffer is not set by the user, it will have a default value - NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>dst_buf may be linked to other buffers, with a limit according to the max_send_buf_list_len property that can be set or queried using <a class="el" href="group__DOCA__RDMA.html#gafdc92935ee7fad23891df4213341fc04" title="Set the maximum buffer list length property for local buffers of tasks that are sent to the remote an...">doca_rdma_set_max_send_buf_list_len()</a> \ <a class="el" href="group__DOCA__RDMA.html#gad7948de5b8a3439c14324cf74be37543" title="Get the maximum buffer list length property for local buffers of tasks that are sent to the remote an...">doca_rdma_get_max_send_buf_list_len()</a> respectfully. </dd></dl>

</div>
</div>
<a id="ga0ce927e378146a0e021824dca747118e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ce927e378146a0e021824dca747118e">&#9670;&nbsp;</a></span>doca_rdma_task_read_set_rdma_connection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> void doca_rdma_task_read_set_rdma_connection </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma_task_read *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct doca_rdma_connection *&#160;</td>
          <td class="paramname"><em>rdma_connection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method sets the rdma_connection of a read task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task to set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rdma_connection</td><td>RDMA Connection to use on this task </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab99613a47053e922c4f3afeccd7bb194"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab99613a47053e922c4f3afeccd7bb194">&#9670;&nbsp;</a></span>doca_rdma_task_read_set_src_buf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> void doca_rdma_task_read_set_src_buf </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma_task_read *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct doca_buf *&#160;</td>
          <td class="paramname"><em>src_buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method sets the source buffer of a read task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task to set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src_buf</td><td>Local source buffer, with the data to be sent. May be NULL when wishing to send an empty message (without data). If the source buffer is not set by the user, it will have a default value - NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>buffer lists are not supported for src_buf, only the head will be considered for this task. </dd></dl>

</div>
</div>
<a id="ga924d2cb1bb97098b43a19e0351e56444"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga924d2cb1bb97098b43a19e0351e56444">&#9670;&nbsp;</a></span>doca_rdma_task_receive_allocate_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_rdma_task_receive_allocate_init </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma *&#160;</td>
          <td class="paramname"><em>rdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct doca_buf *&#160;</td>
          <td class="paramname"><em>dst_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">union <a class="el" href="uniondoca__data.html">doca_data</a>&#160;</td>
          <td class="paramname"><em>user_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct doca_rdma_task_receive **&#160;</td>
          <td class="paramname"><em>task</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method allocates and initializes a receive task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rdma</td><td>The RDMA instance to allocate the task for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dst_buf</td><td>Local destination buffer, for the received data. May be NULL when receiving an empty message (without data), with or without immediate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>dst_buf may be linked to other buffers, with a limit according to <a class="el" href="group__DOCA__RDMA.html#ga3d6858ec036a6a5ffc5f24236cfa3d21">doca_rdma_cap_task_receive_get_max_dst_buf_list_len()</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">user_data</td><td><a class="el" href="uniondoca__data.html" title="Convenience type for representing opaque data.">doca_data</a> to attach to the task. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">task</td><td>On success, an allocated and initialized a receive task.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input.</li>
<li>DOCA_ERROR_NO_MEMORY - no more tasks to allocate. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga553f007d0acabb31b3837f2bd15fda34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga553f007d0acabb31b3837f2bd15fda34">&#9670;&nbsp;</a></span>doca_rdma_task_receive_as_task()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> struct doca_task* doca_rdma_task_receive_as_task </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma_task_receive *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method converts a receive task to a doca_task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task that should be converted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The receive task converted to doca_task. </dd></dl>

</div>
</div>
<a id="ga00f157a503c56605cedebb5624118d9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga00f157a503c56605cedebb5624118d9c">&#9670;&nbsp;</a></span>doca_rdma_task_receive_get_dst_buf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> struct doca_buf* doca_rdma_task_receive_get_dst_buf </td>
          <td>(</td>
          <td class="paramtype">const struct doca_rdma_task_receive *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method gets the destination buffer of a receive task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task that should be queried.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The task's dst_buf. </dd></dl>

</div>
</div>
<a id="gab322e884f5510dc205914c6a3d33ab77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab322e884f5510dc205914c6a3d33ab77">&#9670;&nbsp;</a></span>doca_rdma_task_receive_get_dst_buf_list_len()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_rdma_task_receive_get_dst_buf_list_len </td>
          <td>(</td>
          <td class="paramtype">const struct doca_rdma *&#160;</td>
          <td class="paramname"><em>rdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>buf_list_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the maximal destination buffer list length property for receive tasks. The returned value is the actual value being used and might differ from the size set by the user, as it may be increased. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rdma</td><td>The RDMA instance to get the property from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buf_list_len</td><td>buf_list_len used in doca_rdma.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - if property retrieved successfully. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - if an invalid parameter was given.</li>
<li>DOCA_ERROR_BAD_STATE - if the given RDMA was created with SRQ. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga18f11933847e06c02ed3b511dead5160"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga18f11933847e06c02ed3b511dead5160">&#9670;&nbsp;</a></span>doca_rdma_task_receive_get_result_immediate_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__TYPES.html#ga37ca3c7aed1aadba64e71712ea0e069f">doca_be32_t</a> doca_rdma_task_receive_get_result_immediate_data </td>
          <td>(</td>
          <td class="paramtype">const struct doca_rdma_task_receive *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method gets the immediate data received by the task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task that should be queried.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 32-bit immediate data value, in Big-Endian, received OOB from the peer along with the message. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Valid only on successful completion of the task and when the result opcode is DOCA_RDMA_OPCODE_RECV_SEND_WITH_IMM or DOCA_RDMA_OPCODE_RECV_WRITE_WITH_IMM (retrieved using <a class="el" href="group__DOCA__RDMA.html#ga389747420fbfff3ac2c6d9b905efe6ed" title="This method gets the opcode of the operation executed by the peer and received by the task.">doca_rdma_task_receive_get_result_opcode()</a>). Otherwise, undefined behavior. </dd></dl>

</div>
</div>
<a id="gae26a447dcbf280ea2b9b5ed839df5f63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae26a447dcbf280ea2b9b5ed839df5f63">&#9670;&nbsp;</a></span>doca_rdma_task_receive_get_result_len()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> uint32_t doca_rdma_task_receive_get_result_len </td>
          <td>(</td>
          <td class="paramtype">const struct doca_rdma_task_receive *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method gets the length of data received by the task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task that should be queried.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Total length of received data in case of completion. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Valid only on successful completion of the task. Otherwise, undefined behavior. </dd></dl>

</div>
</div>
<a id="ga389747420fbfff3ac2c6d9b905efe6ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga389747420fbfff3ac2c6d9b905efe6ed">&#9670;&nbsp;</a></span>doca_rdma_task_receive_get_result_opcode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> enum <a class="el" href="group__DOCA__RDMA.html#ga3cbcdbcd5adcbc7aa0b4eae4376ec9c8">doca_rdma_opcode</a> doca_rdma_task_receive_get_result_opcode </td>
          <td>(</td>
          <td class="paramtype">const struct doca_rdma_task_receive *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method gets the opcode of the operation executed by the peer and received by the task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task that should be queried.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The operation executed by the peer and received. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Valid only on after completion of the task. Otherwise, undefined behavior. </dd></dl>

</div>
</div>
<a id="ga6dae1573a3d8cba7a8cf98624033af2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6dae1573a3d8cba7a8cf98624033af2a">&#9670;&nbsp;</a></span>doca_rdma_task_receive_get_result_rdma_connection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> const struct doca_rdma_connection* doca_rdma_task_receive_get_result_rdma_connection </td>
          <td>(</td>
          <td class="paramtype">const struct doca_rdma_task_receive *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method gets the rdma connection of a receive task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task that should be queried.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The task's rdma connection. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Valid only in the doca_rdma_task_receive successful completion callback. </dd></dl>

</div>
</div>
<a id="ga7a7a4d6c724e0d918d85282c42d491dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a7a4d6c724e0d918d85282c42d491dd">&#9670;&nbsp;</a></span>doca_rdma_task_receive_set_conf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_rdma_task_receive_set_conf </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma *&#160;</td>
          <td class="paramname"><em>rdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DOCA__RDMA.html#ga0408ed0a480a862797dcede45efee761">doca_rdma_task_receive_completion_cb_t</a>&#160;</td>
          <td class="paramname"><em>successful_task_completion_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DOCA__RDMA.html#ga0408ed0a480a862797dcede45efee761">doca_rdma_task_receive_completion_cb_t</a>&#160;</td>
          <td class="paramname"><em>error_task_completion_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num_tasks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method sets the receive tasks configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rdma</td><td>The RDMA instance to config. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">successful_task_completion_cb</td><td>A callback function for receive tasks that were completed successfully. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">error_task_completion_cb</td><td>A callback function for receive tasks that were completed with an error. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_tasks</td><td>Number of receive tasks.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input.</li>
<li>DOCA_ERROR_BAD_STATE - the RDMA instance is not idle. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gadce2104fd412c2a131349e9cee97001c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadce2104fd412c2a131349e9cee97001c">&#9670;&nbsp;</a></span>doca_rdma_task_receive_set_dst_buf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> void doca_rdma_task_receive_set_dst_buf </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma_task_receive *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct doca_buf *&#160;</td>
          <td class="paramname"><em>dst_buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method sets the destination buffer of a receive task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task to set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dst_buf</td><td>Local destination buffer, for the received data. May be NULL when receiving an empty message (without data), with or without immediate. If the destination buffer is not set by the user, it will have a default value - NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>dst_buf may be linked to other buffers, with a limit according to <a class="el" href="group__DOCA__RDMA.html#ga3d6858ec036a6a5ffc5f24236cfa3d21">doca_rdma_cap_task_receive_get_max_dst_buf_list_len()</a>. </dd></dl>

</div>
</div>
<a id="gaa747f37e09930ed68a42a3a2f0aec94a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa747f37e09930ed68a42a3a2f0aec94a">&#9670;&nbsp;</a></span>doca_rdma_task_receive_set_dst_buf_list_len()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_rdma_task_receive_set_dst_buf_list_len </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma *&#160;</td>
          <td class="paramname"><em>rdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>buf_list_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the maximal destination buffer list length property for receive tasks. After starting the DOCA RDMA context the length may be increased and the value in use can be queried using doca_rdma_get_recv_buf_list_len(). </p>
<dl class="section note"><dt>Note</dt><dd>Can only be called before calling <a class="el" href="group__DOCA__CTX.html#ga712a2c32ab9113f568d08c379ec506f7" title="Finalizes all configurations, and starts the DOCA CTX.">doca_ctx_start()</a>. </dd>
<dd>
Cannot exceed the value returned from <a class="el" href="group__DOCA__RDMA.html#ga3d6858ec036a6a5ffc5f24236cfa3d21">doca_rdma_cap_task_receive_get_max_dst_buf_list_len()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rdma</td><td>The RDMA instance to set the property for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_list_len</td><td>buf_list_len to use in doca_rdma.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - if property set successfully. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - if an invalid parameter was given.</li>
<li>DOCA_ERROR_BAD_STATE - if context is already started or if the given RDMA was created with SRQ. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gafd0801cde5179de5ad7088cc58719794"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd0801cde5179de5ad7088cc58719794">&#9670;&nbsp;</a></span>doca_rdma_task_remote_net_sync_event_get_allocate_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_rdma_task_remote_net_sync_event_get_allocate_init </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma *&#160;</td>
          <td class="paramname"><em>rdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct doca_rdma_connection *&#160;</td>
          <td class="paramname"><em>rdma_connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct doca_sync_event_remote_net *&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct doca_buf *&#160;</td>
          <td class="paramname"><em>dst_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">union <a class="el" href="uniondoca__data.html">doca_data</a>&#160;</td>
          <td class="paramname"><em>user_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct doca_rdma_task_remote_net_sync_event_get **&#160;</td>
          <td class="paramname"><em>task</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method allocates and initializes a remote_net_sync_event_get task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rdma</td><td>The RDMA instance to allocate the task for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rdma_connection</td><td>Connection related data required for doca_rdma to connect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>Remote net sync event to read its value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dst_buf</td><td>Local destination buffer, to which the read data will be written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>dst_buf may be linked to other buffers, with a limit according to the max_send_buf_list_len property that can be set or queried using <a class="el" href="group__DOCA__RDMA.html#gafdc92935ee7fad23891df4213341fc04" title="Set the maximum buffer list length property for local buffers of tasks that are sent to the remote an...">doca_rdma_set_max_send_buf_list_len()</a> \ <a class="el" href="group__DOCA__RDMA.html#gad7948de5b8a3439c14324cf74be37543" title="Get the maximum buffer list length property for local buffers of tasks that are sent to the remote an...">doca_rdma_get_max_send_buf_list_len()</a> respectfully. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">user_data</td><td><a class="el" href="uniondoca__data.html" title="Convenience type for representing opaque data.">doca_data</a> to attach to the task. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">task</td><td>On success, an allocated and initialized a remote_net_sync_event_get task.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input.</li>
<li>DOCA_ERROR_NO_MEMORY - no more tasks to allocate. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga6e1d6a66ce0da45550b6dbfc8c8e35aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e1d6a66ce0da45550b6dbfc8c8e35aa">&#9670;&nbsp;</a></span>doca_rdma_task_remote_net_sync_event_get_as_task()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> struct doca_task* doca_rdma_task_remote_net_sync_event_get_as_task </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma_task_remote_net_sync_event_get *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method converts a remote_net_sync_event_get task to a doca_task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task that should be converted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The remote_net_sync_event_get task converted to doca_task. </dd></dl>

</div>
</div>
<a id="gae6ead9a285a2311b29f8ef2a17aeff2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae6ead9a285a2311b29f8ef2a17aeff2f">&#9670;&nbsp;</a></span>doca_rdma_task_remote_net_sync_event_get_get_dst_buf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> struct doca_buf* doca_rdma_task_remote_net_sync_event_get_get_dst_buf </td>
          <td>(</td>
          <td class="paramtype">const struct doca_rdma_task_remote_net_sync_event_get *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method gets the destination buffer of a remote_net_sync_event_get task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task that should be queried.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The task's dst_buf. </dd></dl>

</div>
</div>
<a id="ga9a64e9f09886f20d9ff62172ab08b880"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a64e9f09886f20d9ff62172ab08b880">&#9670;&nbsp;</a></span>doca_rdma_task_remote_net_sync_event_get_get_rdma_connection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> const struct doca_rdma_connection* doca_rdma_task_remote_net_sync_event_get_get_rdma_connection </td>
          <td>(</td>
          <td class="paramtype">const struct doca_rdma_task_remote_net_sync_event_get *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method gets the rdma connection of a remote_net_sync_event_get task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task that should be queried.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The task's rdma connection. </dd></dl>

</div>
</div>
<a id="ga32719aa9b8b5573ab6b16315fc2d0873"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga32719aa9b8b5573ab6b16315fc2d0873">&#9670;&nbsp;</a></span>doca_rdma_task_remote_net_sync_event_get_get_result_len()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> uint32_t doca_rdma_task_remote_net_sync_event_get_get_result_len </td>
          <td>(</td>
          <td class="paramtype">const struct doca_rdma_task_remote_net_sync_event_get *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method gets the length of data read by the task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task that should be queried.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Total length of read data in case of completion. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Valid only on successful completion of the task. Otherwise, undefined behavior. </dd></dl>

</div>
</div>
<a id="ga29f9c4752fc0f27d1ba8f1794a9189cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga29f9c4752fc0f27d1ba8f1794a9189cb">&#9670;&nbsp;</a></span>doca_rdma_task_remote_net_sync_event_get_get_sync_event()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> const struct doca_sync_event_remote_net* doca_rdma_task_remote_net_sync_event_get_get_sync_event </td>
          <td>(</td>
          <td class="paramtype">const struct doca_rdma_task_remote_net_sync_event_get *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method gets the remote net sync event of a remote_net_sync_event_get task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task that should be queried.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The task's sync_event. </dd></dl>

</div>
</div>
<a id="ga07a4d220b23b6ca9f9cb5eaf22bde68a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga07a4d220b23b6ca9f9cb5eaf22bde68a">&#9670;&nbsp;</a></span>doca_rdma_task_remote_net_sync_event_get_set_conf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_rdma_task_remote_net_sync_event_get_set_conf </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma *&#160;</td>
          <td class="paramname"><em>rdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DOCA__RDMA.html#ga9dcb777cfd90aaa306faba7c4f7aad14">doca_rdma_task_remote_net_sync_event_get_completion_cb_t</a>&#160;</td>
          <td class="paramname"><em>successful_task_completion_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DOCA__RDMA.html#ga9dcb777cfd90aaa306faba7c4f7aad14">doca_rdma_task_remote_net_sync_event_get_completion_cb_t</a>&#160;</td>
          <td class="paramname"><em>error_task_completion_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num_tasks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method sets the remote_net_sync_event_get tasks configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rdma</td><td>The RDMA instance to config. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">successful_task_completion_cb</td><td>A callback function for remote_net_sync_event_get tasks that were completed successfully. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">error_task_completion_cb</td><td>A callback function for remote_net_sync_event_get tasks that were completed with an error. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_tasks</td><td>Number of remote_net_sync_event_get tasks.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input.</li>
<li>DOCA_ERROR_BAD_STATE - the RDMA instance is not idle. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga39e1d5e8e841e0aa6cfe81db8bd56342"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga39e1d5e8e841e0aa6cfe81db8bd56342">&#9670;&nbsp;</a></span>doca_rdma_task_remote_net_sync_event_get_set_dst_buf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> void doca_rdma_task_remote_net_sync_event_get_set_dst_buf </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma_task_remote_net_sync_event_get *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct doca_buf *&#160;</td>
          <td class="paramname"><em>dst_buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method sets the destination buffer of a remote_net_sync_event_get task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task to set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dst_buf</td><td>Local destination buffer, to which the remote_net_sync_event_get data will be written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>dst_buf may be linked to other buffers, with a limit according to the max_send_buf_list_len property that can be set or queried using <a class="el" href="group__DOCA__RDMA.html#gafdc92935ee7fad23891df4213341fc04" title="Set the maximum buffer list length property for local buffers of tasks that are sent to the remote an...">doca_rdma_set_max_send_buf_list_len()</a> \ <a class="el" href="group__DOCA__RDMA.html#gad7948de5b8a3439c14324cf74be37543" title="Get the maximum buffer list length property for local buffers of tasks that are sent to the remote an...">doca_rdma_get_max_send_buf_list_len()</a> respectfully. </dd></dl>

</div>
</div>
<a id="ga42582adc7cb143fac5bff397f8a1d3e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga42582adc7cb143fac5bff397f8a1d3e9">&#9670;&nbsp;</a></span>doca_rdma_task_remote_net_sync_event_get_set_rdma_connection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> void doca_rdma_task_remote_net_sync_event_get_set_rdma_connection </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma_task_remote_net_sync_event_get *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct doca_rdma_connection *&#160;</td>
          <td class="paramname"><em>rdma_connection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method sets the rdma_connection of a remote_net_sync_event_get task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task to set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rdma_connection</td><td>RDMA Connection to use on this task </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9617f02b4815f98d7aed44b9bf33d8fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9617f02b4815f98d7aed44b9bf33d8fc">&#9670;&nbsp;</a></span>doca_rdma_task_remote_net_sync_event_get_set_sync_event()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> void doca_rdma_task_remote_net_sync_event_get_set_sync_event </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma_task_remote_net_sync_event_get *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct doca_sync_event_remote_net *&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method sets the remote net sync event of a remote_net_sync_event_get task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task to set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>Remote net sync event to read its value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga34aedd8045a97261a2a00421d571bebd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga34aedd8045a97261a2a00421d571bebd">&#9670;&nbsp;</a></span>doca_rdma_task_remote_net_sync_event_notify_add_allocate_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_rdma_task_remote_net_sync_event_notify_add_allocate_init </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma *&#160;</td>
          <td class="paramname"><em>rdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct doca_rdma_connection *&#160;</td>
          <td class="paramname"><em>rdma_connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct doca_sync_event_remote_net *&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct doca_buf *&#160;</td>
          <td class="paramname"><em>result_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>add_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">union <a class="el" href="uniondoca__data.html">doca_data</a>&#160;</td>
          <td class="paramname"><em>user_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct doca_rdma_task_remote_net_sync_event_notify_add **&#160;</td>
          <td class="paramname"><em>task</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method allocates and initializes a remote_net_sync_event_notify_add task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rdma</td><td>The RDMA instance to allocate the task for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rdma_connection</td><td>Connection related data required for doca_rdma to connect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>Remote sync event to atomically increment by a given value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">result_buf</td><td>Local buffer, to which the original remote sync event value (before the addition) will be written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>buffer lists are not supported for result_buf, only the head will be considered for this task. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">add_data</td><td>An 8-byte value that will be added to the remote sync event value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user_data</td><td><a class="el" href="uniondoca__data.html" title="Convenience type for representing opaque data.">doca_data</a> to attach to the task. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">task</td><td>On success, an allocated and initialized a remote_net_sync_event_notify_add task.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input.</li>
<li>DOCA_ERROR_NO_MEMORY - no more tasks to allocate. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga11e698096d21f027d9f1a50797626022"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga11e698096d21f027d9f1a50797626022">&#9670;&nbsp;</a></span>doca_rdma_task_remote_net_sync_event_notify_add_as_task()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> struct doca_task* doca_rdma_task_remote_net_sync_event_notify_add_as_task </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma_task_remote_net_sync_event_notify_add *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method converts a remote_net_sync_event_notify_add task to a doca_task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task that should be converted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The remote_net_sync_event_notify_add task converted to doca_task. </dd></dl>

</div>
</div>
<a id="gac3c9e7f58c02708c647109a9d395d99c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac3c9e7f58c02708c647109a9d395d99c">&#9670;&nbsp;</a></span>doca_rdma_task_remote_net_sync_event_notify_add_get_add_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> uint64_t doca_rdma_task_remote_net_sync_event_notify_add_get_add_data </td>
          <td>(</td>
          <td class="paramtype">const struct doca_rdma_task_remote_net_sync_event_notify_add *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method gets the add data of a remote_net_sync_event_notify_add task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task that should be queried.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The task's add_data. </dd></dl>

</div>
</div>
<a id="ga2b2f1f1b90f44088a0e8f894c8874247"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b2f1f1b90f44088a0e8f894c8874247">&#9670;&nbsp;</a></span>doca_rdma_task_remote_net_sync_event_notify_add_get_rdma_connection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> const struct doca_rdma_connection* doca_rdma_task_remote_net_sync_event_notify_add_get_rdma_connection </td>
          <td>(</td>
          <td class="paramtype">const struct doca_rdma_task_remote_net_sync_event_notify_add *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method gets the rdma connection of a remote_net_sync_event_notify_add task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task that should be queried.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The task's rdma connection. </dd></dl>

</div>
</div>
<a id="ga3215f32c3153263dc9eb495e03372d0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3215f32c3153263dc9eb495e03372d0d">&#9670;&nbsp;</a></span>doca_rdma_task_remote_net_sync_event_notify_add_get_result_buf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> struct doca_buf* doca_rdma_task_remote_net_sync_event_notify_add_get_result_buf </td>
          <td>(</td>
          <td class="paramtype">const struct doca_rdma_task_remote_net_sync_event_notify_add *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method gets the result buffer of a remote_net_sync_event_notify_add task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task that should be queried.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The task's result_buf. </dd></dl>

</div>
</div>
<a id="ga2c9194a38d57cf27eaf5108ff4af8af5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c9194a38d57cf27eaf5108ff4af8af5">&#9670;&nbsp;</a></span>doca_rdma_task_remote_net_sync_event_notify_add_get_sync_event()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> struct doca_sync_event_remote_net* doca_rdma_task_remote_net_sync_event_notify_add_get_sync_event </td>
          <td>(</td>
          <td class="paramtype">const struct doca_rdma_task_remote_net_sync_event_notify_add *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method gets the remote sync event of a remote_net_sync_event_notify_add task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task that should be queried.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The task's sync event. </dd></dl>

</div>
</div>
<a id="gadc75fd226a5a5ddf94fb7f4afee129a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc75fd226a5a5ddf94fb7f4afee129a5">&#9670;&nbsp;</a></span>doca_rdma_task_remote_net_sync_event_notify_add_set_add_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> void doca_rdma_task_remote_net_sync_event_notify_add_set_add_data </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma_task_remote_net_sync_event_notify_add *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>add_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method sets the add data of a remote_net_sync_event_notify_add task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task to set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">add_data</td><td>An 8-byte value that will be atomically added to the remote sync event. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8b986b64cdf675eb0d02481b4a60f63f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b986b64cdf675eb0d02481b4a60f63f">&#9670;&nbsp;</a></span>doca_rdma_task_remote_net_sync_event_notify_add_set_conf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_rdma_task_remote_net_sync_event_notify_add_set_conf </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma *&#160;</td>
          <td class="paramname"><em>rdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DOCA__RDMA.html#ga17916c135eaba7a8bc303a5cc072e9dd">doca_rdma_task_remote_net_sync_event_notify_add_completion_cb_t</a>&#160;</td>
          <td class="paramname"><em>successful_task_completion_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DOCA__RDMA.html#ga17916c135eaba7a8bc303a5cc072e9dd">doca_rdma_task_remote_net_sync_event_notify_add_completion_cb_t</a>&#160;</td>
          <td class="paramname"><em>error_task_completion_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num_tasks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method sets the remote_net_sync_event_notify_add tasks configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rdma</td><td>The RDMA instance to config. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">successful_task_completion_cb</td><td>A callback function for remote_net_sync_event_notify_add tasks that were completed successfully. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">error_task_completion_cb</td><td>A callback function for remote_net_sync_event_notify_add tasks that were completed with an error. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_tasks</td><td>Number of remote_net_sync_event_notify_add tasks.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input.</li>
<li>DOCA_ERROR_BAD_STATE - the RDMA instance is not idle. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gacc5e82533e3a0c7f0eb20561600a4bf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc5e82533e3a0c7f0eb20561600a4bf3">&#9670;&nbsp;</a></span>doca_rdma_task_remote_net_sync_event_notify_add_set_rdma_connection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> void doca_rdma_task_remote_net_sync_event_notify_add_set_rdma_connection </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma_task_remote_net_sync_event_notify_add *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct doca_rdma_connection *&#160;</td>
          <td class="paramname"><em>rdma_connection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method sets the rdma_connection of a remote_net_sync_event_notify_add task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task to set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rdma_connection</td><td>RDMA Connection to use on this task </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3690d671a911fd781a04db8ec1c2dcb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3690d671a911fd781a04db8ec1c2dcb8">&#9670;&nbsp;</a></span>doca_rdma_task_remote_net_sync_event_notify_add_set_result_buf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> void doca_rdma_task_remote_net_sync_event_notify_add_set_result_buf </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma_task_remote_net_sync_event_notify_add *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct doca_buf *&#160;</td>
          <td class="paramname"><em>result_buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method sets the result buffer of a remote_net_sync_event_notify_add task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task to set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">result_buf</td><td>Local buffer, to which the original remote sync event value (before the addition) will be written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>buffer lists are not supported for result_buf, only the head will be considered for this task. </dd></dl>

</div>
</div>
<a id="gaeebf3b6e82949e34ad64a639520f51bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeebf3b6e82949e34ad64a639520f51bf">&#9670;&nbsp;</a></span>doca_rdma_task_remote_net_sync_event_notify_add_set_sync_event()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> void doca_rdma_task_remote_net_sync_event_notify_add_set_sync_event </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma_task_remote_net_sync_event_notify_add *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct doca_sync_event_remote_net *&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method sets the remote sync event of a remote_net_sync_event_notify_add task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task to set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>The remote sync event to increment atomically. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab3fb0b4fbd57f752d6d6fda6b32563b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3fb0b4fbd57f752d6d6fda6b32563b2">&#9670;&nbsp;</a></span>doca_rdma_task_remote_net_sync_event_notify_set_allocate_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_rdma_task_remote_net_sync_event_notify_set_allocate_init </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma *&#160;</td>
          <td class="paramname"><em>rdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct doca_rdma_connection *&#160;</td>
          <td class="paramname"><em>rdma_connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct doca_sync_event_remote_net *&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct doca_buf *&#160;</td>
          <td class="paramname"><em>src_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">union <a class="el" href="uniondoca__data.html">doca_data</a>&#160;</td>
          <td class="paramname"><em>user_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct doca_rdma_task_remote_net_sync_event_notify_set **&#160;</td>
          <td class="paramname"><em>task</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method allocates and initializes a remote_net_sync_event_notify_set task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rdma</td><td>The RDMA instance to allocate the task for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rdma_connection</td><td>Connection related data required for doca_rdma to connect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>The remote sync event to set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src_buf</td><td>Local source buffer, holding the value to set the remote net sync event to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>src_buf may be linked to other buffers, with a limit according to the max_send_buf_list_len property that can be set or queried using <a class="el" href="group__DOCA__RDMA.html#gafdc92935ee7fad23891df4213341fc04" title="Set the maximum buffer list length property for local buffers of tasks that are sent to the remote an...">doca_rdma_set_max_send_buf_list_len()</a> \ <a class="el" href="group__DOCA__RDMA.html#gad7948de5b8a3439c14324cf74be37543" title="Get the maximum buffer list length property for local buffers of tasks that are sent to the remote an...">doca_rdma_get_max_send_buf_list_len()</a> respectfully. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">user_data</td><td><a class="el" href="uniondoca__data.html" title="Convenience type for representing opaque data.">doca_data</a> to attach to the task. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">task</td><td>On success, an allocated and initialized a remote_net_sync_event_notify_set task.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input.</li>
<li>DOCA_ERROR_NO_MEMORY - no more tasks to allocate. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga05c1965b0138773884f0d75df1c99124"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga05c1965b0138773884f0d75df1c99124">&#9670;&nbsp;</a></span>doca_rdma_task_remote_net_sync_event_notify_set_as_task()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> struct doca_task* doca_rdma_task_remote_net_sync_event_notify_set_as_task </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma_task_remote_net_sync_event_notify_set *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method converts a remote_net_sync_event_notify_set task to a doca_task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task that should be converted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The remote_net_sync_event_notify_set task converted to doca_task. </dd></dl>

</div>
</div>
<a id="ga9e724c8da80470d2c0bc5ef5f209e7e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9e724c8da80470d2c0bc5ef5f209e7e3">&#9670;&nbsp;</a></span>doca_rdma_task_remote_net_sync_event_notify_set_get_rdma_connection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> const struct doca_rdma_connection* doca_rdma_task_remote_net_sync_event_notify_set_get_rdma_connection </td>
          <td>(</td>
          <td class="paramtype">const struct doca_rdma_task_remote_net_sync_event_notify_set *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method gets the rdma connection of a remote_net_sync_event_notify_set task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task that should be queried.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The task's rdma connection. </dd></dl>

</div>
</div>
<a id="ga3edf5dbb66f3762a3c7bb70def13dc5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3edf5dbb66f3762a3c7bb70def13dc5d">&#9670;&nbsp;</a></span>doca_rdma_task_remote_net_sync_event_notify_set_get_src_buf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> const struct doca_buf* doca_rdma_task_remote_net_sync_event_notify_set_get_src_buf </td>
          <td>(</td>
          <td class="paramtype">const struct doca_rdma_task_remote_net_sync_event_notify_set *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method gets the source buffer of a remote_net_sync_event_notify_set task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task that should be queried.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The task's src_buf. </dd></dl>

</div>
</div>
<a id="ga14ca6986df0b342d65ced56d5f4afc91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga14ca6986df0b342d65ced56d5f4afc91">&#9670;&nbsp;</a></span>doca_rdma_task_remote_net_sync_event_notify_set_get_sync_event()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> struct doca_sync_event_remote_net* doca_rdma_task_remote_net_sync_event_notify_set_get_sync_event </td>
          <td>(</td>
          <td class="paramtype">const struct doca_rdma_task_remote_net_sync_event_notify_set *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method gets the remote net sync event of a remote_net_sync_event_notify_set task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task that should be queried.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The task's remote net sync event. </dd></dl>

</div>
</div>
<a id="ga98ea421f84b7c744bb72ef7fbc5f5129"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga98ea421f84b7c744bb72ef7fbc5f5129">&#9670;&nbsp;</a></span>doca_rdma_task_remote_net_sync_event_notify_set_set_conf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_rdma_task_remote_net_sync_event_notify_set_set_conf </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma *&#160;</td>
          <td class="paramname"><em>rdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DOCA__RDMA.html#ga856a75fbd80e9fda88005b6012fd3d52">doca_rdma_task_remote_net_sync_event_notify_set_completion_cb_t</a>&#160;</td>
          <td class="paramname"><em>successful_task_completion_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DOCA__RDMA.html#ga856a75fbd80e9fda88005b6012fd3d52">doca_rdma_task_remote_net_sync_event_notify_set_completion_cb_t</a>&#160;</td>
          <td class="paramname"><em>error_task_completion_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num_tasks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method sets the remote_net_sync_event_notify_set tasks configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rdma</td><td>The RDMA instance to config. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">successful_task_completion_cb</td><td>A callback function for remote_net_sync_event_notify_set tasks that were completed successfully. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">error_task_completion_cb</td><td>A callback function for remote_net_sync_event_notify_set tasks that were completed with an error. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_tasks</td><td>Number of remote_net_sync_event_notify_set tasks.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input.</li>
<li>DOCA_ERROR_BAD_STATE - the RDMA instance is not idle. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gacf6a4d5bc43cba86657998053e635008"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacf6a4d5bc43cba86657998053e635008">&#9670;&nbsp;</a></span>doca_rdma_task_remote_net_sync_event_notify_set_set_rdma_connection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> void doca_rdma_task_remote_net_sync_event_notify_set_set_rdma_connection </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma_task_remote_net_sync_event_notify_set *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct doca_rdma_connection *&#160;</td>
          <td class="paramname"><em>rdma_connection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method sets the rdma_connection of a remote_net_sync_event_notify_set task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task to set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rdma_connection</td><td>RDMA Connection to use on this task </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab7306242c3b607e00566d4c393bfad02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab7306242c3b607e00566d4c393bfad02">&#9670;&nbsp;</a></span>doca_rdma_task_remote_net_sync_event_notify_set_set_src_buf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> void doca_rdma_task_remote_net_sync_event_notify_set_set_src_buf </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma_task_remote_net_sync_event_notify_set *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct doca_buf *&#160;</td>
          <td class="paramname"><em>src_buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method sets the source buffer of a remote_net_sync_event_notify_set task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task to set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src_buf</td><td>Local source buffer, holding the value to set the remote net sync event to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga92e1d705ece2917bf3561e6329648ed7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga92e1d705ece2917bf3561e6329648ed7">&#9670;&nbsp;</a></span>doca_rdma_task_remote_net_sync_event_notify_set_set_sync_event()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> void doca_rdma_task_remote_net_sync_event_notify_set_set_sync_event </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma_task_remote_net_sync_event_notify_set *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct doca_sync_event_remote_net *&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method sets the remote net sync event of a remote_net_sync_event_notify_set task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task to set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>The remote net sync event to set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaced6b369d13e033006d9061e9ebb9745"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaced6b369d13e033006d9061e9ebb9745">&#9670;&nbsp;</a></span>doca_rdma_task_send_allocate_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_rdma_task_send_allocate_init </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma *&#160;</td>
          <td class="paramname"><em>rdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct doca_rdma_connection *&#160;</td>
          <td class="paramname"><em>rdma_connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct doca_buf *&#160;</td>
          <td class="paramname"><em>src_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">union <a class="el" href="uniondoca__data.html">doca_data</a>&#160;</td>
          <td class="paramname"><em>user_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct doca_rdma_task_send **&#160;</td>
          <td class="paramname"><em>task</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method allocates and initializes a send task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rdma</td><td>The RDMA instance to allocate the task for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rdma_connection</td><td>Connection related data required for doca_rdma to connect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src_buf</td><td>Local source buffer, with the data to be sent. May be NULL when wishing to send an empty message (without data). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>src_buf may be linked to other buffers, with a limit according to the max_send_buf_list_len property that can be set or queried using <a class="el" href="group__DOCA__RDMA.html#gafdc92935ee7fad23891df4213341fc04" title="Set the maximum buffer list length property for local buffers of tasks that are sent to the remote an...">doca_rdma_set_max_send_buf_list_len()</a> \ <a class="el" href="group__DOCA__RDMA.html#gad7948de5b8a3439c14324cf74be37543" title="Get the maximum buffer list length property for local buffers of tasks that are sent to the remote an...">doca_rdma_get_max_send_buf_list_len()</a> respectfully. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">user_data</td><td><a class="el" href="uniondoca__data.html" title="Convenience type for representing opaque data.">doca_data</a> to attach to the task. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">task</td><td>On success, an allocated and initialized a send task.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input.</li>
<li>DOCA_ERROR_NO_MEMORY - no more tasks to allocate. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga8c1347cb733ff6372d7cc2d58ef8379d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c1347cb733ff6372d7cc2d58ef8379d">&#9670;&nbsp;</a></span>doca_rdma_task_send_as_task()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> struct doca_task* doca_rdma_task_send_as_task </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma_task_send *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method converts a send task to a doca_task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task that should be converted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The send task converted to doca_task. </dd></dl>

</div>
</div>
<a id="ga3d5c195fa2b645a2a33374db759af72f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d5c195fa2b645a2a33374db759af72f">&#9670;&nbsp;</a></span>doca_rdma_task_send_get_rdma_connection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> const struct doca_rdma_connection* doca_rdma_task_send_get_rdma_connection </td>
          <td>(</td>
          <td class="paramtype">const struct doca_rdma_task_send *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method gets the rdma connection of a send task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task that should be queried.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The task's rdma connection. </dd></dl>

</div>
</div>
<a id="ga3e1187c092b6deb22d8e49301ddde1d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3e1187c092b6deb22d8e49301ddde1d5">&#9670;&nbsp;</a></span>doca_rdma_task_send_get_src_buf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> const struct doca_buf* doca_rdma_task_send_get_src_buf </td>
          <td>(</td>
          <td class="paramtype">const struct doca_rdma_task_send *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method gets the source buffer of a send task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task that should be queried.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The task's src_buf. </dd></dl>

</div>
</div>
<a id="ga1873254f7307b4ab29576db45208878d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1873254f7307b4ab29576db45208878d">&#9670;&nbsp;</a></span>doca_rdma_task_send_imm_allocate_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_rdma_task_send_imm_allocate_init </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma *&#160;</td>
          <td class="paramname"><em>rdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct doca_rdma_connection *&#160;</td>
          <td class="paramname"><em>rdma_connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct doca_buf *&#160;</td>
          <td class="paramname"><em>src_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DOCA__TYPES.html#ga37ca3c7aed1aadba64e71712ea0e069f">doca_be32_t</a>&#160;</td>
          <td class="paramname"><em>immediate_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">union <a class="el" href="uniondoca__data.html">doca_data</a>&#160;</td>
          <td class="paramname"><em>user_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct doca_rdma_task_send_imm **&#160;</td>
          <td class="paramname"><em>task</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method allocates and initializes a send with immediate task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rdma</td><td>The RDMA instance to allocate the task for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rdma_connection</td><td>Connection related data required for doca_rdma to connect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src_buf</td><td>Local source buffer, with the data to be sent. May be NULL when wishing to send an empty message (without data). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>src_buf may be linked to other buffers, with a limit according to the max_send_buf_list_len property that can be set or queried using <a class="el" href="group__DOCA__RDMA.html#gafdc92935ee7fad23891df4213341fc04" title="Set the maximum buffer list length property for local buffers of tasks that are sent to the remote an...">doca_rdma_set_max_send_buf_list_len()</a> \ <a class="el" href="group__DOCA__RDMA.html#gad7948de5b8a3439c14324cf74be37543" title="Get the maximum buffer list length property for local buffers of tasks that are sent to the remote an...">doca_rdma_get_max_send_buf_list_len()</a> respectfully. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">immediate_data</td><td>A 32-bit value, in Big-Endian, to be sent OOB to the peer along with the message. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user_data</td><td><a class="el" href="uniondoca__data.html" title="Convenience type for representing opaque data.">doca_data</a> to attach to the task. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">task</td><td>On success, an allocated and initialized a send with immediate task.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input.</li>
<li>DOCA_ERROR_NO_MEMORY - no more tasks to allocate. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga394ca996da1e5413ede353c63932869d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga394ca996da1e5413ede353c63932869d">&#9670;&nbsp;</a></span>doca_rdma_task_send_imm_as_task()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> struct doca_task* doca_rdma_task_send_imm_as_task </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma_task_send_imm *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method converts a send with immediate task to a doca_task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task that should be converted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The send with immediate task converted to doca_task. </dd></dl>

</div>
</div>
<a id="ga724b865451587721499c1fcbb6f10df8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga724b865451587721499c1fcbb6f10df8">&#9670;&nbsp;</a></span>doca_rdma_task_send_imm_get_immediate_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__TYPES.html#ga37ca3c7aed1aadba64e71712ea0e069f">doca_be32_t</a> doca_rdma_task_send_imm_get_immediate_data </td>
          <td>(</td>
          <td class="paramtype">const struct doca_rdma_task_send_imm *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method gets the immediate data of a send with immediate task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task that should be queried.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The task's immediate_data. </dd></dl>

</div>
</div>
<a id="ga0d64bdb6b7f4813ad9cb4565d722771b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d64bdb6b7f4813ad9cb4565d722771b">&#9670;&nbsp;</a></span>doca_rdma_task_send_imm_get_rdma_connection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> const struct doca_rdma_connection* doca_rdma_task_send_imm_get_rdma_connection </td>
          <td>(</td>
          <td class="paramtype">const struct doca_rdma_task_send_imm *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method gets the rdma connection of a send with immediate task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task that should be queried.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The task's rdma connection. </dd></dl>

</div>
</div>
<a id="gaad558ab87c69e6c9a98b91e366cd1f3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad558ab87c69e6c9a98b91e366cd1f3d">&#9670;&nbsp;</a></span>doca_rdma_task_send_imm_get_src_buf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> const struct doca_buf* doca_rdma_task_send_imm_get_src_buf </td>
          <td>(</td>
          <td class="paramtype">const struct doca_rdma_task_send_imm *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method gets the source buffer of a send with immediate task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task that should be queried.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The task's src_buf. </dd></dl>

</div>
</div>
<a id="ga655423e7adf87dcb3e42127acc5e0c9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga655423e7adf87dcb3e42127acc5e0c9a">&#9670;&nbsp;</a></span>doca_rdma_task_send_imm_set_conf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_rdma_task_send_imm_set_conf </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma *&#160;</td>
          <td class="paramname"><em>rdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DOCA__RDMA.html#ga86fa09af84fd6b25a24ba2e64e8d0360">doca_rdma_task_send_imm_completion_cb_t</a>&#160;</td>
          <td class="paramname"><em>successful_task_completion_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DOCA__RDMA.html#ga86fa09af84fd6b25a24ba2e64e8d0360">doca_rdma_task_send_imm_completion_cb_t</a>&#160;</td>
          <td class="paramname"><em>error_task_completion_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num_tasks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method sets the send with immediate tasks configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rdma</td><td>The RDMA instance to config. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">successful_task_completion_cb</td><td>A callback function for send with immediate tasks that were completed successfully. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">error_task_completion_cb</td><td>A callback function for send with immediate tasks that were completed with an error. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_tasks</td><td>Number of send with immediate tasks.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input.</li>
<li>DOCA_ERROR_BAD_STATE - the RDMA instance is not idle. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaec5cebb393ee713a7080b11f4fbffb1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec5cebb393ee713a7080b11f4fbffb1d">&#9670;&nbsp;</a></span>doca_rdma_task_send_imm_set_immediate_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> void doca_rdma_task_send_imm_set_immediate_data </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma_task_send_imm *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DOCA__TYPES.html#ga37ca3c7aed1aadba64e71712ea0e069f">doca_be32_t</a>&#160;</td>
          <td class="paramname"><em>immediate_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method sets the immediate data of a send with immediate task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task to set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">immediate_data</td><td>A 32-bit value, in Big-Endian, to be sent OOB to the peer along with the message. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7566d48addd132b1f338036ae6928071"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7566d48addd132b1f338036ae6928071">&#9670;&nbsp;</a></span>doca_rdma_task_send_imm_set_rdma_connection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> void doca_rdma_task_send_imm_set_rdma_connection </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma_task_send_imm *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct doca_rdma_connection *&#160;</td>
          <td class="paramname"><em>rdma_connection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method sets the rdma_connection of a send with immediate task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task to set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rdma_connection</td><td>RDMA Connection to use on this task </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacd620c2fd40f4f1d4a3400988430f9f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd620c2fd40f4f1d4a3400988430f9f1">&#9670;&nbsp;</a></span>doca_rdma_task_send_imm_set_src_buf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> void doca_rdma_task_send_imm_set_src_buf </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma_task_send_imm *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct doca_buf *&#160;</td>
          <td class="paramname"><em>src_buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method sets the source buffer of a send with immediate task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task to set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src_buf</td><td>Local source buffer, with the data to be sent. May be NULL when wishing to send an empty message (without data). If the source buffer is not set by the user, it will have a default value - NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>src_buf may be linked to other buffers, with a limit according to the max_send_buf_list_len property that can be set or queried using <a class="el" href="group__DOCA__RDMA.html#gafdc92935ee7fad23891df4213341fc04" title="Set the maximum buffer list length property for local buffers of tasks that are sent to the remote an...">doca_rdma_set_max_send_buf_list_len()</a> \ <a class="el" href="group__DOCA__RDMA.html#gad7948de5b8a3439c14324cf74be37543" title="Get the maximum buffer list length property for local buffers of tasks that are sent to the remote an...">doca_rdma_get_max_send_buf_list_len()</a> respectfully. </dd></dl>

</div>
</div>
<a id="ga15606de845e3940374c61c1a5a7a5782"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15606de845e3940374c61c1a5a7a5782">&#9670;&nbsp;</a></span>doca_rdma_task_send_set_conf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_rdma_task_send_set_conf </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma *&#160;</td>
          <td class="paramname"><em>rdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DOCA__RDMA.html#ga8e87e2039e435abe52200598623f0cac">doca_rdma_task_send_completion_cb_t</a>&#160;</td>
          <td class="paramname"><em>successful_task_completion_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DOCA__RDMA.html#ga8e87e2039e435abe52200598623f0cac">doca_rdma_task_send_completion_cb_t</a>&#160;</td>
          <td class="paramname"><em>error_task_completion_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num_tasks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method sets the send tasks configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rdma</td><td>The RDMA instance to config. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">successful_task_completion_cb</td><td>A callback function for send tasks that were completed successfully. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">error_task_completion_cb</td><td>A callback function for send tasks that were completed with an error. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_tasks</td><td>Number of send tasks.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input.</li>
<li>DOCA_ERROR_BAD_STATE - the RDMA instance is not idle. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga9c09c589aae170ae6185dda475b9e135"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c09c589aae170ae6185dda475b9e135">&#9670;&nbsp;</a></span>doca_rdma_task_send_set_rdma_connection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> void doca_rdma_task_send_set_rdma_connection </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma_task_send *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct doca_rdma_connection *&#160;</td>
          <td class="paramname"><em>rdma_connection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method sets the rdma_connection of a send task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task to set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rdma_connection</td><td>RDMA Connection to use on this task </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4fcf031d9e8fd7292a4a225b6aaadd7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4fcf031d9e8fd7292a4a225b6aaadd7e">&#9670;&nbsp;</a></span>doca_rdma_task_send_set_src_buf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> void doca_rdma_task_send_set_src_buf </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma_task_send *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct doca_buf *&#160;</td>
          <td class="paramname"><em>src_buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method sets the source buffer of a send task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task to set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src_buf</td><td>Local source buffer, with the data to be sent. May be NULL when wishing to send an empty message (without data). If the source buffer is not set by the user, it will have a default value - NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>src_buf may be linked to other buffers, with a limit according to the max_send_buf_list_len property that can be set or queried using <a class="el" href="group__DOCA__RDMA.html#gafdc92935ee7fad23891df4213341fc04" title="Set the maximum buffer list length property for local buffers of tasks that are sent to the remote an...">doca_rdma_set_max_send_buf_list_len()</a> \ <a class="el" href="group__DOCA__RDMA.html#gad7948de5b8a3439c14324cf74be37543" title="Get the maximum buffer list length property for local buffers of tasks that are sent to the remote an...">doca_rdma_get_max_send_buf_list_len()</a> respectfully. </dd></dl>

</div>
</div>
<a id="gaef1a6ed8577a70425ae60fa56b907261"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef1a6ed8577a70425ae60fa56b907261">&#9670;&nbsp;</a></span>doca_rdma_task_write_allocate_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_rdma_task_write_allocate_init </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma *&#160;</td>
          <td class="paramname"><em>rdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct doca_rdma_connection *&#160;</td>
          <td class="paramname"><em>rdma_connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct doca_buf *&#160;</td>
          <td class="paramname"><em>src_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct doca_buf *&#160;</td>
          <td class="paramname"><em>dst_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">union <a class="el" href="uniondoca__data.html">doca_data</a>&#160;</td>
          <td class="paramname"><em>user_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct doca_rdma_task_write **&#160;</td>
          <td class="paramname"><em>task</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method allocates and initializes a write task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rdma</td><td>The RDMA instance to allocate the task for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rdma_connection</td><td>Connection related data required for doca_rdma to connect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src_buf</td><td>Local source buffer, holding the data that should be written to the remote memory. May be NULL when wishing to write no data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>src_buf may be linked to other buffers, with a limit according to the max_send_buf_list_len property that can be set or queried using <a class="el" href="group__DOCA__RDMA.html#gafdc92935ee7fad23891df4213341fc04" title="Set the maximum buffer list length property for local buffers of tasks that are sent to the remote an...">doca_rdma_set_max_send_buf_list_len()</a> \ <a class="el" href="group__DOCA__RDMA.html#gad7948de5b8a3439c14324cf74be37543" title="Get the maximum buffer list length property for local buffers of tasks that are sent to the remote an...">doca_rdma_get_max_send_buf_list_len()</a> respectfully. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dst_buf</td><td>Remote destination buffer, to which the data will be written. May be NULL when src_buf is NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>buffer lists are not supported for dst_buf, only the head will be considered for this task. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">user_data</td><td><a class="el" href="uniondoca__data.html" title="Convenience type for representing opaque data.">doca_data</a> to attach to the task. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">task</td><td>On success, an allocated and initialized a write task.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input.</li>
<li>DOCA_ERROR_NO_MEMORY - no more tasks to allocate. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga52848023475d133b0bfc9db8b24bd05b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga52848023475d133b0bfc9db8b24bd05b">&#9670;&nbsp;</a></span>doca_rdma_task_write_as_task()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> struct doca_task* doca_rdma_task_write_as_task </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma_task_write *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method converts a write task to a doca_task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task that should be converted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The write task converted to doca_task. </dd></dl>

</div>
</div>
<a id="ga0550fb803829645be2523d86553f6447"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0550fb803829645be2523d86553f6447">&#9670;&nbsp;</a></span>doca_rdma_task_write_get_dst_buf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> struct doca_buf* doca_rdma_task_write_get_dst_buf </td>
          <td>(</td>
          <td class="paramtype">const struct doca_rdma_task_write *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method gets the destination buffer of a write task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task that should be queried.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The task's dst_buf. </dd></dl>

</div>
</div>
<a id="gadeaf1b91b40e2eec573c4305c5991ecd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadeaf1b91b40e2eec573c4305c5991ecd">&#9670;&nbsp;</a></span>doca_rdma_task_write_get_rdma_connection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> const struct doca_rdma_connection* doca_rdma_task_write_get_rdma_connection </td>
          <td>(</td>
          <td class="paramtype">const struct doca_rdma_task_write *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method gets the rdma connection of a write task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task that should be queried.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The task's rdma connection. </dd></dl>

</div>
</div>
<a id="ga3136356950e85c4c0fd0f3a3a283a1e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3136356950e85c4c0fd0f3a3a283a1e7">&#9670;&nbsp;</a></span>doca_rdma_task_write_get_src_buf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> const struct doca_buf* doca_rdma_task_write_get_src_buf </td>
          <td>(</td>
          <td class="paramtype">const struct doca_rdma_task_write *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method gets the source buffer of a write task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task that should be queried.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The task's src_buf. </dd></dl>

</div>
</div>
<a id="ga218b303b2e79d682d52e5383b516bd86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga218b303b2e79d682d52e5383b516bd86">&#9670;&nbsp;</a></span>doca_rdma_task_write_imm_allocate_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_rdma_task_write_imm_allocate_init </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma *&#160;</td>
          <td class="paramname"><em>rdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct doca_rdma_connection *&#160;</td>
          <td class="paramname"><em>rdma_connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct doca_buf *&#160;</td>
          <td class="paramname"><em>src_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct doca_buf *&#160;</td>
          <td class="paramname"><em>dst_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DOCA__TYPES.html#ga37ca3c7aed1aadba64e71712ea0e069f">doca_be32_t</a>&#160;</td>
          <td class="paramname"><em>immediate_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">union <a class="el" href="uniondoca__data.html">doca_data</a>&#160;</td>
          <td class="paramname"><em>user_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct doca_rdma_task_write_imm **&#160;</td>
          <td class="paramname"><em>task</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method allocates and initializes a write with immediate task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rdma</td><td>The RDMA instance to allocate the task for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rdma_connection</td><td>Connection related data required for doca_rdma to connect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src_buf</td><td>Local source buffer, holding the data that should be written to the remote memory. May be NULL when wishing to write no data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>src_buf may be linked to other buffers, with a limit according to the max_send_buf_list_len property that can be set or queried using <a class="el" href="group__DOCA__RDMA.html#gafdc92935ee7fad23891df4213341fc04" title="Set the maximum buffer list length property for local buffers of tasks that are sent to the remote an...">doca_rdma_set_max_send_buf_list_len()</a> \ <a class="el" href="group__DOCA__RDMA.html#gad7948de5b8a3439c14324cf74be37543" title="Get the maximum buffer list length property for local buffers of tasks that are sent to the remote an...">doca_rdma_get_max_send_buf_list_len()</a> respectfully. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dst_buf</td><td>Remote destination buffer, to which the data will be written. May be NULL when src_buf is NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>buffer lists are not supported for dst_buf, only the head will be considered for this task. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">immediate_data</td><td>A 32-bit value, in Big-Endian, to be sent OOB to the peer along with the write data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user_data</td><td><a class="el" href="uniondoca__data.html" title="Convenience type for representing opaque data.">doca_data</a> to attach to the task. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">task</td><td>On success, an allocated and initialized a write with immediate task.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input.</li>
<li>DOCA_ERROR_NO_MEMORY - no more tasks to allocate. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga3b255391c608b943f2e96c06a1ea820d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b255391c608b943f2e96c06a1ea820d">&#9670;&nbsp;</a></span>doca_rdma_task_write_imm_as_task()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> struct doca_task* doca_rdma_task_write_imm_as_task </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma_task_write_imm *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method converts a write with immediate task to a doca_task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task that should be converted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The write with immediate task converted to doca_task. </dd></dl>

</div>
</div>
<a id="ga5ebb2a0eaf61176bdc464b4f7093d3f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ebb2a0eaf61176bdc464b4f7093d3f8">&#9670;&nbsp;</a></span>doca_rdma_task_write_imm_get_dst_buf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> struct doca_buf* doca_rdma_task_write_imm_get_dst_buf </td>
          <td>(</td>
          <td class="paramtype">const struct doca_rdma_task_write_imm *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method gets the destination buffer of a write with immediate task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task that should be queried.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The task's dst_buf. </dd></dl>

</div>
</div>
<a id="gab58c998388a4166b222ff0e573013f85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab58c998388a4166b222ff0e573013f85">&#9670;&nbsp;</a></span>doca_rdma_task_write_imm_get_immediate_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__TYPES.html#ga37ca3c7aed1aadba64e71712ea0e069f">doca_be32_t</a> doca_rdma_task_write_imm_get_immediate_data </td>
          <td>(</td>
          <td class="paramtype">const struct doca_rdma_task_write_imm *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method gets the immediate data of a write with immediate task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task that should be queried.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The task's immediate_data. </dd></dl>

</div>
</div>
<a id="gafe5a4ae4929381592e44751b32480315"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe5a4ae4929381592e44751b32480315">&#9670;&nbsp;</a></span>doca_rdma_task_write_imm_get_rdma_connection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> const struct doca_rdma_connection* doca_rdma_task_write_imm_get_rdma_connection </td>
          <td>(</td>
          <td class="paramtype">const struct doca_rdma_task_write_imm *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method gets the rdma connection of a write with immediate task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task that should be queried.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The task's rdma connection. </dd></dl>

</div>
</div>
<a id="ga78af9693f1514cc330a3a0cef849762a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga78af9693f1514cc330a3a0cef849762a">&#9670;&nbsp;</a></span>doca_rdma_task_write_imm_get_src_buf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> const struct doca_buf* doca_rdma_task_write_imm_get_src_buf </td>
          <td>(</td>
          <td class="paramtype">const struct doca_rdma_task_write_imm *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method gets the source buffer of a write with immediate task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task that should be queried.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The task's src_buf. </dd></dl>

</div>
</div>
<a id="ga1fe338e727493a8bbd9ec5ab11255397"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1fe338e727493a8bbd9ec5ab11255397">&#9670;&nbsp;</a></span>doca_rdma_task_write_imm_set_conf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_rdma_task_write_imm_set_conf </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma *&#160;</td>
          <td class="paramname"><em>rdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DOCA__RDMA.html#gaf46528474ecc323adb02c804fca60edc">doca_rdma_task_write_imm_completion_cb_t</a>&#160;</td>
          <td class="paramname"><em>successful_task_completion_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DOCA__RDMA.html#gaf46528474ecc323adb02c804fca60edc">doca_rdma_task_write_imm_completion_cb_t</a>&#160;</td>
          <td class="paramname"><em>error_task_completion_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num_tasks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method sets the write with immediate tasks configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rdma</td><td>The RDMA instance to config. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">successful_task_completion_cb</td><td>A callback function for write with immediate tasks that were completed successfully. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">error_task_completion_cb</td><td>A callback function for write with immediate tasks that were completed with an error. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_tasks</td><td>Number of write with immediate tasks.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input.</li>
<li>DOCA_ERROR_BAD_STATE - the RDMA instance is not idle. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga1271e7025aba75712723504044e160b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1271e7025aba75712723504044e160b8">&#9670;&nbsp;</a></span>doca_rdma_task_write_imm_set_dst_buf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> void doca_rdma_task_write_imm_set_dst_buf </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma_task_write_imm *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct doca_buf *&#160;</td>
          <td class="paramname"><em>dst_buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method sets the destination buffer of a write with immediate task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task to set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dst_buf</td><td>Remote destination buffer, to which the data will be written. May be NULL when src_buf is NULL. If the destination buffer is not set by the user, it will have a default value - NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>buffer lists are not supported for dst_buf, only the head will be considered for this task. </dd></dl>

</div>
</div>
<a id="ga1b5d19c55aacc909c97660b5f07c4ce5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b5d19c55aacc909c97660b5f07c4ce5">&#9670;&nbsp;</a></span>doca_rdma_task_write_imm_set_immediate_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> void doca_rdma_task_write_imm_set_immediate_data </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma_task_write_imm *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DOCA__TYPES.html#ga37ca3c7aed1aadba64e71712ea0e069f">doca_be32_t</a>&#160;</td>
          <td class="paramname"><em>immediate_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method sets the immediate data of a write with immediate task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task to set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">immediate_data</td><td>A 32-bit value, in Big-Endian, to be sent OOB to the peer along with the write data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9f6cf6f24974f3d6cf10a25ebee2f2a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f6cf6f24974f3d6cf10a25ebee2f2a4">&#9670;&nbsp;</a></span>doca_rdma_task_write_imm_set_rdma_connection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> void doca_rdma_task_write_imm_set_rdma_connection </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma_task_write_imm *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct doca_rdma_connection *&#160;</td>
          <td class="paramname"><em>rdma_connection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method sets the rdma connection of a write with immediate task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task to set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rdma_connection</td><td>RDMA Connection to use on this task </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaad8adb2ba7444d5c1ffe3ecebd78e23f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad8adb2ba7444d5c1ffe3ecebd78e23f">&#9670;&nbsp;</a></span>doca_rdma_task_write_imm_set_src_buf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> void doca_rdma_task_write_imm_set_src_buf </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma_task_write_imm *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct doca_buf *&#160;</td>
          <td class="paramname"><em>src_buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method sets the source buffer of a write with immediate task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task to set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src_buf</td><td>Local source buffer, holding the data that should be written to the remote memory. May be NULL when wishing to write no data. If the source buffer is not set by the user, it will have a default value - NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>src_buf may be linked to other buffers, with a limit according to the max_send_buf_list_len property that can be set or queried using <a class="el" href="group__DOCA__RDMA.html#gafdc92935ee7fad23891df4213341fc04" title="Set the maximum buffer list length property for local buffers of tasks that are sent to the remote an...">doca_rdma_set_max_send_buf_list_len()</a> \ <a class="el" href="group__DOCA__RDMA.html#gad7948de5b8a3439c14324cf74be37543" title="Get the maximum buffer list length property for local buffers of tasks that are sent to the remote an...">doca_rdma_get_max_send_buf_list_len()</a> respectfully. </dd></dl>

</div>
</div>
<a id="ga6e28a390009e2b6caaf6367aadb8a4a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e28a390009e2b6caaf6367aadb8a4a2">&#9670;&nbsp;</a></span>doca_rdma_task_write_set_conf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_rdma_task_write_set_conf </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma *&#160;</td>
          <td class="paramname"><em>rdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DOCA__RDMA.html#gaf81a8b85901e3017b44eba70873cc322">doca_rdma_task_write_completion_cb_t</a>&#160;</td>
          <td class="paramname"><em>successful_task_completion_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DOCA__RDMA.html#gaf81a8b85901e3017b44eba70873cc322">doca_rdma_task_write_completion_cb_t</a>&#160;</td>
          <td class="paramname"><em>error_task_completion_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num_tasks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method sets the write tasks configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rdma</td><td>The RDMA instance to config. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">successful_task_completion_cb</td><td>A callback function for write tasks that were completed successfully. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">error_task_completion_cb</td><td>A callback function for write tasks that were completed with an error. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_tasks</td><td>Number of write tasks.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success. doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input.</li>
<li>DOCA_ERROR_BAD_STATE - the RDMA instance is not idle. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga3fcb7db4f0a7ff79eabe5905f12e5d89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3fcb7db4f0a7ff79eabe5905f12e5d89">&#9670;&nbsp;</a></span>doca_rdma_task_write_set_dst_buf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> void doca_rdma_task_write_set_dst_buf </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma_task_write *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct doca_buf *&#160;</td>
          <td class="paramname"><em>dst_buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method sets the destination buffer of a write task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task to set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dst_buf</td><td>Remote destination buffer, to which the data will be written. May be NULL when src_buf is NULL. If the destination buffer is not set by the user, it will have a default value - NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>buffer lists are not supported for dst_buf, only the head will be considered for this task. </dd></dl>

</div>
</div>
<a id="ga988da927f00a8cd220f577dc73bb0e2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga988da927f00a8cd220f577dc73bb0e2f">&#9670;&nbsp;</a></span>doca_rdma_task_write_set_rdma_connection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> void doca_rdma_task_write_set_rdma_connection </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma_task_write *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct doca_rdma_connection *&#160;</td>
          <td class="paramname"><em>rdma_connection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method sets the rdma_connection of a write task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task to set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rdma_connection</td><td>RDMA Connection to use on this task </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga514267dcb068edeed17720ae5b8077a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga514267dcb068edeed17720ae5b8077a5">&#9670;&nbsp;</a></span>doca_rdma_task_write_set_src_buf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> void doca_rdma_task_write_set_src_buf </td>
          <td>(</td>
          <td class="paramtype">struct doca_rdma_task_write *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct doca_buf *&#160;</td>
          <td class="paramname"><em>src_buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method sets the source buffer of a write task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>The task to set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src_buf</td><td>Local source buffer, holding the data that should be written to the remote memory. May be NULL when wishing to write no data. If the source buffer is not set by the user, it will have a default value - NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>src_buf may be linked to other buffers, with a limit according to the max_send_buf_list_len property that can be set or queried using <a class="el" href="group__DOCA__RDMA.html#gafdc92935ee7fad23891df4213341fc04" title="Set the maximum buffer list length property for local buffers of tasks that are sent to the remote an...">doca_rdma_set_max_send_buf_list_len()</a> \ <a class="el" href="group__DOCA__RDMA.html#gad7948de5b8a3439c14324cf74be37543" title="Get the maximum buffer list length property for local buffers of tasks that are sent to the remote an...">doca_rdma_get_max_send_buf_list_len()</a> respectfully. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Wed Aug 13 2025 08:00:17 for NVIDIA DOCA SDK by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
