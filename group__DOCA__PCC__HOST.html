<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NVIDIA DOCA SDK: DOCA PCC Host</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<!-- Doxygen Awesome CSS -->
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript">
DoxygenAwesomeDarkModeToggle.init()
DoxygenAwesomeFragmentCopyButton.init()
DoxygenAwesomeParagraphLink.init()
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectname">NVIDIA DOCA SDK
  </td>
  <td id="projectbrief">Data Center on a Chip Framework Documentation</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__DOCA__PCC__HOST.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">DOCA PCC Host<div class="ingroups"><a class="el" href="group__DOCA__PCC.html">DOCA PCC</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for DOCA PCC Host:</div>
<div class="dyncontent">
<div class="center"><img src="group__DOCA__PCC__HOST.png" border="0" usemap="#agroup____DOCA____PCC____HOST" alt=""/></div>
<map name="agroup____DOCA____PCC____HOST" id="agroup____DOCA____PCC____HOST">
<area shape="rect" title=" " alt="" coords="144,5,268,31"/>
<area shape="rect" href="group__DOCA__PCC.html" title=" " alt="" coords="5,5,96,31"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga94175e78d1ec955e5a7780cd4267ba03"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__PCC__HOST.html#ga94175e78d1ec955e5a7780cd4267ba03">doca_pcc_trace_callback_t</a>) (void *<a class="el" href="upf__accel__flow__processing_8h.html#a8b3a0cb2be2fc166f6fa69afa523e3e4">ctx</a>, struct doca_pcc_bin_report *reps, int reps_size)</td></tr>
<tr class="memdesc:ga94175e78d1ec955e5a7780cd4267ba03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tracer user callback, to be defined by user and called when traces are sent by DPA.  <a href="group__DOCA__PCC__HOST.html#ga94175e78d1ec955e5a7780cd4267ba03">More...</a><br /></td></tr>
<tr class="separator:ga94175e78d1ec955e5a7780cd4267ba03"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga2a694bd9ecf9c0560bfd509211c913dc"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__PCC__HOST.html#ga2a694bd9ecf9c0560bfd509211c913dc">doca_pcc_ccmad_custom_header_loc_t</a> { <a class="el" href="group__DOCA__PCC__HOST.html#gga2a694bd9ecf9c0560bfd509211c913dca4959aae36100f595c0948fd2d8e0f5a1">DOCA_PCC_CCMAD_CUSTOM_HEADER_LOCATION_MAD_PAYLOAD</a> = 1
 }</td></tr>
<tr class="memdesc:ga2a694bd9ecf9c0560bfd509211c913dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">CCMAD custom header location.  <a href="group__DOCA__PCC__HOST.html#ga2a694bd9ecf9c0560bfd509211c913dc">More...</a><br /></td></tr>
<tr class="separator:ga2a694bd9ecf9c0560bfd509211c913dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85406a96c85da788489b54b06fa00aea"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__PCC__HOST.html#ga85406a96c85da788489b54b06fa00aea">doca_pcc_process_state_t</a> { <a class="el" href="group__DOCA__PCC__HOST.html#gga85406a96c85da788489b54b06fa00aeaa0035c21e7dae7eb728c1cf9f6016ac4b">DOCA_PCC_PS_ACTIVE</a> = 0
, <a class="el" href="group__DOCA__PCC__HOST.html#gga85406a96c85da788489b54b06fa00aeaacd2e07fcc14b3f78ddfa739851316f45">DOCA_PCC_PS_STANDBY</a> = 1
, <a class="el" href="group__DOCA__PCC__HOST.html#gga85406a96c85da788489b54b06fa00aeaab7afcd8a8ae5765aa33567af11e63ed7">DOCA_PCC_PS_DEACTIVATED</a> = 2
, <a class="el" href="group__DOCA__PCC__HOST.html#gga85406a96c85da788489b54b06fa00aeaab9492786d66214e997af0d682c7377a0">DOCA_PCC_PS_ERROR</a> = 3
 }</td></tr>
<tr class="memdesc:ga85406a96c85da788489b54b06fa00aea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process states.  <a href="group__DOCA__PCC__HOST.html#ga85406a96c85da788489b54b06fa00aea">More...</a><br /></td></tr>
<tr class="separator:ga85406a96c85da788489b54b06fa00aea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga93eed83db8267fd4aa9a6c8bff8eb99f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#gabf4c2072da5a4674395e37df60eb4b1c">DOCA_STABLE</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__PCC__HOST.html#ga93eed83db8267fd4aa9a6c8bff8eb99f">doca_devinfo_get_is_pcc_supported</a> (const struct doca_devinfo *devinfo)</td></tr>
<tr class="memdesc:ga93eed83db8267fd4aa9a6c8bff8eb99f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get whether the DOCA device supports PCC reaction point.  <a href="group__DOCA__PCC__HOST.html#ga93eed83db8267fd4aa9a6c8bff8eb99f">More...</a><br /></td></tr>
<tr class="separator:ga93eed83db8267fd4aa9a6c8bff8eb99f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5ab2ddc97bb4a8260b2aa7d5b5793e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__PCC__HOST.html#gad5ab2ddc97bb4a8260b2aa7d5b5793e4">doca_pcc_np_cap_is_supported</a> (const struct doca_devinfo *devinfo)</td></tr>
<tr class="memdesc:gad5ab2ddc97bb4a8260b2aa7d5b5793e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get whether the DOCA device supports PCC notification point.  <a href="group__DOCA__PCC__HOST.html#gad5ab2ddc97bb4a8260b2aa7d5b5793e4">More...</a><br /></td></tr>
<tr class="separator:gad5ab2ddc97bb4a8260b2aa7d5b5793e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15cbe9b21a587fd481e13c493f8b879a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#gabf4c2072da5a4674395e37df60eb4b1c">DOCA_STABLE</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__PCC__HOST.html#ga15cbe9b21a587fd481e13c493f8b879a">doca_pcc_create</a> (struct doca_dev *doca_dev, struct doca_pcc **pcc)</td></tr>
<tr class="memdesc:ga15cbe9b21a587fd481e13c493f8b879a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create programmable CC Reaction Point context.  <a href="group__DOCA__PCC__HOST.html#ga15cbe9b21a587fd481e13c493f8b879a">More...</a><br /></td></tr>
<tr class="separator:ga15cbe9b21a587fd481e13c493f8b879a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a697332d6690eebde525e2a7166ff13"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__PCC__HOST.html#ga8a697332d6690eebde525e2a7166ff13">doca_pcc_np_create</a> (struct doca_dev *doca_dev, struct doca_pcc **pcc)</td></tr>
<tr class="memdesc:ga8a697332d6690eebde525e2a7166ff13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create programmable CC Notification Point context.  <a href="group__DOCA__PCC__HOST.html#ga8a697332d6690eebde525e2a7166ff13">More...</a><br /></td></tr>
<tr class="separator:ga8a697332d6690eebde525e2a7166ff13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f18073dc140da7b0f8dc700828924db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#gabf4c2072da5a4674395e37df60eb4b1c">DOCA_STABLE</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__PCC__HOST.html#ga4f18073dc140da7b0f8dc700828924db">doca_pcc_destroy</a> (struct doca_pcc *pcc)</td></tr>
<tr class="memdesc:ga4f18073dc140da7b0f8dc700828924db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a DOCA PCC context.  <a href="group__DOCA__PCC__HOST.html#ga4f18073dc140da7b0f8dc700828924db">More...</a><br /></td></tr>
<tr class="separator:ga4f18073dc140da7b0f8dc700828924db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac14acc4141443f07b1eea38232781072"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#gabf4c2072da5a4674395e37df60eb4b1c">DOCA_STABLE</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__PCC__HOST.html#gac14acc4141443f07b1eea38232781072">doca_pcc_start</a> (struct doca_pcc *pcc)</td></tr>
<tr class="memdesc:gac14acc4141443f07b1eea38232781072"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a PCC context Register the pcc process in the NIC hw.  <a href="group__DOCA__PCC__HOST.html#gac14acc4141443f07b1eea38232781072">More...</a><br /></td></tr>
<tr class="separator:gac14acc4141443f07b1eea38232781072"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga791500567a3fe79dbdea97c44676505e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#gabf4c2072da5a4674395e37df60eb4b1c">DOCA_STABLE</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__PCC__HOST.html#ga791500567a3fe79dbdea97c44676505e">doca_pcc_stop</a> (struct doca_pcc *pcc)</td></tr>
<tr class="memdesc:ga791500567a3fe79dbdea97c44676505e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop a PCC context.  <a href="group__DOCA__PCC__HOST.html#ga791500567a3fe79dbdea97c44676505e">More...</a><br /></td></tr>
<tr class="separator:ga791500567a3fe79dbdea97c44676505e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga827be97366d1089f855b606366fb77a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#gabf4c2072da5a4674395e37df60eb4b1c">DOCA_STABLE</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__PCC__HOST.html#ga827be97366d1089f855b606366fb77a7">doca_pcc_get_min_num_threads</a> (struct doca_pcc *pcc, uint32_t *min_num_threads)</td></tr>
<tr class="memdesc:ga827be97366d1089f855b606366fb77a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a minimal required number of threads handling CC events.  <a href="group__DOCA__PCC__HOST.html#ga827be97366d1089f855b606366fb77a7">More...</a><br /></td></tr>
<tr class="separator:ga827be97366d1089f855b606366fb77a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9731d6386f86bbb69999646bc2e1811a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#gabf4c2072da5a4674395e37df60eb4b1c">DOCA_STABLE</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__PCC__HOST.html#ga9731d6386f86bbb69999646bc2e1811a">doca_pcc_get_max_num_threads</a> (struct doca_pcc *pcc, uint32_t *max_num_threads)</td></tr>
<tr class="memdesc:ga9731d6386f86bbb69999646bc2e1811a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a maximal allowed number of threads handling CC events.  <a href="group__DOCA__PCC__HOST.html#ga9731d6386f86bbb69999646bc2e1811a">More...</a><br /></td></tr>
<tr class="separator:ga9731d6386f86bbb69999646bc2e1811a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d0fe3c35a8c002583656a5cd2712dc6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#gabf4c2072da5a4674395e37df60eb4b1c">DOCA_STABLE</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__PCC__HOST.html#ga7d0fe3c35a8c002583656a5cd2712dc6">doca_pcc_set_app</a> (struct doca_pcc *pcc, struct doca_pcc_app *app)</td></tr>
<tr class="memdesc:ga7d0fe3c35a8c002583656a5cd2712dc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set program app for PCC context.  <a href="group__DOCA__PCC__HOST.html#ga7d0fe3c35a8c002583656a5cd2712dc6">More...</a><br /></td></tr>
<tr class="separator:ga7d0fe3c35a8c002583656a5cd2712dc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2006578406372264729fd0f247a9dd1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__PCC__HOST.html#gac2006578406372264729fd0f247a9dd1">doca_pcc_cap_get_num_probe_format_slots</a> (struct doca_pcc *pcc, uint32_t *num_probe_format_slots)</td></tr>
<tr class="memdesc:gac2006578406372264729fd0f247a9dd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of available probe format slots.  <a href="group__DOCA__PCC__HOST.html#gac2006578406372264729fd0f247a9dd1">More...</a><br /></td></tr>
<tr class="separator:gac2006578406372264729fd0f247a9dd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5006261269e8b174d825e8d45d94aeca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__PCC__HOST.html#ga5006261269e8b174d825e8d45d94aeca">doca_pcc_set_ccmad_probe_packet_format</a> (struct doca_pcc *pcc, uint32_t probe_format_slot)</td></tr>
<tr class="memdesc:ga5006261269e8b174d825e8d45d94aeca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set CCMAD probe packet format for the pcc process.  <a href="group__DOCA__PCC__HOST.html#ga5006261269e8b174d825e8d45d94aeca">More...</a><br /></td></tr>
<tr class="separator:ga5006261269e8b174d825e8d45d94aeca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga219b3b3baad4a8290e4c10d0b2a8a7a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__PCC__HOST.html#ga219b3b3baad4a8290e4c10d0b2a8a7a1">doca_pcc_set_ifa1_probe_packet_format</a> (struct doca_pcc *pcc, uint32_t probe_format_slot)</td></tr>
<tr class="memdesc:ga219b3b3baad4a8290e4c10d0b2a8a7a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set ifa1 probe packet format for the pcc process.  <a href="group__DOCA__PCC__HOST.html#ga219b3b3baad4a8290e4c10d0b2a8a7a1">More...</a><br /></td></tr>
<tr class="separator:ga219b3b3baad4a8290e4c10d0b2a8a7a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50545c303fa582495733618c6d5e888a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__PCC__HOST.html#ga50545c303fa582495733618c6d5e888a">doca_pcc_set_ifa2_probe_packet_format</a> (struct doca_pcc *pcc, uint32_t probe_format_slot)</td></tr>
<tr class="memdesc:ga50545c303fa582495733618c6d5e888a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set ifa2 probe packet format for the pcc process.  <a href="group__DOCA__PCC__HOST.html#ga50545c303fa582495733618c6d5e888a">More...</a><br /></td></tr>
<tr class="separator:ga50545c303fa582495733618c6d5e888a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3825e237f32212c4dd29be5b27815350"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__PCC__HOST.html#ga3825e237f32212c4dd29be5b27815350">doca_pcc_rp_set_ccmad_remote_sw_handler</a> (struct doca_pcc *pcc, uint32_t probe_format_slot, <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> sw_handler)</td></tr>
<tr class="memdesc:ga3825e237f32212c4dd29be5b27815350"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set sw remote handler for CCMAD probe type.  <a href="group__DOCA__PCC__HOST.html#ga3825e237f32212c4dd29be5b27815350">More...</a><br /></td></tr>
<tr class="separator:ga3825e237f32212c4dd29be5b27815350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1870c6801bc7e476ec9970c43a773a9b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__PCC__HOST.html#ga1870c6801bc7e476ec9970c43a773a9b">doca_pcc_cap_is_ccmad_custom_header_supported</a> (const struct doca_devinfo *devinfo)</td></tr>
<tr class="memdesc:ga1870c6801bc7e476ec9970c43a773a9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get whether the DOCA device supports PCC ccmad customized header in reaction point.  <a href="group__DOCA__PCC__HOST.html#ga1870c6801bc7e476ec9970c43a773a9b">More...</a><br /></td></tr>
<tr class="separator:ga1870c6801bc7e476ec9970c43a773a9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0065e1f0bd615ad86942e34db4980b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__PCC__HOST.html#gaa0065e1f0bd615ad86942e34db4980b6">doca_pcc_rp_set_ccmad_custom_header_size</a> (struct doca_pcc *pcc, uint32_t probe_format_slot, uint8_t header_size)</td></tr>
<tr class="memdesc:gaa0065e1f0bd615ad86942e34db4980b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set customized header of CCMAD probe packet in RP.  <a href="group__DOCA__PCC__HOST.html#gaa0065e1f0bd615ad86942e34db4980b6">More...</a><br /></td></tr>
<tr class="separator:gaa0065e1f0bd615ad86942e34db4980b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga118a23e5b7ebadc35bd6d260a9c047ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__PCC__HOST.html#ga118a23e5b7ebadc35bd6d260a9c047ad">doca_pcc_rp_set_ccmad_custom_header_location</a> (struct doca_pcc *pcc, uint32_t probe_format_slot, <a class="el" href="group__DOCA__PCC__HOST.html#ga2a694bd9ecf9c0560bfd509211c913dc">doca_pcc_ccmad_custom_header_loc_t</a> header_loc)</td></tr>
<tr class="memdesc:ga118a23e5b7ebadc35bd6d260a9c047ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set customized header of CCMAD probe packet in RP.  <a href="group__DOCA__PCC__HOST.html#ga118a23e5b7ebadc35bd6d260a9c047ad">More...</a><br /></td></tr>
<tr class="separator:ga118a23e5b7ebadc35bd6d260a9c047ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6149111b6548fc3a27736d19582d4f16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__PCC__HOST.html#ga6149111b6548fc3a27736d19582d4f16">doca_pcc_set_ifa1_probe_marker</a> (struct doca_pcc *pcc, uint32_t probe_format_slot, uint64_t probe_marker)</td></tr>
<tr class="memdesc:ga6149111b6548fc3a27736d19582d4f16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set probe marker value for IFA1 probe.  <a href="group__DOCA__PCC__HOST.html#ga6149111b6548fc3a27736d19582d4f16">More...</a><br /></td></tr>
<tr class="separator:ga6149111b6548fc3a27736d19582d4f16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdca493b94e40c99e7f00630a05d0c72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__PCC__HOST.html#gabdca493b94e40c99e7f00630a05d0c72">doca_pcc_rp_set_ifa2_gns</a> (struct doca_pcc *pcc, uint32_t probe_format_slot, uint8_t gns)</td></tr>
<tr class="memdesc:gabdca493b94e40c99e7f00630a05d0c72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set GNS value for IFA2 packets.  <a href="group__DOCA__PCC__HOST.html#gabdca493b94e40c99e7f00630a05d0c72">More...</a><br /></td></tr>
<tr class="separator:gabdca493b94e40c99e7f00630a05d0c72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa7587c392afaca77e38856c33e7350b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__PCC__HOST.html#gafa7587c392afaca77e38856c33e7350b">doca_pcc_np_set_ifa2_gns_ignore</a> (struct doca_pcc *pcc, uint32_t probe_format_slot, uint8_t ignore_mask, uint8_t ignore_value)</td></tr>
<tr class="memdesc:gafa7587c392afaca77e38856c33e7350b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set GNS ignore for IFA2 packets.  <a href="group__DOCA__PCC__HOST.html#gafa7587c392afaca77e38856c33e7350b">More...</a><br /></td></tr>
<tr class="separator:gafa7587c392afaca77e38856c33e7350b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga603d0f9642a46e786e74870172041d2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__PCC__HOST.html#ga603d0f9642a46e786e74870172041d2f">doca_pcc_rp_set_ifa2_hop_limit</a> (struct doca_pcc *pcc, uint32_t probe_format_slot, uint8_t hop_limit)</td></tr>
<tr class="memdesc:ga603d0f9642a46e786e74870172041d2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set hop_limit field in the metadata header for IFA2 packets.  <a href="group__DOCA__PCC__HOST.html#ga603d0f9642a46e786e74870172041d2f">More...</a><br /></td></tr>
<tr class="separator:ga603d0f9642a46e786e74870172041d2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9eb357ed7ef0d26f602cbc78d30b33fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#gabf4c2072da5a4674395e37df60eb4b1c">DOCA_STABLE</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__PCC__HOST.html#ga9eb357ed7ef0d26f602cbc78d30b33fc">doca_pcc_set_thread_affinity</a> (struct doca_pcc *pcc, uint32_t num_threads, uint32_t *affinity_configs)</td></tr>
<tr class="memdesc:ga9eb357ed7ef0d26f602cbc78d30b33fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure affinity of threads handling CC events.  <a href="group__DOCA__PCC__HOST.html#ga9eb357ed7ef0d26f602cbc78d30b33fc">More...</a><br /></td></tr>
<tr class="separator:ga9eb357ed7ef0d26f602cbc78d30b33fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga329327c70ee4595f1c8be3dc9c0ed5fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#gabf4c2072da5a4674395e37df60eb4b1c">DOCA_STABLE</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__PCC__HOST.html#ga329327c70ee4595f1c8be3dc9c0ed5fb">doca_pcc_set_trace_message</a> (struct doca_pcc *pcc, char **trace_message)</td></tr>
<tr class="memdesc:ga329327c70ee4595f1c8be3dc9c0ed5fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set message for trace printing.  <a href="group__DOCA__PCC__HOST.html#ga329327c70ee4595f1c8be3dc9c0ed5fb">More...</a><br /></td></tr>
<tr class="separator:ga329327c70ee4595f1c8be3dc9c0ed5fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1dc80651655ac173b09c10d196d40e80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__PCC__HOST.html#ga1dc80651655ac173b09c10d196d40e80">doca_pcc_activate_tracer</a> (struct doca_pcc *pcc)</td></tr>
<tr class="memdesc:ga1dc80651655ac173b09c10d196d40e80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable trace printing.  <a href="group__DOCA__PCC__HOST.html#ga1dc80651655ac173b09c10d196d40e80">More...</a><br /></td></tr>
<tr class="separator:ga1dc80651655ac173b09c10d196d40e80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf149b7ba7dca84b19724c5f56d98dc81"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__PCC__HOST.html#gaf149b7ba7dca84b19724c5f56d98dc81">doca_pcc_deactivate_tracer</a> (struct doca_pcc *pcc)</td></tr>
<tr class="memdesc:gaf149b7ba7dca84b19724c5f56d98dc81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable trace printing.  <a href="group__DOCA__PCC__HOST.html#gaf149b7ba7dca84b19724c5f56d98dc81">More...</a><br /></td></tr>
<tr class="separator:gaf149b7ba7dca84b19724c5f56d98dc81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae56cf045ba3495cd8e59c4c5604845f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__PCC__HOST.html#gae56cf045ba3495cd8e59c4c5604845f0">doca_pcc_trace_buf_set</a> (struct doca_pcc *pcc, void *buf_addr, uint32_t buf_size)</td></tr>
<tr class="memdesc:gae56cf045ba3495cd8e59c4c5604845f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set trace buffer address to write trace into.  <a href="group__DOCA__PCC__HOST.html#gae56cf045ba3495cd8e59c4c5604845f0">More...</a><br /></td></tr>
<tr class="separator:gae56cf045ba3495cd8e59c4c5604845f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97741252bbe4c287ce470d42d0bbb388"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__PCC__HOST.html#ga97741252bbe4c287ce470d42d0bbb388">doca_pcc_trace_buf_get</a> (struct doca_pcc *pcc, void **buf_addr, uint32_t *buf_size)</td></tr>
<tr class="memdesc:ga97741252bbe4c287ce470d42d0bbb388"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get trace buffer address to write trace into.  <a href="group__DOCA__PCC__HOST.html#ga97741252bbe4c287ce470d42d0bbb388">More...</a><br /></td></tr>
<tr class="separator:ga97741252bbe4c287ce470d42d0bbb388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8bee4b3c7a970d5379e2ca2044c9f127"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__PCC__HOST.html#ga8bee4b3c7a970d5379e2ca2044c9f127">doca_pcc_trace_file_set</a> (struct doca_pcc *pcc, const char *file_path)</td></tr>
<tr class="memdesc:ga8bee4b3c7a970d5379e2ca2044c9f127"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set trace file path to write trace into.  <a href="group__DOCA__PCC__HOST.html#ga8bee4b3c7a970d5379e2ca2044c9f127">More...</a><br /></td></tr>
<tr class="separator:ga8bee4b3c7a970d5379e2ca2044c9f127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga168e379bc7e9121711b8193eb39d41d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__PCC__HOST.html#ga168e379bc7e9121711b8193eb39d41d9">doca_pcc_trace_file_get</a> (struct doca_pcc *pcc, char **file_path, uint32_t *file_path_len)</td></tr>
<tr class="memdesc:ga168e379bc7e9121711b8193eb39d41d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get trace file path to write trace into.  <a href="group__DOCA__PCC__HOST.html#ga168e379bc7e9121711b8193eb39d41d9">More...</a><br /></td></tr>
<tr class="separator:ga168e379bc7e9121711b8193eb39d41d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae04b121d3a5167f35f7d0a2e4f2aeceb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__PCC__HOST.html#gae04b121d3a5167f35f7d0a2e4f2aeceb">doca_pcc_register_trace_handler</a> (struct doca_pcc *pcc, <a class="el" href="group__DOCA__PCC__HOST.html#ga94175e78d1ec955e5a7780cd4267ba03">doca_pcc_trace_callback_t</a> trace_callback, void *user_ctx)</td></tr>
<tr class="memdesc:gae04b121d3a5167f35f7d0a2e4f2aeceb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a user callback that is triggered when traces arrive from the device.  <a href="group__DOCA__PCC__HOST.html#gae04b121d3a5167f35f7d0a2e4f2aeceb">More...</a><br /></td></tr>
<tr class="separator:gae04b121d3a5167f35f7d0a2e4f2aeceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa301ffdf2031da378179b3672de5288f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#gabf4c2072da5a4674395e37df60eb4b1c">DOCA_STABLE</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__PCC__HOST.html#gaa301ffdf2031da378179b3672de5288f">doca_pcc_set_print_buffer_size</a> (struct doca_pcc *pcc, <a class="el" href="____stddef__size__t_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a> buffer_size)</td></tr>
<tr class="memdesc:gaa301ffdf2031da378179b3672de5288f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set buffer size of DPA print message.  <a href="group__DOCA__PCC__HOST.html#gaa301ffdf2031da378179b3672de5288f">More...</a><br /></td></tr>
<tr class="separator:gaa301ffdf2031da378179b3672de5288f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed02890978f8635cd38ca20538636d18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#gabf4c2072da5a4674395e37df60eb4b1c">DOCA_STABLE</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__PCC__HOST.html#gaed02890978f8635cd38ca20538636d18">doca_pcc_set_dev_coredump_file</a> (struct doca_pcc *pcc, const char *file_name)</td></tr>
<tr class="memdesc:gaed02890978f8635cd38ca20538636d18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set output file to write crash data and coredump in case of unrecoverable error on the device.  <a href="group__DOCA__PCC__HOST.html#gaed02890978f8635cd38ca20538636d18">More...</a><br /></td></tr>
<tr class="separator:gaed02890978f8635cd38ca20538636d18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a31ec06b2ecd47fea99b5b1ed02a102"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__PCC__HOST.html#ga4a31ec06b2ecd47fea99b5b1ed02a102">doca_pcc_set_mailbox</a> (struct doca_pcc *pcc, uint32_t max_request_size, uint32_t max_response_size)</td></tr>
<tr class="memdesc:ga4a31ec06b2ecd47fea99b5b1ed02a102"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set mailbox attributes to obtain and pass data from and to the device.  <a href="group__DOCA__PCC__HOST.html#ga4a31ec06b2ecd47fea99b5b1ed02a102">More...</a><br /></td></tr>
<tr class="separator:ga4a31ec06b2ecd47fea99b5b1ed02a102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga432c321af717f5ab7fc2abc19798556b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__PCC__HOST.html#ga432c321af717f5ab7fc2abc19798556b">doca_pcc_mailbox_get_request_buffer</a> (struct doca_pcc *pcc, void **request_buffer)</td></tr>
<tr class="memdesc:ga432c321af717f5ab7fc2abc19798556b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get mailbox request data buffer address to fill and transfer to device.  <a href="group__DOCA__PCC__HOST.html#ga432c321af717f5ab7fc2abc19798556b">More...</a><br /></td></tr>
<tr class="separator:ga432c321af717f5ab7fc2abc19798556b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e05f0bde24d8193cc11dc2d5e8c960c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__PCC__HOST.html#ga2e05f0bde24d8193cc11dc2d5e8c960c">doca_pcc_mailbox_get_response_buffer</a> (struct doca_pcc *pcc, void **response_buffer)</td></tr>
<tr class="memdesc:ga2e05f0bde24d8193cc11dc2d5e8c960c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get mailbox response data buffer address that contains data transferred from device.  <a href="group__DOCA__PCC__HOST.html#ga2e05f0bde24d8193cc11dc2d5e8c960c">More...</a><br /></td></tr>
<tr class="separator:ga2e05f0bde24d8193cc11dc2d5e8c960c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25b0899b688b8f03c18865461d1a9aaa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__PCC__HOST.html#ga25b0899b688b8f03c18865461d1a9aaa">doca_pcc_mailbox_send</a> (struct doca_pcc *pcc, uint32_t request_size, uint32_t *response_size, uint32_t *cb_ret_val)</td></tr>
<tr class="memdesc:ga25b0899b688b8f03c18865461d1a9aaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send mailbox request data to device.  <a href="group__DOCA__PCC__HOST.html#ga25b0899b688b8f03c18865461d1a9aaa">More...</a><br /></td></tr>
<tr class="separator:ga25b0899b688b8f03c18865461d1a9aaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d44e3cbf7230d8f889165578615a04c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#gabf4c2072da5a4674395e37df60eb4b1c">DOCA_STABLE</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__PCC__HOST.html#ga7d44e3cbf7230d8f889165578615a04c">doca_pcc_wait</a> (struct doca_pcc *pcc, int wait_time)</td></tr>
<tr class="memdesc:ga7d44e3cbf7230d8f889165578615a04c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait on events or timeout from device for given time in seconds.  <a href="group__DOCA__PCC__HOST.html#ga7d44e3cbf7230d8f889165578615a04c">More...</a><br /></td></tr>
<tr class="separator:ga7d44e3cbf7230d8f889165578615a04c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafcf7e1ab70638ee50d19a78627794ce1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#gabf4c2072da5a4674395e37df60eb4b1c">DOCA_STABLE</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__PCC__HOST.html#gafcf7e1ab70638ee50d19a78627794ce1">doca_pcc_get_process_state</a> (const struct doca_pcc *pcc, <a class="el" href="group__DOCA__PCC__HOST.html#ga85406a96c85da788489b54b06fa00aea">doca_pcc_process_state_t</a> *process_state)</td></tr>
<tr class="memdesc:gafcf7e1ab70638ee50d19a78627794ce1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the state of the process.  <a href="group__DOCA__PCC__HOST.html#gafcf7e1ab70638ee50d19a78627794ce1">More...</a><br /></td></tr>
<tr class="separator:gafcf7e1ab70638ee50d19a78627794ce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22e5d335cde7ec9d3ba101f88275273b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__PCC__HOST.html#ga22e5d335cde7ec9d3ba101f88275273b">doca_pcc_dump_debug</a> (const struct doca_pcc *pcc)</td></tr>
<tr class="memdesc:ga22e5d335cde7ec9d3ba101f88275273b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump device side debug info.  <a href="group__DOCA__PCC__HOST.html#ga22e5d335cde7ec9d3ba101f88275273b">More...</a><br /></td></tr>
<tr class="separator:ga22e5d335cde7ec9d3ba101f88275273b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad2a0441b12de404a197c1634e0f2bb3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DOCA__PCC__HOST.html#gaad2a0441b12de404a197c1634e0f2bb3">doca_pcc_enable_debug</a> (const struct doca_pcc *pcc, <a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> enable)</td></tr>
<tr class="memdesc:gaad2a0441b12de404a197c1634e0f2bb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable device side debug.  <a href="group__DOCA__PCC__HOST.html#gaad2a0441b12de404a197c1634e0f2bb3">More...</a><br /></td></tr>
<tr class="separator:gaad2a0441b12de404a197c1634e0f2bb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>DOCA PCC Host library. For more details please refer to the user guide on DOCA devzone. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga94175e78d1ec955e5a7780cd4267ba03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga94175e78d1ec955e5a7780cd4267ba03">&#9670;&nbsp;</a></span>doca_pcc_trace_callback_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* doca_pcc_trace_callback_t) (void *<a class="el" href="upf__accel__flow__processing_8h.html#a8b3a0cb2be2fc166f6fa69afa523e3e4">ctx</a>, struct doca_pcc_bin_report *reps, int reps_size)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tracer user callback, to be defined by user and called when traces are sent by DPA. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>- User defined context that will be sent each time for user to update, Optional </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reps</td><td>- Array of trace messages that are received by DPA </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reps_size</td><td>- Number of trace messages received in reps array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>User can define what the return value means. </dd></dl>

<p class="definition">Definition at line <a class="el" href="doca__pcc_8h_source.html#l00619">619</a> of file <a class="el" href="doca__pcc_8h_source.html">doca_pcc.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga2a694bd9ecf9c0560bfd509211c913dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2a694bd9ecf9c0560bfd509211c913dc">&#9670;&nbsp;</a></span>doca_pcc_ccmad_custom_header_loc_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__DOCA__PCC__HOST.html#ga2a694bd9ecf9c0560bfd509211c913dc">doca_pcc_ccmad_custom_header_loc_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CCMAD custom header location. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga2a694bd9ecf9c0560bfd509211c913dca4959aae36100f595c0948fd2d8e0f5a1"></a>DOCA_PCC_CCMAD_CUSTOM_HEADER_LOCATION_MAD_PAYLOAD&#160;</td><td class="fielddoc"><p>Custom header will be inserted after MAD payload </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="doca__pcc_8h_source.html#l00350">350</a> of file <a class="el" href="doca__pcc_8h_source.html">doca_pcc.h</a>.</p>

</div>
</div>
<a id="ga85406a96c85da788489b54b06fa00aea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga85406a96c85da788489b54b06fa00aea">&#9670;&nbsp;</a></span>doca_pcc_process_state_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__DOCA__PCC__HOST.html#ga85406a96c85da788489b54b06fa00aea">doca_pcc_process_state_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Process states. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga85406a96c85da788489b54b06fa00aeaa0035c21e7dae7eb728c1cf9f6016ac4b"></a>DOCA_PCC_PS_ACTIVE&#160;</td><td class="fielddoc"><p>The process handles CC events (only one process is active at a given time) </p>
</td></tr>
<tr><td class="fieldname"><a id="gga85406a96c85da788489b54b06fa00aeaacd2e07fcc14b3f78ddfa739851316f45"></a>DOCA_PCC_PS_STANDBY&#160;</td><td class="fielddoc"><p>The process is in standby mode (another process is already ACTIVE) </p>
</td></tr>
<tr><td class="fieldname"><a id="gga85406a96c85da788489b54b06fa00aeaab7afcd8a8ae5765aa33567af11e63ed7"></a>DOCA_PCC_PS_DEACTIVATED&#160;</td><td class="fielddoc"><p>The process was deactivated by NIC FW and should be destroyed </p>
</td></tr>
<tr><td class="fieldname"><a id="gga85406a96c85da788489b54b06fa00aeaab9492786d66214e997af0d682c7377a0"></a>DOCA_PCC_PS_ERROR&#160;</td><td class="fielddoc"><p>The process is in error state and should be destroyed </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="doca__pcc_8h_source.html#l00766">766</a> of file <a class="el" href="doca__pcc_8h_source.html">doca_pcc.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga93eed83db8267fd4aa9a6c8bff8eb99f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga93eed83db8267fd4aa9a6c8bff8eb99f">&#9670;&nbsp;</a></span>doca_devinfo_get_is_pcc_supported()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#gabf4c2072da5a4674395e37df60eb4b1c">DOCA_STABLE</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_devinfo_get_is_pcc_supported </td>
          <td>(</td>
          <td class="paramtype">const struct doca_devinfo *&#160;</td>
          <td class="paramname"><em>devinfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get whether the DOCA device supports PCC reaction point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">devinfo</td><td>- The device to query</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of the DOCA device queried has PCC reaction point support Error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input</li>
<li>DOCA_ERROR_NOT_SUPPORTED - the device queried does not support PCC reaction point </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga1dc80651655ac173b09c10d196d40e80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1dc80651655ac173b09c10d196d40e80">&#9670;&nbsp;</a></span>doca_pcc_activate_tracer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_pcc_activate_tracer </td>
          <td>(</td>
          <td class="paramtype">struct doca_pcc *&#160;</td>
          <td class="paramname"><em>pcc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable trace printing. </p>
<dl class="section note"><dt>Note</dt><dd>if not set tracing will be disabled by default</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pcc</td><td>- PCC context</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>DOCA_SUCCESS - in case of success</li>
<li>DOCA_ERROR_INVALID_VALUE - received invalid null input</li>
<li>DOCA_ERROR_DRIVER - in case of error in a DOCA driver call </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gac2006578406372264729fd0f247a9dd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac2006578406372264729fd0f247a9dd1">&#9670;&nbsp;</a></span>doca_pcc_cap_get_num_probe_format_slots()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_pcc_cap_get_num_probe_format_slots </td>
          <td>(</td>
          <td class="paramtype">struct doca_pcc *&#160;</td>
          <td class="paramname"><em>pcc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>num_probe_format_slots</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get number of available probe format slots. </p>
<p>The NIC may support multiple probe formats in parallel. This function returns the number of probe formats supported by the device used to open the pcc context.</p>
<p>The caller may set probe_format_slot values of 0 to num_probe_format_slots - 1 in the functions referring to this value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pcc</td><td>- PCC context </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">num_probe_format_slots</td><td>- number of available probe format slots </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1870c6801bc7e476ec9970c43a773a9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1870c6801bc7e476ec9970c43a773a9b">&#9670;&nbsp;</a></span>doca_pcc_cap_is_ccmad_custom_header_supported()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_pcc_cap_is_ccmad_custom_header_supported </td>
          <td>(</td>
          <td class="paramtype">const struct doca_devinfo *&#160;</td>
          <td class="paramname"><em>devinfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get whether the DOCA device supports PCC ccmad customized header in reaction point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">devinfo</td><td>- The device to query</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case the DOCA device queried has support for CCMAD custom header Error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input</li>
<li>DOCA_ERROR_NOT_SUPPORTED - the device queried does not support CCMAD custom header </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga15cbe9b21a587fd481e13c493f8b879a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15cbe9b21a587fd481e13c493f8b879a">&#9670;&nbsp;</a></span>doca_pcc_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#gabf4c2072da5a4674395e37df60eb4b1c">DOCA_STABLE</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_pcc_create </td>
          <td>(</td>
          <td class="paramtype">struct doca_dev *&#160;</td>
          <td class="paramname"><em>doca_dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct doca_pcc **&#160;</td>
          <td class="paramname"><em>pcc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create programmable CC Reaction Point context. </p>
<p>This function creates a DOCA PCC Reaction Point context to capture and route PCC events to the DPA.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">doca_dev</td><td>- DOCA device </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pcc</td><td>- Created PCC context</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input</li>
<li>DOCA_ERROR_DRIVER - in case of error in a DOCA driver call</li>
<li>DOCA_ERROR_NOT_SUPPORTED - the device does not support PCC</li>
<li>DOCA_ERROR_NO_MEMORY - in case of failure in internal memory allocation </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaf149b7ba7dca84b19724c5f56d98dc81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf149b7ba7dca84b19724c5f56d98dc81">&#9670;&nbsp;</a></span>doca_pcc_deactivate_tracer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_pcc_deactivate_tracer </td>
          <td>(</td>
          <td class="paramtype">struct doca_pcc *&#160;</td>
          <td class="paramname"><em>pcc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable trace printing. </p>
<dl class="section note"><dt>Note</dt><dd>if not set tracing will be disabled by default</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pcc</td><td>- PCC context</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>DOCA_SUCCESS - in case of success</li>
<li>DOCA_ERROR_INVALID_VALUE - received invalid null input</li>
<li>DOCA_ERROR_DRIVER - in case of error in a DOCA driver call </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga4f18073dc140da7b0f8dc700828924db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f18073dc140da7b0f8dc700828924db">&#9670;&nbsp;</a></span>doca_pcc_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#gabf4c2072da5a4674395e37df60eb4b1c">DOCA_STABLE</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_pcc_destroy </td>
          <td>(</td>
          <td class="paramtype">struct doca_pcc *&#160;</td>
          <td class="paramname"><em>pcc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a DOCA PCC context. </p>
<p>This function destroys PCC context created by <a class="el" href="group__DOCA__PCC__HOST.html#ga15cbe9b21a587fd481e13c493f8b879a" title="Create programmable CC Reaction Point context.">doca_pcc_create()</a> When the termination is started the process will stop handling PCC events. Issuing a ^c during doca_pcc_wait(...) will also result in the application's termination.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pcc</td><td>- Previously created PCC context</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input</li>
<li>DOCA_ERROR_DRIVER - in case of error in a DOCA driver call </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga22e5d335cde7ec9d3ba101f88275273b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga22e5d335cde7ec9d3ba101f88275273b">&#9670;&nbsp;</a></span>doca_pcc_dump_debug()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_pcc_dump_debug </td>
          <td>(</td>
          <td class="paramtype">const struct doca_pcc *&#160;</td>
          <td class="paramname"><em>pcc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump device side debug info. </p>
<p>Must call doca_pcc_enable_debug(pcc, true) to enable debug first; Otherwise no debug info will be dumped.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pcc</td><td>- PCC context</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input</li>
<li>DOCA_ERROR_BAD_STATE - in case pcc is not started</li>
<li>DOCA_ERROR_DRIVER - in case of error in a DOCA driver call </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaad2a0441b12de404a197c1634e0f2bb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad2a0441b12de404a197c1634e0f2bb3">&#9670;&nbsp;</a></span>doca_pcc_enable_debug()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_pcc_enable_debug </td>
          <td>(</td>
          <td class="paramtype">const struct doca_pcc *&#160;</td>
          <td class="paramname"><em>pcc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable or disable device side debug. </p>
<p>When issues arize, device side debugging can be enabled during runtime. Subsequently, calling doca_pcc_dump_debug(pcc) will output the debugging info. This debug info can assist in pinpointing the source of the issues. The same function can be used to disable device side debugging during runtime.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pcc</td><td>- PCC context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enable</td><td>- enable debug if true; disable debug if false.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input</li>
<li>DOCA_ERROR_BAD_STATE - in case pcc is not started</li>
<li>DOCA_ERROR_DRIVER - in case of error in a DOCA driver call </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga9731d6386f86bbb69999646bc2e1811a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9731d6386f86bbb69999646bc2e1811a">&#9670;&nbsp;</a></span>doca_pcc_get_max_num_threads()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#gabf4c2072da5a4674395e37df60eb4b1c">DOCA_STABLE</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_pcc_get_max_num_threads </td>
          <td>(</td>
          <td class="paramtype">struct doca_pcc *&#160;</td>
          <td class="paramname"><em>pcc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>max_num_threads</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a maximal allowed number of threads handling CC events. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pcc</td><td>- PCC context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_num_threads</td><td>- maximal number of threads used by pcc</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success Error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga827be97366d1089f855b606366fb77a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga827be97366d1089f855b606366fb77a7">&#9670;&nbsp;</a></span>doca_pcc_get_min_num_threads()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#gabf4c2072da5a4674395e37df60eb4b1c">DOCA_STABLE</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_pcc_get_min_num_threads </td>
          <td>(</td>
          <td class="paramtype">struct doca_pcc *&#160;</td>
          <td class="paramname"><em>pcc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>min_num_threads</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a minimal required number of threads handling CC events. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pcc</td><td>- PCC context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min_num_threads</td><td>- minimal number of threads used by pcc</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success Error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gafcf7e1ab70638ee50d19a78627794ce1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafcf7e1ab70638ee50d19a78627794ce1">&#9670;&nbsp;</a></span>doca_pcc_get_process_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#gabf4c2072da5a4674395e37df60eb4b1c">DOCA_STABLE</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_pcc_get_process_state </td>
          <td>(</td>
          <td class="paramtype">const struct doca_pcc *&#160;</td>
          <td class="paramname"><em>pcc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DOCA__PCC__HOST.html#ga85406a96c85da788489b54b06fa00aea">doca_pcc_process_state_t</a> *&#160;</td>
          <td class="paramname"><em>process_state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the state of the process. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pcc</td><td>- PCC context </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">process_state</td><td>- state of the PCC process. In case positive wait_time is specified and expired, DEACTIVATED state will be returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input</li>
<li>DOCA_ERROR_BAD_STATE - in case pcc is not started </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga432c321af717f5ab7fc2abc19798556b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga432c321af717f5ab7fc2abc19798556b">&#9670;&nbsp;</a></span>doca_pcc_mailbox_get_request_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_pcc_mailbox_get_request_buffer </td>
          <td>(</td>
          <td class="paramtype">struct doca_pcc *&#160;</td>
          <td class="paramname"><em>pcc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>request_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get mailbox request data buffer address to fill and transfer to device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pcc</td><td>- PCC context </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">request_buffer</td><td>- pointer to request data buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input</li>
<li>DOCA_ERROR_BAD_STATE - in case pcc is not started</li>
<li>DOCA_ERROR_INITIALIZATION - mailbox was not set for PCC context </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga2e05f0bde24d8193cc11dc2d5e8c960c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2e05f0bde24d8193cc11dc2d5e8c960c">&#9670;&nbsp;</a></span>doca_pcc_mailbox_get_response_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_pcc_mailbox_get_response_buffer </td>
          <td>(</td>
          <td class="paramtype">struct doca_pcc *&#160;</td>
          <td class="paramname"><em>pcc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>response_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get mailbox response data buffer address that contains data transferred from device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pcc</td><td>- PCC context </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">response_buffer</td><td>- pointer to response data buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input</li>
<li>DOCA_ERROR_BAD_STATE - in case pcc is not started</li>
<li>DOCA_ERROR_INITIALIZATION - mailbox was not set for PCC context </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga25b0899b688b8f03c18865461d1a9aaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga25b0899b688b8f03c18865461d1a9aaa">&#9670;&nbsp;</a></span>doca_pcc_mailbox_send()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_pcc_mailbox_send </td>
          <td>(</td>
          <td class="paramtype">struct doca_pcc *&#160;</td>
          <td class="paramname"><em>pcc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>request_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>response_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>cb_ret_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send mailbox request data to device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pcc</td><td>- PCC context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">request_size</td><td>- size of request data to send to device </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">response_size</td><td>- size of response data received from device </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cb_ret_val</td><td>- return value of device user callback <a class="el" href="group__DOCA__PCC__DEVICE__SERVICES.html#ga3742965fd7476f22683b90b35b51583e" title="User callback to process a request from host to device.">doca_pcc_dev_user_mailbox_handle()</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input</li>
<li>DOCA_ERROR_DRIVER - in case of error in a DOCA driver call</li>
<li>DOCA_ERROR_BAD_STATE - in case pcc is not started</li>
<li>DOCA_ERROR_INITIALIZATION - mailbox was not set for PCC context </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gad5ab2ddc97bb4a8260b2aa7d5b5793e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5ab2ddc97bb4a8260b2aa7d5b5793e4">&#9670;&nbsp;</a></span>doca_pcc_np_cap_is_supported()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_pcc_np_cap_is_supported </td>
          <td>(</td>
          <td class="paramtype">const struct doca_devinfo *&#160;</td>
          <td class="paramname"><em>devinfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get whether the DOCA device supports PCC notification point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">devinfo</td><td>- The device to query</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of the DOCA device queried has PCC notification point support Error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input</li>
<li>DOCA_ERROR_NOT_SUPPORTED - the device queried does not support PCC notification point </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga8a697332d6690eebde525e2a7166ff13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a697332d6690eebde525e2a7166ff13">&#9670;&nbsp;</a></span>doca_pcc_np_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_pcc_np_create </td>
          <td>(</td>
          <td class="paramtype">struct doca_dev *&#160;</td>
          <td class="paramname"><em>doca_dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct doca_pcc **&#160;</td>
          <td class="paramname"><em>pcc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create programmable CC Notification Point context. </p>
<p>This function creates a DOCA PCC Notification Point context given a DOCA device</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">doca_dev</td><td>- DOCA device </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pcc</td><td>- Created PCC context</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input</li>
<li>DOCA_ERROR_DRIVER - in case of error in a DOCA driver call</li>
<li>DOCA_ERROR_NOT_SUPPORTED - the device does not support PCC</li>
<li>DOCA_ERROR_NO_MEMORY - in case of failure in internal memory allocation </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gafa7587c392afaca77e38856c33e7350b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa7587c392afaca77e38856c33e7350b">&#9670;&nbsp;</a></span>doca_pcc_np_set_ifa2_gns_ignore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_pcc_np_set_ifa2_gns_ignore </td>
          <td>(</td>
          <td class="paramtype">struct doca_pcc *&#160;</td>
          <td class="paramname"><em>pcc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>probe_format_slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ignore_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ignore_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set GNS ignore for IFA2 packets. </p>
<p>Applicable to: NP role when probe packet format is set to IFA2</p>
<p>When (ignore_mask != 0), if: (packet.GNS &amp; ignore_mask) == (ignore_value &amp; ignore_mask) the packet will not be sent to the NP process, and will be delivered to SW as a standard eth packet.</p>
<p>By default all IFA2 packets are sent to the NP process (ignore_mask = 0)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pcc</td><td>- PCC context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">probe_format_slot</td><td>- format slot to configure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__DOCA__PCC__HOST.html#gac2006578406372264729fd0f247a9dd1" title="Get number of available probe format slots.">doca_pcc_cap_get_num_probe_format_slots()</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ignore_mask</td><td>- GNS ignore mask - limited to 4 bits </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ignore_value</td><td>- GNS ignore value - limited to 4 bits</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input</li>
<li>DOCA_ERROR_NOT_SUPPORTED - the device does not support setting probe packet format</li>
<li>DOCA_ERROR_BAD_STATE - PCC context is already started </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gae04b121d3a5167f35f7d0a2e4f2aeceb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae04b121d3a5167f35f7d0a2e4f2aeceb">&#9670;&nbsp;</a></span>doca_pcc_register_trace_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_pcc_register_trace_handler </td>
          <td>(</td>
          <td class="paramtype">struct doca_pcc *&#160;</td>
          <td class="paramname"><em>pcc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DOCA__PCC__HOST.html#ga94175e78d1ec955e5a7780cd4267ba03">doca_pcc_trace_callback_t</a>&#160;</td>
          <td class="paramname"><em>trace_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a user callback that is triggered when traces arrive from the device. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__DOCA__PCC__HOST.html#ga94175e78d1ec955e5a7780cd4267ba03" title="Tracer user callback, to be defined by user and called when traces are sent by DPA.">doca_pcc_trace_callback_t</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pcc</td><td>- PCC context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trace_callback</td><td>- pointer to user-implemented callback </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user_ctx</td><td>- pointer to user-defined context, This is optional parameter, can be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>DOCA_SUCCESS - in case of success</li>
<li>DOCA_ERROR_INVALID_VALUE - received invalid null input </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga118a23e5b7ebadc35bd6d260a9c047ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga118a23e5b7ebadc35bd6d260a9c047ad">&#9670;&nbsp;</a></span>doca_pcc_rp_set_ccmad_custom_header_location()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_pcc_rp_set_ccmad_custom_header_location </td>
          <td>(</td>
          <td class="paramtype">struct doca_pcc *&#160;</td>
          <td class="paramname"><em>pcc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>probe_format_slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__DOCA__PCC__HOST.html#ga2a694bd9ecf9c0560bfd509211c913dc">doca_pcc_ccmad_custom_header_loc_t</a>&#160;</td>
          <td class="paramname"><em>header_loc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set customized header of CCMAD probe packet in RP. </p>
<p>Applicable to: RP role when probe packet format is set to ccmad</p>
<p>Set the custom header location in CCMAD probe packet in RP. 1: MAD_PAYLOAD - custom bytes inserted after the MAD payload</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pcc</td><td>- PCC context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">probe_format_slot</td><td>- format slot to configure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__DOCA__PCC__HOST.html#gac2006578406372264729fd0f247a9dd1" title="Get number of available probe format slots.">doca_pcc_cap_get_num_probe_format_slots()</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">header_loc</td><td>- custom header location. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__DOCA__PCC__HOST.html#ga2a694bd9ecf9c0560bfd509211c913dc" title="CCMAD custom header location.">doca_pcc_ccmad_custom_header_loc_t</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input</li>
<li>DOCA_ERROR_BAD_STATE - PCC context is already started </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaa0065e1f0bd615ad86942e34db4980b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0065e1f0bd615ad86942e34db4980b6">&#9670;&nbsp;</a></span>doca_pcc_rp_set_ccmad_custom_header_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_pcc_rp_set_ccmad_custom_header_size </td>
          <td>(</td>
          <td class="paramtype">struct doca_pcc *&#160;</td>
          <td class="paramname"><em>pcc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>probe_format_slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>header_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set customized header of CCMAD probe packet in RP. </p>
<p>Applicable to: RP role when probe packet format is set to ccmad</p>
<p>Set the custom header size for CCMAD probe packet in RP.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pcc</td><td>- PCC context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">probe_format_slot</td><td>- format slot to configure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__DOCA__PCC__HOST.html#gac2006578406372264729fd0f247a9dd1" title="Get number of available probe format slots.">doca_pcc_cap_get_num_probe_format_slots()</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">header_size</td><td>- custom header size, unit is 4 Bytes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input</li>
<li>DOCA_ERROR_BAD_STATE - PCC context is already started </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga3825e237f32212c4dd29be5b27815350"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3825e237f32212c4dd29be5b27815350">&#9670;&nbsp;</a></span>doca_pcc_rp_set_ccmad_remote_sw_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_pcc_rp_set_ccmad_remote_sw_handler </td>
          <td>(</td>
          <td class="paramtype">struct doca_pcc *&#160;</td>
          <td class="paramname"><em>pcc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>probe_format_slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdbool_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>sw_handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set sw remote handler for CCMAD probe type. </p>
<p>When a CCMAD probe packet is received by the remote RX NP port, it can be sent either to the HW CC handler (for rtt probes) or to NP process for any probe format.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pcc</td><td>- PCC context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">probe_format_slot</td><td>- format slot to configure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__DOCA__PCC__HOST.html#gac2006578406372264729fd0f247a9dd1" title="Get number of available probe format slots.">doca_pcc_cap_get_num_probe_format_slots()</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sw_handler</td><td>- When set, packets generated by the RP are handled by the NP PCC process. When cleared, packets generated by the RP are handled by the NP HW handler</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input</li>
<li>DOCA_ERROR_BAD_STATE - PCC context is already started </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gabdca493b94e40c99e7f00630a05d0c72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabdca493b94e40c99e7f00630a05d0c72">&#9670;&nbsp;</a></span>doca_pcc_rp_set_ifa2_gns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_pcc_rp_set_ifa2_gns </td>
          <td>(</td>
          <td class="paramtype">struct doca_pcc *&#160;</td>
          <td class="paramname"><em>pcc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>probe_format_slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>gns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set GNS value for IFA2 packets. </p>
<p>Applicable to: RP role when probe packet format is set to IFA2</p>
<p>By default IFA2 gns value is set to 0xF</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pcc</td><td>- PCC context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">probe_format_slot</td><td>- format slot to configure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__DOCA__PCC__HOST.html#gac2006578406372264729fd0f247a9dd1" title="Get number of available probe format slots.">doca_pcc_cap_get_num_probe_format_slots</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">gns</td><td>- global namespace - limited to 4 bits</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input</li>
<li>DOCA_ERROR_NOT_SUPPORTED - the device does not support setting probe packet format</li>
<li>DOCA_ERROR_BAD_STATE - PCC context is already started </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga603d0f9642a46e786e74870172041d2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga603d0f9642a46e786e74870172041d2f">&#9670;&nbsp;</a></span>doca_pcc_rp_set_ifa2_hop_limit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_pcc_rp_set_ifa2_hop_limit </td>
          <td>(</td>
          <td class="paramtype">struct doca_pcc *&#160;</td>
          <td class="paramname"><em>pcc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>probe_format_slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>hop_limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set hop_limit field in the metadata header for IFA2 packets. </p>
<p>Applicable to: RP role when probe packet format is set to IFA2</p>
<p>By default IFA2 hop_limit value is set to 0xFE</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pcc</td><td>- PCC context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">probe_format_slot</td><td>- format slot to configure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__DOCA__PCC__HOST.html#gac2006578406372264729fd0f247a9dd1" title="Get number of available probe format slots.">doca_pcc_cap_get_num_probe_format_slots</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hop_limit</td><td>- hop limit value to set</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input</li>
<li>DOCA_ERROR_NOT_SUPPORTED - the device does not support setting probe packet format</li>
<li>DOCA_ERROR_BAD_STATE - PCC context is already started </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga7d0fe3c35a8c002583656a5cd2712dc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d0fe3c35a8c002583656a5cd2712dc6">&#9670;&nbsp;</a></span>doca_pcc_set_app()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#gabf4c2072da5a4674395e37df60eb4b1c">DOCA_STABLE</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_pcc_set_app </td>
          <td>(</td>
          <td class="paramtype">struct doca_pcc *&#160;</td>
          <td class="paramname"><em>pcc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct doca_pcc_app *&#160;</td>
          <td class="paramname"><em>app</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set program app for PCC context. </p>
<p>The context represents a program on the DPA that is referenced by the host process that called the context creation API. Must be set before calling <a class="el" href="group__DOCA__PCC__HOST.html#gac14acc4141443f07b1eea38232781072" title="Start a PCC context Register the pcc process in the NIC hw.">doca_pcc_start()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pcc</td><td>- PCC context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">app</td><td>- PCC application generated by DPACC</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input</li>
<li>DOCA_ERROR_BAD_STATE - PCC context is already started </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga5006261269e8b174d825e8d45d94aeca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5006261269e8b174d825e8d45d94aeca">&#9670;&nbsp;</a></span>doca_pcc_set_ccmad_probe_packet_format()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_pcc_set_ccmad_probe_packet_format </td>
          <td>(</td>
          <td class="paramtype">struct doca_pcc *&#160;</td>
          <td class="paramname"><em>pcc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>probe_format_slot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set CCMAD probe packet format for the pcc process. </p>
<p>For RP: Sets the packet type to send to CCMAD when an rtt probe is requested. For NP: defines CCMAD packet type to identify and send to the NP device side code</p>
<dl class="section note"><dt>Note</dt><dd>CCMAD is default value for PCC context probe packet format</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pcc</td><td>- PCC context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">probe_format_slot</td><td>- format slot to configure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__DOCA__PCC__HOST.html#gac2006578406372264729fd0f247a9dd1" title="Get number of available probe format slots.">doca_pcc_cap_get_num_probe_format_slots()</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input</li>
<li>DOCA_ERROR_NOT_SUPPORTED - the device does not support setting probe packet format</li>
<li>DOCA_ERROR_BAD_STATE - PCC context is already started </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaed02890978f8635cd38ca20538636d18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed02890978f8635cd38ca20538636d18">&#9670;&nbsp;</a></span>doca_pcc_set_dev_coredump_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#gabf4c2072da5a4674395e37df60eb4b1c">DOCA_STABLE</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_pcc_set_dev_coredump_file </td>
          <td>(</td>
          <td class="paramtype">struct doca_pcc *&#160;</td>
          <td class="paramname"><em>pcc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set output file to write crash data and coredump in case of unrecoverable error on the device. </p>
<p>Must be set before calling <a class="el" href="group__DOCA__PCC__HOST.html#gac14acc4141443f07b1eea38232781072" title="Start a PCC context Register the pcc process in the NIC hw.">doca_pcc_start()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pcc</td><td>- PCC context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">file_name</td><td>- pathname to the output file to write coredump data into</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input</li>
<li>DOCA_ERROR_BAD_STATE - PCC context is already started</li>
<li>DOCA_ERROR_NO_MEMORY - memory allocation error </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga6149111b6548fc3a27736d19582d4f16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6149111b6548fc3a27736d19582d4f16">&#9670;&nbsp;</a></span>doca_pcc_set_ifa1_probe_marker()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_pcc_set_ifa1_probe_marker </td>
          <td>(</td>
          <td class="paramtype">struct doca_pcc *&#160;</td>
          <td class="paramname"><em>pcc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>probe_format_slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>probe_marker</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set probe marker value for IFA1 probe. </p>
<p>Applicable to: RP/NP role when probe packet format is set to IFA1</p>
<p>Set the probe marker field value in the generated IFA1 packets. Note: the the most significant bit of the probe parameter must be set.</p>
<p>By default the probe marker is set to 0xAAAAAAAABBBBBBBB</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pcc</td><td>- PCC context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">probe_format_slot</td><td>- format slot to configure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__DOCA__PCC__HOST.html#gac2006578406372264729fd0f247a9dd1" title="Get number of available probe format slots.">doca_pcc_cap_get_num_probe_format_slots()</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">probe_marker</td><td>- probe marker value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input</li>
<li>DOCA_ERROR_NOT_SUPPORTED - the device does not support setting probe packet format</li>
<li>DOCA_ERROR_BAD_STATE - PCC context is already started </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga219b3b3baad4a8290e4c10d0b2a8a7a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga219b3b3baad4a8290e4c10d0b2a8a7a1">&#9670;&nbsp;</a></span>doca_pcc_set_ifa1_probe_packet_format()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_pcc_set_ifa1_probe_packet_format </td>
          <td>(</td>
          <td class="paramtype">struct doca_pcc *&#160;</td>
          <td class="paramname"><em>pcc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>probe_format_slot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set ifa1 probe packet format for the pcc process. </p>
<p>For RP: Sets the packet type to send to ifa1 when an rtt probe is requested. For NP: defines ifa1 packet type to identify and send to the NP device side code</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pcc</td><td>- PCC context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">probe_format_slot</td><td>- format slot to configure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__DOCA__PCC__HOST.html#gac2006578406372264729fd0f247a9dd1" title="Get number of available probe format slots.">doca_pcc_cap_get_num_probe_format_slots()</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input</li>
<li>DOCA_ERROR_NOT_SUPPORTED - the device does not support setting probe packet format</li>
<li>DOCA_ERROR_BAD_STATE - PCC context is already started </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga50545c303fa582495733618c6d5e888a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga50545c303fa582495733618c6d5e888a">&#9670;&nbsp;</a></span>doca_pcc_set_ifa2_probe_packet_format()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_pcc_set_ifa2_probe_packet_format </td>
          <td>(</td>
          <td class="paramtype">struct doca_pcc *&#160;</td>
          <td class="paramname"><em>pcc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>probe_format_slot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set ifa2 probe packet format for the pcc process. </p>
<p>For RP: Sets the packet type to send to ifa2 when an rtt probe is requested. For NP: defines ifa2 packet type to identify and send to the NP device side code</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pcc</td><td>- PCC context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">probe_format_slot</td><td>- format slot to configure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__DOCA__PCC__HOST.html#gac2006578406372264729fd0f247a9dd1" title="Get number of available probe format slots.">doca_pcc_cap_get_num_probe_format_slots()</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input</li>
<li>DOCA_ERROR_NOT_SUPPORTED - the device does not support setting probe packet format</li>
<li>DOCA_ERROR_BAD_STATE - PCC context is already started </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga4a31ec06b2ecd47fea99b5b1ed02a102"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4a31ec06b2ecd47fea99b5b1ed02a102">&#9670;&nbsp;</a></span>doca_pcc_set_mailbox()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_pcc_set_mailbox </td>
          <td>(</td>
          <td class="paramtype">struct doca_pcc *&#160;</td>
          <td class="paramname"><em>pcc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_request_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_response_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set mailbox attributes to obtain and pass data from and to the device. </p>
<p>Must be set before calling <a class="el" href="group__DOCA__PCC__HOST.html#gac14acc4141443f07b1eea38232781072" title="Start a PCC context Register the pcc process in the NIC hw.">doca_pcc_start()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pcc</td><td>- PCC context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_request_size</td><td>- max size of request data passed to device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_response_size</td><td>- max size of response data passed from device</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input</li>
<li>DOCA_ERROR_BAD_STATE - PCC context is already started </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaa301ffdf2031da378179b3672de5288f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa301ffdf2031da378179b3672de5288f">&#9670;&nbsp;</a></span>doca_pcc_set_print_buffer_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#gabf4c2072da5a4674395e37df60eb4b1c">DOCA_STABLE</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_pcc_set_print_buffer_size </td>
          <td>(</td>
          <td class="paramtype">struct doca_pcc *&#160;</td>
          <td class="paramname"><em>pcc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="____stddef__size__t_8h.html#aa9d55e2f20e580b7445617d0d12fff6e">size_t</a>&#160;</td>
          <td class="paramname"><em>buffer_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set buffer size of DPA print message. </p>
<p>Must be set before calling <a class="el" href="group__DOCA__PCC__HOST.html#gac14acc4141443f07b1eea38232781072" title="Start a PCC context Register the pcc process in the NIC hw.">doca_pcc_start()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pcc</td><td>- PCC context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer_size</td><td>- size of print buffer from the DPA</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input</li>
<li>DOCA_ERROR_BAD_STATE - PCC context is already started </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga9eb357ed7ef0d26f602cbc78d30b33fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9eb357ed7ef0d26f602cbc78d30b33fc">&#9670;&nbsp;</a></span>doca_pcc_set_thread_affinity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#gabf4c2072da5a4674395e37df60eb4b1c">DOCA_STABLE</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_pcc_set_thread_affinity </td>
          <td>(</td>
          <td class="paramtype">struct doca_pcc *&#160;</td>
          <td class="paramname"><em>pcc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num_threads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>affinity_configs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure affinity of threads handling CC events. </p>
<p>Must be set before calling <a class="el" href="group__DOCA__PCC__HOST.html#gac14acc4141443f07b1eea38232781072" title="Start a PCC context Register the pcc process in the NIC hw.">doca_pcc_start()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pcc</td><td>- PCC context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_threads</td><td>- number of threads used by pcc. Should be constrained by minimum and maximum allowed number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__DOCA__PCC__HOST.html#ga827be97366d1089f855b606366fb77a7" title="Get a minimal required number of threads handling CC events.">doca_pcc_get_min_num_threads()</a> <a class="el" href="iso646_8h.html#aa3d7d535cf450b91b9cb6d9cee2edbb9">and</a> <a class="el" href="group__DOCA__PCC__HOST.html#ga9731d6386f86bbb69999646bc2e1811a" title="Get a maximal allowed number of threads handling CC events.">doca_pcc_get_max_num_threads()</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">affinity_configs</td><td>- array of indexes to assign to threads</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input or invalid number of threads</li>
<li>DOCA_ERROR_BAD_STATE - PCC context is already started </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga329327c70ee4595f1c8be3dc9c0ed5fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga329327c70ee4595f1c8be3dc9c0ed5fb">&#9670;&nbsp;</a></span>doca_pcc_set_trace_message()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#gabf4c2072da5a4674395e37df60eb4b1c">DOCA_STABLE</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_pcc_set_trace_message </td>
          <td>(</td>
          <td class="paramtype">struct doca_pcc *&#160;</td>
          <td class="paramname"><em>pcc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>trace_message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set message for trace printing. </p>
<p>Must be set before calling <a class="el" href="group__DOCA__PCC__HOST.html#gac14acc4141443f07b1eea38232781072" title="Start a PCC context Register the pcc process in the NIC hw.">doca_pcc_start()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pcc</td><td>- PCC context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trace_message</td><td>- message to be printed from trace</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input</li>
<li>DOCA_ERROR_BAD_STATE - PCC context is already started</li>
<li>DOCA_ERROR_NO_MEMORY - in case of failure in internal memory allocation </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gac14acc4141443f07b1eea38232781072"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac14acc4141443f07b1eea38232781072">&#9670;&nbsp;</a></span>doca_pcc_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#gabf4c2072da5a4674395e37df60eb4b1c">DOCA_STABLE</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_pcc_start </td>
          <td>(</td>
          <td class="paramtype">struct doca_pcc *&#160;</td>
          <td class="paramname"><em>pcc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start a PCC context Register the pcc process in the NIC hw. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pcc</td><td>- PCC context</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input</li>
<li>DOCA_ERROR_DRIVER - in case of error in a DOCA driver call</li>
<li>DOCA_ERROR_NO_MEMORY - in case of failure in internal memory allocation</li>
<li>DOCA_ERROR_NOT_SUPPORTED - the device does not support the PCC role </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga791500567a3fe79dbdea97c44676505e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga791500567a3fe79dbdea97c44676505e">&#9670;&nbsp;</a></span>doca_pcc_stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#gabf4c2072da5a4674395e37df60eb4b1c">DOCA_STABLE</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_pcc_stop </td>
          <td>(</td>
          <td class="paramtype">struct doca_pcc *&#160;</td>
          <td class="paramname"><em>pcc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stop a PCC context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pcc</td><td>- PCC context</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input</li>
<li>DOCA_ERROR_DRIVER - in case of error in a DOCA driver call </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga97741252bbe4c287ce470d42d0bbb388"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga97741252bbe4c287ce470d42d0bbb388">&#9670;&nbsp;</a></span>doca_pcc_trace_buf_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_pcc_trace_buf_get </td>
          <td>(</td>
          <td class="paramtype">struct doca_pcc *&#160;</td>
          <td class="paramname"><em>pcc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>buf_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>buf_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get trace buffer address to write trace into. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pcc</td><td>- PCC context </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buf_addr</td><td>- Address to the user allocated buffer used to write device trace into </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buf_size</td><td>- Size of the user allocated buffer to write device trace into</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>DOCA_SUCCESS - in case of success</li>
<li>DOCA_ERROR_INVALID_VALUE - received invalid null input </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gae56cf045ba3495cd8e59c4c5604845f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae56cf045ba3495cd8e59c4c5604845f0">&#9670;&nbsp;</a></span>doca_pcc_trace_buf_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_pcc_trace_buf_set </td>
          <td>(</td>
          <td class="paramtype">struct doca_pcc *&#160;</td>
          <td class="paramname"><em>pcc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>buf_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set trace buffer address to write trace into. </p>
<p>Must be set before calling <a class="el" href="group__DOCA__PCC__HOST.html#gac14acc4141443f07b1eea38232781072" title="Start a PCC context Register the pcc process in the NIC hw.">doca_pcc_start()</a> </p><dl class="section note"><dt>Note</dt><dd>if not set by this function or <a class="el" href="group__DOCA__PCC__HOST.html#ga8bee4b3c7a970d5379e2ca2044c9f127" title="Set trace file path to write trace into.">doca_pcc_trace_file_set()</a> then stdout will be used by default</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pcc</td><td>- PCC context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_addr</td><td>- Address to the user allocated buffer to write device trace into </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_size</td><td>- Size of the user allocated buffer to write device trace into</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>DOCA_SUCCESS - in case of success</li>
<li>DOCA_ERROR_INVALID_VALUE - received invalid null input</li>
<li>DOCA_ERROR_BAD_STATE - PCC context is already started</li>
<li>DOCA_ERROR_OPERATING_SYSTEM - error occurred in opening the file </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga168e379bc7e9121711b8193eb39d41d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga168e379bc7e9121711b8193eb39d41d9">&#9670;&nbsp;</a></span>doca_pcc_trace_file_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_pcc_trace_file_get </td>
          <td>(</td>
          <td class="paramtype">struct doca_pcc *&#160;</td>
          <td class="paramname"><em>pcc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>file_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>file_path_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get trace file path to write trace into. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pcc</td><td>- PCC context </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">file_path</td><td>- pathname to the trace file to write device trace into </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">file_path_len</td><td>- file_path length. Output is actual number of bytes written</td></tr>
  </table>
  </dd>
</dl>
<p>The file_path buffer is allocated by the caller along with setting file_path_len indicating the length that was allocated. Upon return the file_path_len field is set to the actual length of the file_path</p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>DOCA_SUCCESS - in case of success</li>
<li>DOCA_ERROR_NO_MEMORY - memory allocation error</li>
<li>DOCA_ERROR_INVALID_VALUE - received invalid null input </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga8bee4b3c7a970d5379e2ca2044c9f127"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8bee4b3c7a970d5379e2ca2044c9f127">&#9670;&nbsp;</a></span>doca_pcc_trace_file_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#ga7e516bdfce0f7716193136a17046d1ba">DOCA_EXPERIMENTAL</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_pcc_trace_file_set </td>
          <td>(</td>
          <td class="paramtype">struct doca_pcc *&#160;</td>
          <td class="paramname"><em>pcc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file_path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set trace file path to write trace into. </p>
<p>Must be set before calling <a class="el" href="group__DOCA__PCC__HOST.html#gac14acc4141443f07b1eea38232781072" title="Start a PCC context Register the pcc process in the NIC hw.">doca_pcc_start()</a> </p><dl class="section note"><dt>Note</dt><dd>if not set by this function or <a class="el" href="group__DOCA__PCC__HOST.html#gae56cf045ba3495cd8e59c4c5604845f0" title="Set trace buffer address to write trace into.">doca_pcc_trace_buf_set()</a> then stdout will be used by default</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pcc</td><td>- PCC context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">file_path</td><td>- pathname to the trace file to write device trace into</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>DOCA_SUCCESS - in case of success</li>
<li>DOCA_ERROR_INVALID_VALUE - received invalid null input</li>
<li>DOCA_ERROR_BAD_STATE - PCC context is already started</li>
<li>DOCA_ERROR_NO_MEMORY - memory allocation error</li>
<li>DOCA_ERROR_OPERATING_SYSTEM - error occurred in opening the file </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga7d44e3cbf7230d8f889165578615a04c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d44e3cbf7230d8f889165578615a04c">&#9670;&nbsp;</a></span>doca_pcc_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__DOCA__COMPAT.html#gabf4c2072da5a4674395e37df60eb4b1c">DOCA_STABLE</a> <a class="el" href="group__DOCA__ERROR.html#ga709800305e1197db067f30025480b7c5">doca_error_t</a> doca_pcc_wait </td>
          <td>(</td>
          <td class="paramtype">struct doca_pcc *&#160;</td>
          <td class="paramname"><em>pcc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>wait_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait on events or timeout from device for given time in seconds. </p>
<p>Providing a negative value for wait time will cause the context to wait on events until the user terminates it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pcc</td><td>- PCC context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wait_time</td><td>- time in seconds to wait</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DOCA_SUCCESS - in case of success doca_error code - in case of failure:<ul>
<li>DOCA_ERROR_INVALID_VALUE - received invalid input</li>
<li>DOCA_ERROR_BAD_STATE - in case pcc is not started </li>
</ul>
</dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Wed Aug 13 2025 08:00:17 for NVIDIA DOCA SDK by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
