/*
 * Copyright (c) 2023 NVIDIA CORPORATION AND AFFILIATES.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted
 * provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright notice, this list of
 *       conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright notice, this list of
 *       conditions and the following disclaimer in the documentation and/or other materials
 *       provided with the distribution.
 *     * Neither the name of the NVIDIA CORPORATION nor the names of its contributors may be used
 *       to endorse or promote products derived from this software without specific prior written
 *       permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NVIDIA CORPORATION BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TOR (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#include <doca_buf.h>
#include <doca_buf_inventory.h>
#include <doca_error.h>
#include <doca_mmap.h>
#include <doca_pe.h>
#include <doca_types.h>
#include <doca_log.h>

#include <doca_urom.h>
#include <doca_urom_plugin.h>

#include <worker_sandbox.h>
#include <urom_sandbox.h>

DOCA_LOG_REGISTER(UROM::WORKER::SANDBOX);

/* SANDBOX task metadata */
struct doca_sandbox_task_data {
	union doca_data cookie; /* User cookie */
	union {
		urom_sandbox_mem_map_finished mem_map_cb; /* User memory map task callback */
		urom_sandbox_send_finished send_cb;	  /* User tag send task callback */
		urom_sandbox_recv_finished recv_cb;	  /* User tag recv task callback */
	};
};

static uint64_t sandbox_id;		/* Sandbox plugin id, id is generated by UROM lib and
					 * will be updated in init function
					 */
static uint64_t sandbox_version = 0x01; /* Sandbox plugin host version */

/*
 * Sandbox notification unpack function
 *
 * @packed_notif [in]: packed sandbox notification buffer
 * @sandbox_notif [out]: set unpacked sandbox notification
 * @return: DOCA_SUCCESS on success and DOCA_ERROR otherwise
 */
static doca_error_t urom_worker_sandbox_notif_unpack(void *packed_notif,
						     struct urom_worker_notify_sandbox **sandbox_notif)
{
	void *ptr;

	*sandbox_notif = packed_notif;
	ptr = packed_notif + sizeof(struct urom_worker_notify_sandbox);

	switch ((*sandbox_notif)->type) {
	case UROM_WORKER_CMD_SANDBOX_TAG_RECV:
		if ((*sandbox_notif)->tag_recv.buffer)
			(*sandbox_notif)->tag_recv.buffer = ptr;
		break;
	}

	return DOCA_SUCCESS;
}

/*
 * Calculate sandbox packed command size
 *
 * @sandbox_cmd [in]: sandbox command
 * @return: command packed size
 */
static size_t urom_worker_sandbox_cmd_packed_len(struct urom_worker_sandbox_cmd *sandbox_cmd)
{
	size_t pack_len;

	pack_len = sizeof(struct urom_worker_sandbox_cmd);

	/* pack inline data */
	switch (sandbox_cmd->type) {
	case UROM_WORKER_CMD_SANDBOX_MEM_MAP:
		pack_len += sandbox_cmd->mem_map.exported_memh_buffer_len;
		break;
	case UROM_WORKER_CMD_SANDBOX_TAG_SEND:
		if (!sandbox_cmd->tag_send.memh_id)
			pack_len += sandbox_cmd->tag_send.count;
		break;
	}

	return pack_len;
}

/*
 * Pack sandbox command
 *
 * @sandbox_cmd [in]: sandbox command
 * @packed_cmd_len [in/out]: packed command buffer size
 * @packed_cmd [out]: packed command buffer
 * @return: DOCA_SUCCESS on success and DOCA_ERROR otherwise
 */
static doca_error_t urom_worker_sandbox_cmd_pack(struct urom_worker_sandbox_cmd *sandbox_cmd,
						 size_t *packed_cmd_len,
						 void *packed_cmd)
{
	void *pack_tail = packed_cmd;
	void *pack_head;
	size_t pack_len;

	pack_len = urom_worker_sandbox_cmd_packed_len(sandbox_cmd);
	if (pack_len > *packed_cmd_len)
		return DOCA_ERROR_INITIALIZATION;

	/* pack base command */
	pack_len = sizeof(struct urom_worker_sandbox_cmd);
	pack_head = urom_sandbox_serialize_next_raw(&pack_tail, void, pack_len);
	memcpy(pack_head, sandbox_cmd, pack_len);
	*packed_cmd_len = pack_len;

	/* pack inline data */
	switch (sandbox_cmd->type) {
	case UROM_WORKER_CMD_SANDBOX_MEM_MAP:
		pack_len = sandbox_cmd->mem_map.exported_memh_buffer_len;
		pack_head = urom_sandbox_serialize_next_raw(&pack_tail, void, pack_len);
		memcpy(pack_head, sandbox_cmd->mem_map.map_params.exported_memh_buffer, pack_len);
		*packed_cmd_len += pack_len;
		break;
	case UROM_WORKER_CMD_SANDBOX_TAG_SEND:
		if (!sandbox_cmd->tag_send.memh_id) {
			pack_len = sandbox_cmd->tag_send.count;
			pack_head = urom_sandbox_serialize_next_raw(&pack_tail, void, pack_len);
			memcpy(pack_head, (void *)sandbox_cmd->tag_send.buffer, pack_len);
			*packed_cmd_len += pack_len;
		}
		break;
	}

	return DOCA_SUCCESS;
}

/*
 * Sandbox tag send command completion callback function, user callback will be called inside the function
 *
 * @task [in]: UROM worker task
 * @task_user_data [in]: task user data
 * @ctx_user_data [in]: worker context user data
 */
static void urom_sandbox_send_completed(struct doca_urom_worker_cmd_task *task,
					union doca_data task_user_data,
					union doca_data ctx_user_data)
{
	(void)task_user_data;
	(void)ctx_user_data;

	size_t data_len;
	doca_error_t result;
	struct doca_buf *response;
	struct urom_worker_notify_sandbox notify_error = {0};
	struct urom_worker_notify_sandbox *sandbox_notify = &notify_error;
	struct doca_sandbox_task_data *task_data;
	union doca_data context = {0};

	task_data = (struct doca_sandbox_task_data *)doca_urom_worker_cmd_task_get_user_data(task);
	if (task_data == NULL) {
		DOCA_LOG_ERR("Failed to get task data buffer");
		goto task_release;
	}

	response = doca_urom_worker_cmd_task_get_response(task);
	if (response == NULL) {
		DOCA_LOG_ERR("Failed to get task response buffer");
		result = DOCA_ERROR_INVALID_VALUE;
		goto error_exit;
	}

	result = doca_buf_get_data(response, (void **)&sandbox_notify);
	if (result != DOCA_SUCCESS)
		goto error_exit;

	result = doca_buf_get_data_len(response, &data_len);
	if (result != DOCA_SUCCESS) {
		DOCA_LOG_ERR("Failed to get response data length");
		goto error_exit;
	}

	result = doca_task_get_status(doca_urom_worker_cmd_task_as_task(task));
	if (result != DOCA_SUCCESS)
		goto error_exit;

	if (data_len != sizeof(*sandbox_notify)) {
		DOCA_LOG_ERR("Task response data length is different from notification expected length");
		result = DOCA_ERROR_INVALID_VALUE;
		goto error_exit;
	}

error_exit:
	context.u64 = sandbox_notify->tag_send.context;
	(task_data->send_cb)(result, task_data->cookie, context, sandbox_notify->tag_send.status);

task_release:
	result = doca_urom_worker_cmd_task_release(task);
	if (result != DOCA_SUCCESS)
		DOCA_LOG_ERR("Failed to release worker command task %s", doca_error_get_descr(result));
}

doca_error_t urom_sandbox_tag_task_send(struct doca_urom_worker *worker_ctx,
					union doca_data cookie,
					union doca_data context,
					uint64_t dest,
					uint64_t buffer,
					uint64_t count,
					uint64_t tag,
					uint64_t memh_id,
					urom_sandbox_send_finished cb)
{
	doca_error_t result;
	size_t cmd_len = 0;
	struct doca_buf *payload;
	struct doca_urom_worker_cmd_task *task;
	struct doca_sandbox_task_data *task_data;
	struct urom_worker_sandbox_cmd *sandbox_cmd;

	/* Allocate task */
	result = doca_urom_worker_cmd_task_allocate_init(worker_ctx, sandbox_id, &task);
	if (result != DOCA_SUCCESS)
		return result;

	payload = doca_urom_worker_cmd_task_get_payload(task);
	result = doca_buf_get_data(payload, (void **)&sandbox_cmd);
	if (result != DOCA_SUCCESS)
		goto task_destroy;

	result = doca_buf_get_data_len(payload, &cmd_len);
	if (result != DOCA_SUCCESS)
		goto task_destroy;

	/* Populate commands attributes */
	sandbox_cmd->type = UROM_WORKER_CMD_SANDBOX_TAG_SEND;
	sandbox_cmd->tag_send.context = context.u64;
	sandbox_cmd->tag_send.dest = dest;
	sandbox_cmd->tag_send.buffer = (uint64_t)buffer;
	sandbox_cmd->tag_send.count = count;
	sandbox_cmd->tag_send.tag = tag;
	sandbox_cmd->tag_send.memh_id = memh_id;

	urom_worker_sandbox_cmd_pack(sandbox_cmd, &cmd_len, (void *)sandbox_cmd);

	doca_buf_set_data(payload, sandbox_cmd, cmd_len);

	task_data = (struct doca_sandbox_task_data *)doca_urom_worker_cmd_task_get_user_data(task);
	task_data->send_cb = cb;
	task_data->cookie = cookie;

	doca_urom_worker_cmd_task_set_cb(task, urom_sandbox_send_completed);
	result = doca_task_submit(doca_urom_worker_cmd_task_as_task(task));
	if (result != DOCA_SUCCESS)
		goto task_destroy;

	return DOCA_SUCCESS;
task_destroy:
	doca_urom_worker_cmd_task_release(task);
	return result;
}

/*
 * Sandbox tag recv command completion callback function, user callback will be called inside the function
 *
 * @task [in]: UROM worker task
 * @task_user_data [in]: task user data
 * @ctx_user_data [in]: worker context user data
 */
static void urom_sandbox_recv_completed(struct doca_urom_worker_cmd_task *task,
					union doca_data task_user_data,
					union doca_data ctx_user_data)
{
	(void)task_user_data;
	(void)ctx_user_data;

	size_t data_len, extended_mem = 0;
	doca_error_t result;
	struct doca_buf *response;
	struct urom_worker_notify_sandbox notify_error = {0};
	struct urom_worker_notify_sandbox *sandbox_notify = &notify_error;
	struct doca_sandbox_task_data *task_data;
	union doca_data context;

	task_data = (struct doca_sandbox_task_data *)doca_urom_worker_cmd_task_get_user_data(task);
	if (task_data == NULL) {
		DOCA_LOG_ERR("Failed to get task data buffer");
		goto task_release;
	}

	response = doca_urom_worker_cmd_task_get_response(task);
	if (response == NULL) {
		DOCA_LOG_ERR("Failed to get task response buffer");
		result = DOCA_ERROR_INVALID_VALUE;
		goto error_exit;
	}

	result = doca_buf_get_data_len(response, &data_len);
	if (result != DOCA_SUCCESS) {
		DOCA_LOG_ERR("Failed to get response data length");
		goto error_exit;
	}

	result = doca_buf_get_data(response, (void **)&sandbox_notify);
	if (result != DOCA_SUCCESS)
		goto error_exit;

	result = urom_worker_sandbox_notif_unpack((void *)sandbox_notify, &sandbox_notify);
	if (result != DOCA_SUCCESS)
		goto error_exit;

	result = doca_task_get_status(doca_urom_worker_cmd_task_as_task(task));
	if (result != DOCA_SUCCESS)
		goto error_exit;

	if (sandbox_notify->tag_recv.buffer != NULL)
		extended_mem = sandbox_notify->tag_recv.count;

	if (data_len != sizeof(*sandbox_notify) + extended_mem) {
		DOCA_LOG_ERR("Task response data length is different from notification expected length");
		result = DOCA_ERROR_INVALID_VALUE;
		goto error_exit;
	}

error_exit:
	context.u64 = sandbox_notify->tag_recv.context;
	(task_data->recv_cb)(result,
			     task_data->cookie,
			     context,
			     sandbox_notify->tag_recv.buffer,
			     sandbox_notify->tag_recv.count,
			     sandbox_notify->tag_recv.sender_tag,
			     sandbox_notify->tag_recv.status);

task_release:
	result = doca_urom_worker_cmd_task_release(task);
	if (result != DOCA_SUCCESS)
		DOCA_LOG_ERR("Failed to release worker command task %s", doca_error_get_descr(result));
}

doca_error_t urom_sandbox_tag_task_recv(struct doca_urom_worker *worker_ctx,
					union doca_data cookie,
					union doca_data context,
					uint64_t buffer,
					uint64_t count,
					uint64_t tag,
					uint64_t tag_mask,
					uint64_t memh_id,
					urom_sandbox_recv_finished cb)
{
	doca_error_t result;
	size_t pack_len = 0;
	struct doca_buf *payload;
	struct doca_urom_worker_cmd_task *task;
	struct doca_sandbox_task_data *task_data;
	struct urom_worker_sandbox_cmd *sandbox_cmd;

	/* Allocate task */
	result = doca_urom_worker_cmd_task_allocate_init(worker_ctx, sandbox_id, &task);
	if (result != DOCA_SUCCESS)
		return result;

	payload = doca_urom_worker_cmd_task_get_payload(task);
	result = doca_buf_get_data(payload, (void **)&sandbox_cmd);
	if (result != DOCA_SUCCESS)
		goto task_destroy;
	result = doca_buf_get_data_len(payload, &pack_len);
	if (result != DOCA_SUCCESS)
		goto task_destroy;

	/* Populate commands attributes */
	sandbox_cmd->type = UROM_WORKER_CMD_SANDBOX_TAG_RECV;
	sandbox_cmd->tag_recv.context = context.u64;
	sandbox_cmd->tag_recv.buffer = (uint64_t)buffer;
	sandbox_cmd->tag_recv.count = count;
	sandbox_cmd->tag_recv.tag = tag;
	sandbox_cmd->tag_recv.tag_mask = tag_mask;
	sandbox_cmd->tag_recv.memh_id = memh_id;

	urom_worker_sandbox_cmd_pack(sandbox_cmd, &pack_len, (void *)sandbox_cmd);

	doca_buf_set_data(payload, sandbox_cmd, pack_len);

	task_data = (struct doca_sandbox_task_data *)doca_urom_worker_cmd_task_get_user_data(task);
	task_data->recv_cb = cb;
	task_data->cookie = cookie;

	doca_urom_worker_cmd_task_set_cb(task, urom_sandbox_recv_completed);
	result = doca_task_submit(doca_urom_worker_cmd_task_as_task(task));
	if (result != DOCA_SUCCESS)
		goto task_destroy;

	return DOCA_SUCCESS;

task_destroy:
	doca_urom_worker_cmd_task_release(task);
	return result;
}

/*
 * Sandbox memory map command completion callback function, user callback will be called inside the function
 *
 * @task [in]: UROM worker task
 * @task_user_data [in]: task user data
 * @ctx_user_data [in]: worker context user data
 */
static void urom_sandbox_mem_map_completed(struct doca_urom_worker_cmd_task *task,
					   union doca_data task_user_data,
					   union doca_data ctx_user_data)
{
	(void)task_user_data;
	(void)ctx_user_data;

	size_t data_len;
	doca_error_t result;
	struct doca_buf *response;
	struct urom_worker_notify_sandbox notify_error = {0};
	struct urom_worker_notify_sandbox *sandbox_notify = &notify_error;
	struct doca_sandbox_task_data *task_data;
	union doca_data context = {0};

	task_data = (struct doca_sandbox_task_data *)doca_urom_worker_cmd_task_get_user_data(task);
	if (task_data == NULL) {
		DOCA_LOG_ERR("Failed to get task data buffer");
		goto task_release;
	}

	response = doca_urom_worker_cmd_task_get_response(task);
	if (response == NULL) {
		DOCA_LOG_ERR("Failed to get task response buffer");
		result = DOCA_ERROR_INVALID_VALUE;
		goto error_exit;
	}

	result = doca_buf_get_data(response, (void **)&sandbox_notify);
	if (result != DOCA_SUCCESS)
		goto error_exit;

	result = doca_buf_get_data_len(response, &data_len);
	if (result != DOCA_SUCCESS) {
		DOCA_LOG_ERR("Failed to get response data length");
		goto error_exit;
	}

	result = doca_task_get_status(doca_urom_worker_cmd_task_as_task(task));
	if (result != DOCA_SUCCESS)
		goto error_exit;

	if (data_len != sizeof(*sandbox_notify)) {
		DOCA_LOG_ERR("Task response data length is different from notification expected length");
		result = DOCA_ERROR_INVALID_VALUE;
		goto error_exit;
	}

error_exit:
	context.u64 = sandbox_notify->mem_map.context;
	(task_data->mem_map_cb)(result, task_data->cookie, context, sandbox_notify->mem_map.memh_id);

task_release:
	result = doca_urom_worker_cmd_task_release(task);
	if (result != DOCA_SUCCESS)
		DOCA_LOG_ERR("Failed to release worker command task %s", doca_error_get_descr(result));
}

doca_error_t urom_sandbox_task_mem_map(struct doca_urom_worker *worker_ctx,
				       union doca_data cookie,
				       union doca_data context,
				       ucp_mem_map_params_t map_params,
				       size_t exported_memh_buffer_len,
				       urom_sandbox_mem_map_finished cb)
{
	size_t pack_len = 0;
	doca_error_t result;
	struct doca_buf *payload;
	struct doca_urom_worker_cmd_task *task;
	struct doca_sandbox_task_data *task_data;
	struct urom_worker_sandbox_cmd *sandbox_cmd;

	/* Allocate task */
	result = doca_urom_worker_cmd_task_allocate_init(worker_ctx, sandbox_id, &task);
	if (result != DOCA_SUCCESS)
		return result;

	payload = doca_urom_worker_cmd_task_get_payload(task);
	result = doca_buf_get_data(payload, (void **)&sandbox_cmd);
	if (result != DOCA_SUCCESS)
		goto task_destroy;

	result = doca_buf_get_data_len(payload, &pack_len);
	if (result != DOCA_SUCCESS)
		goto task_destroy;

	/* Populate commands attributes */
	sandbox_cmd->type = UROM_WORKER_CMD_SANDBOX_MEM_MAP;
	sandbox_cmd->mem_map.context = context.u64;
	memcpy(&sandbox_cmd->mem_map.map_params, &map_params, sizeof(ucp_mem_map_params_t));
	sandbox_cmd->mem_map.exported_memh_buffer_len = exported_memh_buffer_len;

	urom_worker_sandbox_cmd_pack(sandbox_cmd, &pack_len, (void *)sandbox_cmd);

	doca_buf_set_data(payload, sandbox_cmd, pack_len);

	task_data = (struct doca_sandbox_task_data *)doca_urom_worker_cmd_task_get_user_data(task);
	task_data->mem_map_cb = cb;
	task_data->cookie = cookie;

	doca_urom_worker_cmd_task_set_cb(task, urom_sandbox_mem_map_completed);
	result = doca_task_submit(doca_urom_worker_cmd_task_as_task(task));
	if (result != DOCA_SUCCESS)
		goto task_destroy;

	return DOCA_SUCCESS;

task_destroy:
	doca_urom_worker_cmd_task_release(task);
	return result;
}

doca_error_t urom_sandbox_init(uint64_t plugin_id, uint64_t version)
{
	if (version != sandbox_version)
		return DOCA_ERROR_UNSUPPORTED_VERSION;

	sandbox_id = plugin_id;

	return DOCA_SUCCESS;
}
